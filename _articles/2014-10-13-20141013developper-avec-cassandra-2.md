---
ID: 147
post_title: Développer avec Cassandra 2
author: Gérald Quintana
post_date: 2014-10-13 14:00:00
post_excerpt: "<p>Depuis l'arrivée de CQL3, et la marginalisation progressive de Thrift, certaines librairies comme Hector ou Astyanax autrefois célèbres, sont aujourd'hui démodées. Dans cet article, nous ferons le point sur les outils actuels pour développer en Java avec Cassandra et CQL3.</p>"
layout: post
permalink: http://blog.zenika-offres.com/?p=147
published: true
---
<p>Depuis l'arrivée de CQL3, et la marginalisation progressive de Thrift, certaines librairies comme Hector ou Astyanax autrefois célèbres, sont aujourd'hui démodées. Dans cet article, nous ferons le point sur les outils actuels pour développer en Java avec Cassandra et CQL3.</p>
<!--more-->
<h3>Le driver Java</h3> <p>Les base de données relationnelles ont leur driver JDBC; Cassandra a son driver Java.  Certes il n'implémente pas JDBC, mais il s'en inspire fortement. L'API proposée est même plus moderne et mieux conçue que le JDBC:</p> <pre>     session.execute(         &quot;insert into utilisateur (id, nom, prenom, date_naissance) values (?,?,?,?)&quot;,         utilisateur.getId(), utilisateur.getNom(), utilisateur.getPrenom(), utilisateur.getDateNaissance()); </pre> <p>La <code>Session</code> est l'équivalent d'une connexion, elle est associée à un keyspace et est thread-safe. On retrouve les notions de <code>PreparedStatement</code> et de <code>ResultSet</code> sauf qu'il n'est pas nécessaire de les fermer après usage:</p> <pre>     Statement statement = session         .prepare(&quot;select id, nom, prenom from utilisateur where id = ?&quot;)         .setConsistencyLevel(ConsistencyLevel.LOCAL_QUORUM)         .bind(id);     ResultSet resultSet = session.execute(statement);     Row row = resultSet.one();     Utilisateur utilisateur = new Utilisateur(         row.getString(&quot;id&quot;), row.getString(&quot;prenom&quot;),         row.getString(&quot;nom&quot;), row.getDate(&quot;date_naissance&quot;)); </pre> <p>On peut utiliser les <code>PreparedStatement</code> avec des paramètres nommés plutôt qu'indexés:</p> <pre>     Statement statement = session.prepare(&quot;select id, nom, prenom, date_naissance from utilisateur where id = :id&quot;)             .setConsistencyLevel(ConsistencyLevel.LOCAL_QUORUM)             .bind().setString(&quot;id&quot;, id);     Row row = session.execute(statement).one(); </pre> <p>On trouve le nécessaire pour construire les requêtes à la sauce "fluent" comme QueryDSL ou les Criteria JPA (le typage fort en moins):</p> <pre>     ResultSet resultSet = session.execute(         select(&quot;id&quot;,&quot;nom&quot;,&quot;prenom&quot;).from(&quot;utilisateur&quot;).where(eq(id, id))         .setConsistencyLevel(ConsistencyLevel.LOCAL_QUORUM)); </pre> <p>Les requêtes peuvent être exécutées de manière asynchrone, le driver s'appuie sur les <code>ListenableFuture</code> de Guava, les adeptes d'architectures orientés événements (VertX par exemple) apprécieront.</p> <p>Néanmoins, le driver en lui même ne propose pas de mécanisme de conversion de la <code>Row</code> en objet.</p> <h3>Intégration avec Spring</h3> <p>Dans une application Spring, selon que l'on utilise la configuration XML traditionnelle ou la JavaConfig la manière de se connecter à Cassandra sera un peu différente.</p> <p>Si la configuration Spring est exprimée en Java, l'utilisation du Driver Java suffit à configurer la connexion au cluster Cassandra:</p> <pre>     @Bean(destroyMethod = &quot;close&quot;)     public Cluster cluster() {         return Cluster.builder()                 .addContactPoint(&quot;zencassandra1&quot;)                 .addContactPoint(&quot;zencassandra2&quot;)                 .withClusterName(&quot;zencluster&quot;)                 .build();     }     @Bean(destroyMethod = &quot;close&quot;)     public Session session() {         return cluster().connect(&quot;zenmessage&quot;);     } </pre> <p>Comme la <code>Session</code> est thread-safe, on peut en faire un singleton et l'injecter telle quelle dans les repositories.</p> <p>Si la configuration Spring est exprimée en XML, il faudra aller chercher dans Spring Data Cassandra, les <code>FactoryBean</code> ou bien le namespace <code>&lt;cassandra:...&gt;</code> nécessaires à la configuration:</p> <pre>     &lt;cassandra:cluster contact-points=&quot;zencassandra1,zencassandra2&quot; /&gt;     &lt;cassandra:session keyspace-name=&quot;zenmessage&quot; /&gt; </pre> <h3>Spring Data Cassandra</h3> <p>A l'instar des autres membres du groupe Spring Data (JPA, MongoDB, etc), Spring Data Cassandra permet de générer dynamiquement les repositories et d'automatiser les opérations de CRUD. Pour cela, Spring Data Cassandra s'appuie sur le driver Java.</p> <pre> public interface UtilisateurRepository extends CassandraRepository&lt;Utilisateur, String&gt; { } </pre> <p>La classe <code>Utilisateur</code> se voit affublée d'annotations décrivant le mapping et permettant d'automatiser le mapping ligne/objet:</p> <pre>     @Table     public class Utilisateur {         @PrimaryKey String id;         String prenom;         String nom;         @Column(&quot;date_naissance&quot;) Date dateNaissance; </pre> <p>Calqué sur le <code>JdbcTemplate</code>, Spring Data Cassandra fournit un <code>CassandraTemplate</code>, ou plutôt des CassandraTemplates puis qu'il y en a 2. Le <code>CqlTemplate</code> reste très proche du JdbcTemplate et apporte peu de choses par rapport au driver. Le <code>CassandraTemplate</code> apporte les fonctionnalités de conversion de ligne /objet basée sur annotations:</p> <pre>     Utilisateur utilisateur = cassandraTemplate.selectOne(         select(&quot;id&quot;,&quot;nom&quot;,&quot;prenom&quot;,&quot;date_naissance&quot;)             .from(&quot;utilisateur&quot;).where(eq(&quot;id&quot;, id)).limit(1),         Utilisateur.class); </pre> <p>A l'heure où j'écris ces lignes, Spring Data Cassandra n'est pas compatible avec les drivers de la version 2.1, il faut se limiter à la version 2.0.</p> <h3>Achilles</h3> <p>Achilles s'inspire fortement de JPA pour proposer un outil de mapping Objet. Comme JPA, il est capable de créer les tables (DDL), de marquer les changements sur les entités (dirty checking), de s'intégrer avec Bean Validation... Les possibilités de mapping sont aussi nettement supérieures à celles de Spring Data.</p> <pre>     @Entity(table=&quot;utilisateur&quot;)     public class Utilisateur {         @Id      String id;         @Column  String prenom;         @Column  String nom;         @Column(name = &quot;date_naissance&quot;) Date dateNaissance;     persistenceManager.insert(utilisateur);     List&lt;Utilisateur&gt; utilisateurs = persistenceManager.typedQuery(Utilisateur.class,         select().from(&quot;utilisateur&quot;)).get();     Utilisateur utilisateur = persistenceManager.find(Utilisateur.class, id); </pre> <p>Contrairement à JPA, Achilles est stateless: Les entités ne sont jamais attachées, il n'y a pas de cache de premier niveau. Pour prototyper une modélisation et la valider rapidement, c'est un outil très efficace: On pose quelques annotations sur des POJO et les tables se créent, s'alimentent, et se requêtent les yeux fermés.</p> <h3>Cassandra Java Mapper</h3> <p>Depuis la toute récente version 2.1 de Cassandra, DataStax fournit une extension au driver Java, le mapper. Lui aussi utilise des annotations pour décrire le mapping objet:</p> <pre>     @Table(name = &quot;utilisateur&quot;)     public class Utilisateur {         @PartitionKey String id;         String prenom;         String nom;         @Column(name = &quot;date_naissance&quot;) Date dateNaissance;     Mapper&lt;Utilisateur&gt; mapper = mappingManager.mapper(Utilisateur.class);     Utilisateur utilisateur = mapper.get(id);     List&lt;Utilisateur&gt; utilisateurs = mapper.map(session.execute(&quot;select id, nom, prenom, date_naissance from utilisateur&quot;)).all(); </pre> <p>Le mapping ligne/objet, c'était justement ce qu'il manquait au driver de base. Voilà une lacune comblée!</p> <h3>CassandraUnit pour les tests automatisés</h3> <p>Pour tester une couche d'accès aux données Cassandra (DAO), il est très pratique de pouvoir démarrer un Cassandra embarqué: Achilles et Cassandra Unit permettent ça.</p> <pre>     // Cassandra Unit     EmbeddedCassandraServerHelper.startEmbeddedCassandra(         &quot;/cassandra.yaml&quot;, // Fichier de configuration Cassandra         &quot;target/cassandra&quot; // Dossier contenant les données, logs...         ); </pre> <pre>     // Achilles Embedded     Session session = CassandraEmbeddedServerBuilder             .withEntities(Utilisateur.class)             .withClusterName(&quot;test_cluster&quot;)             .cleanDataFilesAtStartup(true)             .withKeyspaceName(&quot;test_ks&quot;)             .withCQLPort(9042)             .buildNativeSessionOnly()
; </pre> <p>En pratique, le temps de démarrage d'un Cassandra est plus long et gourmand qu'une base de données du style H2DB, l'utilisation d'un Cassandra embarqué est donc discutable. La variante Achilles Embedded configure Cassandra avec des valeurs par défaut convenables, ce qui évite d'avoir un fichier de configuration <code>cassandra.yaml</code></p> <p>Pour charger des jeux de données dans les tables, CassandraUnit imite DBUnit. Les DataSets seront toutefois exprimés sous forme de  scripts CQL. Pour charger ces DataSet et faire le nettoyage, il y a une <code>Rule</code> JUnit</p> <pre>     @Rule     public CassandraCQLUnit cassandra = new CassandraCQLUnit(         new ClassPathCQLDataSet(&quot;zenmessage-data.cql&quot;, &quot;zenmessage&quot;),         &quot;/cassandra.yaml&quot;, &quot;localhost&quot;, 9042); </pre> <p>Et, luxe ultime,  avec le <code>SpringJUnit4ClassRunner</code>, il y a un <code>TestExecutionListener</code> et des annotations.</p> <pre> @RunWith(SpringJUnit4ClassRunner.class) @TestExecutionListeners(CassandraUnitTestExecutionListener.class) @CassandraDataSet(value=&quot;zenmessage-data.cql&quot;) @EmbeddedCassandra public class UtilisateurRepositoryTest { </pre> <p>On regrettera peut-être de ne pas pouvoir utiliser des jeux de données dans des formats plus descriptifs comme XML, CSV... En réalité, la fonctionnalité existe mais s'appuie sur les API Thrift et sur Hector. Cela impose donc de connaître le modèle de données sous forme de <code>ColumnFamily</code>...</p> <h3>Conclusion</h3> <p>Pour lire/écrire des objets depuis/dans Cassandra, le développeur Java a l'embarras du choix. Le driver Java et le mapper associé fournis par DataStax sont remarquablement agréables à utiliser. Quant aux tests automatisés, avec Cassandra Unit, on a rien à envier aux bases de données relationnelles classiques.</p>