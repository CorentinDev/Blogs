---
ID: 233
post_title: 'Séminaire &quot;Expertise Tomcat&quot; : compte-rendu'
author: ocroisier
post_date: 2009-01-26 17:49:00
post_excerpt: |
  <p>Mardi 21 janvier se tenait un séminaire d'une demi-journée organisé par <a href="http://www.springsource.com/">SpringSource</a>, sur les différents aspects de l'utilisation de <a href="http://tomcat.apache.org">Tomcat</a> en production&nbsp;: déploiement, performance, débuggage et monitoring. <br />
  Pour l'occasion, SpringSource avait mis les petits plats dans les grands&nbsp;: récéption dans un grand hôtel à la Défense avec vue panoramique sur Paris et repas gastronomique, et Filip Hanik sur la scène, un des principaux <em>committers</em> sur Tomcat.</p>
layout: post
permalink: http://blog.zenika-offres.com/?p=233
published: true
---
<p>Mardi 21 janvier se tenait un séminaire d'une demi-journée organisé par <a href="http://www.springsource.com/">SpringSource</a>, sur les différents aspects de l'utilisation de <a href="http://tomcat.apache.org">Tomcat</a> en production&nbsp;: déploiement, performance, débuggage et monitoring. <br />
Pour l'occasion, SpringSource avait mis les petits plats dans les grands&nbsp;: récéption dans un grand hôtel à la Défense avec vue panoramique sur Paris et repas gastronomique, et Filip Hanik sur la scène, un des principaux <em>committers</em> sur Tomcat.</p>
<!--more-->
<h3>Large scale Tomcat deployment</h3> <p>Pour cette première séance, Filip a montré comment déployer plusieurs instances de Tomcat de manière simple et flexible. Il suffit pour cela de comprendre la différence entre les variables d'environnement <code>CATALINA_HOME</code> et <code>CATALINA_BASE</code>, et le mécanisme de lancement de Tomcat.</p> <h4>Plus, c'est mieux</h4> <p><img src="/wp-content/uploads/2015/07/Filip_Hanik.jpg" alt="Filip Hanik" style="float:right; margin: 0 0 1em 1em;" title="Filip Hanik" /> Mais tout d'abord, pourquoi voudrait-on lancer plusieurs instances de Tomcat sur une machine&nbsp;? <br />
Selon Filip, il est plus intéressant d'héberger chaque application sur une instance dédiée&nbsp;:</p> <ul> <li>Pour éviter que les fuites mémoire d'une application ne contaminent les autres</li> <li>Parce que les ressources consommées et le temps de lancement additionnels sont négligeables</li> <li>Pour définir des paramètres distincts par application (réglages mémoire, répertoire de log, port d'écoute...)</li> <li>Parce qu'il vaut mieux lancer deux JVM avec 2Go de <em>Heap</em> qu'une seul avec 4Go, à cause du <em>garbage collector</em>.</li> </ul> <h4>La mystérieuse histoire de CATALINA</h4> <p>Si l'on connaît bien la variable d'environnement <code>CATALINA_HOME</code>, qui est décrite dans la documentation, <code>CATALINA_BASE</code> est en revanche généralement méconnue. Leur combinaison est pourtant très utile&nbsp;:</p> <ul> <li><code>CATALINA_HOME</code> représente le répertoire d'installation de Tomcat, contenant les éléments communs aux instances (server.xml, webapps...). Pour une installation mono-instance, il s'agit du répertoire obtenu par décompression de l'archive d'installation&nbsp;; mais il est également possible de séparer les binaires (spécifiques à chaque version) de la configuration, comme dans l'exemple ci-dessous.</li> <li><code>CATALINA_BASE</code> pointe sur un répertoire contenant la configuration spécifique d'une instance de Tomcat. Toutes les valeurs spécifiées ici remplacent celles par défaut (nous verrons comment plus loin).</li> </ul> <p>Exemple de configuration&nbsp;:</p> <pre> /opt/tomcat/run.sh /opt/tomcat/tomcat-6.0.18   +-- bin : startup.sh, shutdown.sh   +-- shared   +-- lib /opt/tomcat/shared (CATALINA_HOME)   +-- conf : logging.properties, server.xml, tomcat-users.xml...   +-- webapps /opt/tomcat/instance1 (CATALINA_BASE)   +-- bin : setenv.sh, setclasspath.sh   +-- conf : catalina.properties   +-- logs   +-- work /opt/tomcat/instance2 (CATALINA_BASE)   +-- bin : setenv.sh, setclasspath.sh   +-- conf : catalina.properties   +-- logs   +-- work </pre> <p>La gestion (lancement/arrêt) des instances est confiée au script <code>run.sh</code>. En fonction du paramètre "numéro d'instance" qui lui est passé, il positionne la variable d'environnement <code>CATALINA_BASE</code> puis appelle les scripts standards de Tomcat. On peut ainsi mettre à jour les binaires de Tomcat sans pour autant toucher à sa configuration, et ajouter ou supprimer des instances facilement.</p> <h4>Bien démarrer son tigre, mode d'emploi</h4> <p>Voyons maintenant le processus de lancement de Tomcat.</p> <p>Dans le répertoire <code>bin</code>, se trouvent les scripts <code>startup.sh</code> et <code>shutdown.sh</code>, qui délèguent le travail à <code>catalina.sh</code>. Après avoir détecté son environnement d'exécution (AS400, Cygwin, VMWare...), celui-ci recherche et exécute les scripts <code>setclasspath.sh</code> et <code>setenv.sh</code> dans <code>CATALINA_BASE/bin</code> s'ils existent, sinon dans <code>CATALINA_HOME/bin</code>. C'est là l'occasion de redéfinir, globalement ou par instance, des variables comme <code>JAVA_HOME</code>, <code>JAVA_OPTS</code> ou <code>CATALINA_OPTS</code>.</p> <p>Au démarrage, Tomcat lit sa configuration est lue depuis les fichiers <code>server.xml</code>, <code>logging.properties</code>, etc. Chaque instance possédant ses propres paramètres (port d'écoute, répertoire de log...), il pourrait être tentant de copier et modifier ces fichiers manuellement. <br />
Mais Tomcat propose une solution plus élégante&nbsp;: les <em>placeholders</em>, ou variables de remplacement. Il est alors possible de créer un modèle universel de configuration possédant des portions dynamiques de la forme "<code>${variable}</code>", dont les valeurs spécifiques sont redéfinies au niveau de chaque instance.<br />
Dans notre exemple d'installation, les fichiers de configuration placés dans <code>CATALINA_HOME/conf</code> sont les modèles, et les valeur spécifiques sont définies dans les fichiers <code>CATALINA_BASE/conf/catalina.properties</code> des instances.</p> <h3>Performance Tuning&nbsp;: Harder, Better, Faster, Stronger</h3> <p>En introduction de cette séance, Filip a surpris tout le monde en indiquant qu'il ne voyait pas l'intérêt de la réplication d'état entre serveurs. <br />
Son raisonnement est simple&nbsp;: si vous avez une architecture simple qui fonctionne à 99.99% du temps, il est stupide de mettre en place des systèmes complexes et coûteux pour espérer gérer les 0.01% restants. Au pire, si un serveur montre des signes de faiblesse, il est possible de le drainer avec un <em>load-balancer</em> HTTP, puis de le retirer du <em>cluster</em> sans perdre de requêtes...</p> <p>Maintenant que plusieurs instances sont lancées, voyons comment les optimiser.</p> <h4>Le processus</h4> <p>Comme toute tentative d'optimisation, le processus est simple&nbsp;:</p> <ol> <li>Définir un objectif quantifiable</li> <li>Mesurer l'existant</li> <li>Améliorer</li> <li>Mesurer l'amélioration</li> <li>Retour au point 2</li> </ol> <p>Pour l'amélioration, le <em>hardware</em> étant nettement moins cher que les compétences informatiques, il faut toujours tenter en premier d'ajouter de la puissance CPU et/ou de la RAM, et vérifier si cela suffit à atteindre les objectifs fixés. Aujourd'hui, un développeur expérimenté coûte environ 600€/jour&nbsp;; au DSI de choisir entre une semaine d'optimisation manuelle aux résultats incertains et un nouveau serveur...</p> <h4>Quelques pistes d'optimisation</h4> <p>Plus de 90% du temps de réponse à une requête étant consommés par les applications (accès à une base de données, application de règles métier, préparation des vues...), il est impératif d'optimiser celles-ci avant de commencer à modifier Tomcat. <br />
Voici tout de même les pistes d'optimisation les plus courantes.</p> <h5>Logging</h5> <p>Comme l'avait indiqué Mark Thomas à l'occasion des Rencontres Spring, les logs sont souvent mal configurés. Tout d'abord, supprimez le logger "console" (dans <code>logging.properties</code>), car il est synchrone et ne fait que dupliquer les informations déjà présentes dans les logs des applications. Ensuite, définissez une politique de rotation des fichiers, par jour ou par taille.</p> <h5>Connecteur</h5> <p>Le connecteur utilisé a également son importance. Trois connecteurs existent&nbsp;:</p> <ul> <li>BIO&nbsp;: Standard, le plus ancien. Synchrone, stable mais gère SSL via JSSE qui est lent.</li> <li>APR&nbsp;: Natif, asynchrone, gère SSL via OpenSSL qui est rapide.</li> <li>NIO&nbsp;: Utilise java.nio. Asynchrone, mais moins stable et utilise également JSSE.</li> </ul> <p>Le choix de l'un ou l'autre dépend donc&nbsp;:</p> <ol> <li>de la configuration réseau&nbsp;: les <em>load-balancers</em> opèrent-ils couche 4 (TCP) ou couche 7 (HTTP)&nbsp;?</li> <li>de la sécurisation HTTPS dans l'application.</li> <li>de la configuration du paramètre "<em>keep-alive</em>" des connexions.</li> <li>du niveau de stabilité souhaité</li> </ol> <p>Récapitulatif&nbsp;:</p> <pre> But                        Bon   Moyen Mauvais Stabilité                  BIO   APR   NIO SSL                        APR   NIO   BIO Faible charge              BIO   APR   NIO Forte charge - Keep-Alive  BIO   APR   NIO Forte charge + Keep-Alive  APR   NIO   BIO </pre> <h5>Ressources statiques</h5> <p>Il est souvent intéressant de placer des serveur Apache HTTPD devant les serveurs d'applications, car ils sont généralement plus performants pour servir les ressources statiques (images, scripts javascript...). Mais dans le cas où ces ressources sont de taille modeste (c'est-à-dire inférieure à la taille du buffer de réponse de Tomcat), Tomcat offre des performances équivalentes. <br />
Il peut également être intéressant de jouer sur la taille du cache des données statiques, et sur leur délai de revalidation.</p> <h5>Taille du buffer de réponse</h5> <p>Ce buffer (<code>socketBuffer</code>) joue un rôle particulièrement important dans les performances de Tomcat. Selon Filip, les gains de performance réalisés en déterminant sa taille optimale peuvent représenter jusqu'à 80% des gains totaux réalisés lors du procesus d'optimisation&nbsp;!</p> <h5>Autres réglages</h5> <p>Quelques autres pistes d'optimisation&nbsp;:</p> <ul> <li>Nombre de <em>threads</em> (<code>maxThreads</code>)&nbsp;: 400 est une bonne première approximation. Si le CPU encaisse la charge, augmentez la valeur.</li> <li>Nombre de connexions maintenues (<code>maxKeepAlive</code>)&nbsp;: mettre -1 (pas de <em>keep-alive</em>) en l'absence de SSL, si la charge est forte, ou si les <em>load-balancers</em> opèrent sur la couche 4 (TCP)&nbsp;; sinon, une première valeur entre 100 et 200 paraît raisonnable.</li> <li>Timeout (<code>connectionTimeout</code>): la valeur par défaut (20s) était adéquate pour les connexions RTC, mais en ces temps de haut débit, elle peut être dsecendue à 4s sans problème.</li> </ul> <h3>Troubleshooting in production</h3> <p>Pour cette troisième séance, Filip a démontré comment on pouvait diagnostiquer les problèmes en production, sans arrêter les serveurs.</p> <p>La technique consiste à générer et analyser des <em>thread dumps</em>, avec&nbsp;:</p> <ul> <li><code>kill -3 &lt;pid&gt;</code></li> <li><code>jstack -l</code></li> </ul> <p>Filip a présenté trois cas pratiques&nbsp;:</p> <ul> <li>Un <em>deadlock</em>, repéré en suivant les <em>locks</em> obtenus par les différents <em>threads</em>.</li> <li>Un cas de lenteur applicative résultant de la création de trop nombreux objets temporaires&nbsp;: la zone "<em>young</em>" de la mémoire étant pleine, le <em>garbage collector</em> passait plus de 100 fois par seconde, laissant ainsi peu de CPU pour l'application.</li> <li>Un cas de paralysie totale due à une surcharge d'objets non temporaires. Tous les threads étaient bloqués sur des opérations de création d'objet (&lt;init&gt;), et le <em>garbage collector</em> ne parvenait même plus à libérer de la mémoire, mais ne déclenchait pas d'<code>OutOfMemoryError</code> pour autant. Dans ce cas de figure, l'option "<code>-XX:+UseGCOverheadLimit</code>" permet de brider un peu le <em>garbage collector</em> et de récupérer du CPU pour l'application (et la JVM).</li> </ul> <p>La démonstration étant très visuelle et interactive, je ne peux vous en faire un compte-rendu plus détaillé... Mais c'était tout de même assez impressionnant. L'analyse des <em>thread dumps</em> est définitivement une compétence intéressante à acquérir.</p> <h3>Enterprise capabilities</h3> <p>Pour finir, <a href="http://www.springsource.com/node/897">SpringSource TC Server</a> nous a été présenté.<br />
Il s'agit tout simplement d'un Tomcat auquel ont été rajoutées des capacités de gestion et de supervision. Contrairement à <a href="http://www.springsource.com/products/suite/dmserver">SpringSource DM Server</a>, il s'agit d'une version "normale" de Tomcat (la dernière version stable), vos applications ne nécessitent donc aucune modification. De plus, sa configuration est pré-optimisée&nbsp;: logging asynchrone, <em>timeouts</em>, etc.</p> <p>TC Server collecte en permanence des statistiques comme les temps de réponse, le nombre de connexions réussies ou ratées aux bases de données, les passages du <em>garbage collector</em>... Ces informations sont inestimables en cas de problème, car elles en donnent le contexte sans avoir besoin de reproduire l'erreur.</p> <p>Enfin, une console d'administration impressionnante, véritable centre de commande, permet de superviser tout un <em>cluster</em>, d'en modifier la configuration (et revenir à la dernière version stable connue si nécessaire), de programmer des déploiements...</p> <p>Pour finir, un officiel Spring a indiqué que TC Server passerait en version beta dans les semaines à venir, et que le coût du support serait de 500 à 750 € par CPU physique, ce qui est plus que raisonnable au regard <del>du racket</del> de la politique d'IBM par exemple.</p> <h3>Conclusion et Photos</h3> <p>Ce séminaire fut très instructif. Tomcat, le "petit" serveur, possède des ressources insoupçonnées, et son grand frère TC Server pourrait bien être le best-seller de 2009, si la crise se poursuit et pousse les DSI à envisager des solutions alternatives aux grands éditeurs logiciels.<br />
<br />
Vous pouvez <a href="http://www.springsource.com/node/1175">télécharger</a> tous les slides et démonstrations. <br />
<br /></p> <p><a href="/wp-content/uploads/2015/07/img_3642.jpg"><img src="/wp-content/uploads/2015/07/.img_3642_m.jpg" alt="La salle.jpg" style="display:block; margin:0 auto;" title="La salle.jpg" /></a> <br />
<a href="/wp-content/uploads/2015/07/Panoramique.jpg"><img src="/wp-content/uploads/2015/07/.Panoramique_m.jpg" alt="Panoramique Paris" style="display:block; margin:0 auto;" title="Panoramique Paris" /></a></p>