---
ID: 115
post_title: PDF workers with RabbitMQ
author: Arnaud Cogolu√®gnes
post_date: 2012-04-05 09:20:00
post_excerpt: "<p>Initiating a CPU-intensive task from within an HTTP request is quite common. Asking for a PDF report is a typical example. But where should the processing take place? Processing the task in the same thread as the HTTP request is simple and works well, but it can overload the web server machine. Another solution consists in submitting the task to remote workers. This solution offers a good decoupling between the task producer (the web controller) and the consumers (the remote workers). Let's see how to implement such a solution with RabbitMQ ans Spring AMQP's support.</p>"
layout: post
permalink: http://blog.zenika-offres.com/?p=115
published: true
---
<p>Initiating a CPU-intensive task from within an HTTP request is quite common. Asking for a PDF report is a typical example. But where should the processing take place? Processing the task in the same thread as the HTTP request is simple and works well, but it can overload the web server machine. Another solution consists in submitting the task to remote workers. This solution offers a good decoupling between the task producer (the web controller) and the consumers (the remote workers). Let's see how to implement such a solution with RabbitMQ ans Spring AMQP's support.</p>
<!--more-->
<h3>The simple, 100%-local solution</h3> <p>Let's see first the simple solution, where the producer and the worker are co-located, as illustrated in the diagram below.</p> <p><img src="/wp-content/uploads/2015/07/pdf-workers-rabbitmq-local-solution.png" alt="Local solution for PDF generation" style="display:block; margin:0 auto;" title="Local solution for PDF generation" /></p> <p>What about the code? Imagine you're in a Java Servlet or any kind of web controller:</p> <pre class="java code java" style="font-family:inherit">PdfService pdfService = <span style="color: #7F0055; font-weight: bold;">new</span> ITextPdfService<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>; <span style="color: #7F0055; font-weight: bold;">byte</span> <span style="color: #000000;">&#91;</span><span style="color: #000000;">&#93;</span> content = pdfService.<span style="color: #000000;">createPdf</span><span style="color: #000000;">&#40;</span>pdfRequest<span style="color: #000000;">&#41;</span>; response.<span style="color: #000000;">getOutputStream</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>.<span style="color: #000000;">write</span><span style="color: #000000;">&#40;</span>content<span style="color: #000000;">&#41;</span>; response.<span style="color: #000000;">setStatus</span><span style="color: #000000;">&#40;</span>HttpServletResponse.<span style="color: #000000;">SC_OK</span><span style="color: #000000;">&#41;</span>; response.<span style="color: #000000;">setContentType</span><span style="color: #000000;">&#40;</span><span style="color: #888888;">&quot;application/pdf&quot;</span><span style="color: #000000;">&#41;</span>; response.<span style="color: #000000;">setHeader</span><span style="color: #000000;">&#40;</span><span style="color: #888888;">&quot;Content-Disposition&quot;</span>,<span style="color: #888888;">&quot;attachment; filename=spring-amqp.pdf&quot;</span><span style="color: #000000;">&#41;</span>;</pre> <p>Apart from the use of an <code>PdfService</code> interface, the web controller and the PDF service can't be more coupled. We can do better with messaging, let's see a little bit of theory first.</p> <h3>Messaging at the rescue</h3> <p>Messaging is a powerful paradigm, it is based among others on asynchronicity and document-based communication. Message producers and message consumers don't share state and don't work synchronously. Most of the time, they work in different processes, on different nodes. Messaging helps to keep components decoupled, making the whole system easier to maintain and more scalable.</p> <p>Building a message-based system can be tricky, but hopefully patterns can help. Let's see the two patterns we'll need for our PDF generation.</p> <h4>Work queues</h4> <p>With the work queue pattern, tasks are queued and worker processes pop tasks  from the queue and eventually execute the job.</p> <p><img src="/wp-content/uploads/2015/07/pdf-workers-rabbitmq-work-queues.png" alt="Work queues" style="display:block; margin:0 auto;" title="Work queues" /></p> <p>Work queues provide good decoupling between task submission and task processing. Processing can easily scale in case of spikes just by adding new workers. If the task processing is resource-intensive, the workers can be on powerful servers. Work queues are the stable parts (they never move, always there to queue tasks) and the workers are dynamic parts of the system.</p> <p>The load balancing can be natural: a worker unqueues a task when it's available.</p> <p>But what about the response? In our case, we need the generated PDF file! Work queues are often used to postpone task execution, but they also work in request/reply scenario.</p> <h4>Request/reply (aka RPC)</h4> <p>A producer can submit a task and also wait for an answer. In such a case, the task is unqueued, processed, and the worker sends back the response in a queue the producer is waiting on.</p> <p><img src="/wp-content/uploads/2015/07/pdf-workers-rabbitmq-request-reply.png" alt="Request/reply" style="display:block; margin:0 auto;" title="Request/reply" /></p> <p>The response queue can be private (as in the diagram) or shared. In the latter case, the task contains a correlation id that will identify the response (another pattern!).</p> <p>OK, enough theory, let's see the practice.</p> <h3>A decoupled solution with Spring AMQP</h3> <p><a href="http://www.springsource.org/spring-amqp">Spring AMQP</a> provides a <code>RabbitTemplate</code> that <em>directly implements the request/reply pattern</em>. Behind the scenes <a href="http://www.rabbitmq.com/">RabbitMQ</a> powers up message sending, queuing, and dispatching.</p> <p>Here is how to configure the <code>RabbitTemplate</code>:</p> <pre class="xml code xml" style="font-family:inherit"><span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;rabbit:connection-factory</span> <span style="color: #000066;">id</span>=<span style="color: #ff0000;">&quot;connectionFactory&quot;</span> <span style="color: #000066;">channel-cache-size</span>=<span style="color: #ff0000;">&quot;10&quot;</span> <span style="color: #000000; font-weight: bold;">/&gt;</span></span> &nbsp; <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;bean</span> <span style="color: #000066;">class</span>=<span style="color: #ff0000;">&quot;org.springframework.amqp.rabbit.core.RabbitTemplate&quot;</span><span style="color: #000000; font-weight: bold;">&gt;</span></span>   <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;property</span> <span style="color: #000066;">name</span>=<span style="color: #ff0000;">&quot;connectionFactory&quot;</span> <span style="color: #000066;">ref</span>=<span style="color: #ff0000;">&quot;connectionFactory&quot;</span> <span style="color: #000000; font-weight: bold;">/&gt;</span></span> <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;/bean<span style="color: #000000; font-weight: bold;">&gt;</span></span></span></pre> <p>Note you can do this configuration in Java if you don't like XML. Using the <code>RabbitTemplate</code> is as simple as this:</p> <pre class="java code java" style="font-family:inherit">RabbitTemplate tpl = <span style="color: #000000;">&#40;</span>...<span style="color: #000000;">&#41;</span>  <span style="color: #808080; font-style: italic;">// looked up from the Spring application context</span> <span style="color: #7F0055; font-weight: bold;">byte</span> <span style="color: #000000;">&#91;</span><span style="color: #000000;">&#93;</span> content = <span style="color: #000000;">&#40;</span><span style="color: #7F0055; font-weight: bold;">byte</span><span style="color: #000000;">&#91;</span><span style="color: #000000;">&#93;</span><span style="color: #000000;">&#41;</span> tpl.<span style="color: #000000;">convertSendAndReceive</span><span style="color: #000000;">&#40;</span><span style="color: #888888;">&quot;pdfRequests&quot;</span>, request<span style="color: #000000;">&#41;</span>;</pre> <p>Where <code>pdfRequests</code> is the routing key, which means the request will be sent to a <code>pdfRequests</code> queue.</p> <p>But what about the worker? You can configure a worker to listens on the <code>pdfRequests</code> this way:</p> <pre class="xml code xml" style="font-family:inherit"><span style="color: #808080; font-style: italic;">&lt;!-- the original PDF service --&gt;</span> <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;bean</span> <span style="color: #000066;">id</span>=<span style="color: #ff0000;">&quot;pdfService&quot;</span> <span style="color: #000066;">class</span>=<span style="color: #ff0000;">&quot;com.zenika.rabbitmq.ITextPdfService&quot;</span> <span style="color: #000000; font-weight: bold;">/&gt;</span></span> &nbsp; <span style="color: #808080; font-style: italic;">&lt;!-- making the PDF service message --&gt;</span> <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;rabbit:listener-container</span> <span style="color: #000066;">connection-factory</span>=<span st
yle="color: #ff0000;">&quot;connectionFactory&quot;</span><span style="color: #000000; font-weight: bold;">&gt;</span></span>   <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;rabbit:listener</span> <span style="color: #000066;">ref</span>=<span style="color: #ff0000;">&quot;pdfService&quot;</span> <span style="color: #000066;">method</span>=<span style="color: #ff0000;">&quot;createPdf&quot;</span> <span style="color: #000066;">queues</span>=<span style="color: #ff0000;">&quot;pdfRequests&quot;</span> <span style="color: #000000; font-weight: bold;">/&gt;</span></span> <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;/rabbit:listener-container<span style="color: #000000; font-weight: bold;">&gt;</span></span></span></pre> <p>You just have to bootstrap a Spring application context on different servers and you have your army of workers. Note you can make your workers multi-threaded.</p> <p>Our solution works and is decoupled now, but it's a little bit intrusive because we directly use the <code>RabbitTemplate</code> in our code. Spring Integration can help us to make the processing less intrusive and even more decoupled.</p> <h3>A more decoupled solution with Spring Integration</h3> <p><a href="http://www.springsource.org/spring-integration">Spring Integration</a>'s AMQP support builds on top Spring AMQP. Spring Integration implements tons of messaging patterns (aka "<a href="http://www.eaipatterns.com/">Enterprise Integration Patterns</a>"). One of them is the outbound gateway that fits perfectly our needs. The outbound gateway implements the request/reply pattern (it takes care of the submission, the response queue, and so on) and can behave as a <code>PdfService</code>, our application interface.</p> <p>This means our application code is agnostic to the task submission and to the processing: local, in another thread, remote with JMS or AMQP... this is all about configuration, the application code won't change.</p> <p>Here is what we about to do:</p> <p><img src="/wp-content/uploads/2015/07/pdf-workers-rabbitmq-spring-integration.png" alt="PDF generation with RabbitMQ and Spring Integration" style="display:block; margin:0 auto;" title="PDF generation with RabbitMQ and Spring Integration" /></p> <p>And now the code. The worker part doesn't change: workers still listen on the <code>pdfRequests</code> queue. We configure now 2 gateways for the producer side:</p> <pre class="xml code xml" style="font-family:inherit"><span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;int:gateway</span> <span style="color: #000066;">id</span>=<span style="color: #ff0000;">&quot;pdfService&quot;</span> <span style="color: #000066;">default-request-channel</span>=<span style="color: #ff0000;">&quot;pdfRequestsChannel&quot;</span> <span style="color: #000066;">service-interface</span>=<span style="color: #ff0000;">&quot;com.zenika.rabbitmq.PdfService&quot;</span> <span style="color: #000000; font-weight: bold;">/&gt;</span></span> &nbsp; <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;int:channel</span> <span style="color: #000066;">id</span>=<span style="color: #ff0000;">&quot;pdfRequestsChannel&quot;</span> <span style="color: #000000; font-weight: bold;">/&gt;</span></span> &nbsp; <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;int-amqp:outbound-gateway</span> <span style="color: #000066;">request-channel</span>=<span style="color: #ff0000;">&quot;pdfRequestsChannel&quot;</span> <span style="color: #000066;">amqp-template</span>=<span style="color: #ff0000;">&quot;amqpTemplate&quot;</span> <span style="color: #000066;">routing-key</span>=<span style="color: #ff0000;">&quot;pdfRequests&quot;</span> <span style="color: #000000; font-weight: bold;">/&gt;</span></span></pre> <p>The first gateway is the one that ends up used in the application, it feels and smells like a <code>PdfService</code>, but it's an entry point into the messaging world. It sends every request through the <code>pdfRequestsChannel</code> to the second gateway. This second gateway handles the request/reply pattern.</p> <p>Our application code goes back to normal: it knows only about the <code>PdfService</code>:</p> <pre class="java code java" style="font-family:inherit">PdfService pdfService = <span style="color: #000000;">&#40;</span>...<span style="color: #000000;">&#41;</span> <span style="color: #808080; font-style: italic;">// looked up from Spring application context</span> <span style="color: #7F0055; font-weight: bold;">byte</span> <span style="color: #000000;">&#91;</span><span style="color: #000000;">&#93;</span> content = pdfService.<span style="color: #000000;">createPdf</span><span style="color: #000000;">&#40;</span>pdfRequest<span style="color: #000000;">&#41;</span>;</pre> <h3>Conclusion</h3> <p>Messaging is your friend when it comes to decouple and scale your systems. Message-based systems are built up from the combination of patterns, but implementing these patterns is usually cumbersome and error-prone. Frameworks like <a href="http://www.springsource.org/spring-integration">Spring Integration</a> help to leverage these patterns and let you focus on what matters: the application code.</p> <p>Source code <a href="https://github.com/acogoluegnes/PDF-workers-with-RabbitMQ">available on Github</a>.</p>