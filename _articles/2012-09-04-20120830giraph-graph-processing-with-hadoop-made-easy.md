---
ID: 198
post_title: 'Hadoop, part 3 : graph processing with Giraph'
author: edaboussi
post_date: 2012-09-04 09:30:00
post_excerpt: '<p>For the last part of this Hadoop series, I will introduce you the way to process graphs with Hadoop, through Apache Giraph.</p>'
layout: post
permalink: http://blog.zenika-offres.com/?p=198
published: true
---
<p>For the last part of this Hadoop series, I will introduce you the way to process graphs with Hadoop, through Apache Giraph.</p>
<!--more-->
<p>We will first introduce Giraph, then we will take a look at how the graphs are processed, then we will implement a classical example : the Travelling Salesman Problem, in its brute force version.</p> <h3>1. Giraph</h3> <div>With the emergence of Facebook, LinkedIn, and the new social networks, the Big Data problems have lead us to Big Graph problems, as we try to process complex graphs, for example to obtain the shortest path between two nodes, or the friends of a friend, etc...</div><div>Hadoop and its eco-system is made to process large distributed sets of data, and Giraph follows this logic, and is a way to&nbsp;parallelize the treatment of a graph.</div><h3>2. How it works</h3> <div>Let's start by describing the way the graphs are represented through Giraph's eyes.</div><div>The graphs are defined by all their vertexes, and four types are needed to define the graph :</div><p>-I is the id type</p> <p>-V is the value type</p> <p>-E is the type of the edge values</p> <p>-M is the type of the messages</p> <div>But what are those messages? The messages are at the root of Giraph's way to process the Graph. Each vertex, when processed, can send a message to its connected vertexes.</div><div>The id is the unique identifier of the vertex, while the value is the value of the node, and the edge value is the "cost" of the edge between two vertexes.</div><div>You can create your own graphs, and ids can be lists, messages can be images, etc...Here is a basic vision of the vertexes from Giraph :</div><div><img src="/wp-content/uploads/2015/07/Vertex.jpg" alt="" style="margin: 0 auto; display: block; " title="vertex" /></div><div>Apart from these basic characteristics, Giraph adds another dimension to the graph processing : the vertexes can be active or inactive. They all begin the process as active, then they become inactive if they "vote to halt"</div><div>When they are inactive, they are not processed, and they can come back to activity only if they receive one (or more) message, and then they can be processed normally. The global treatment stops when all the vertexes are inactive. This scheme describes the transition from active to inactive, and the contrary.</div><div><img src="/wp-content/uploads/2015/07/etats2.jpg" alt="" style="margin: 0 auto; display: block; " title="etats2" /></div><div>Giraph will the process the graph using "supersteps" : a superstep is a step during which the vertexes send messages to each other. Only the active vertexes are processed, and they call the method <code>compute()</code> at each verticle, while they call the method <code>voteToHalt()</code> in order to be inactive. The process ends when all the vertexes vote to halt.</div><h3>3. The Travelling Salesman Problem Example</h3> <div>To illustrate the way Giraph works, we implemented quickly the <a href="http://en.wikipedia.org/wiki/Travelling_salesman_problem">Travelling Salesman Problem</a>&nbsp;(TSP), in its "brute-force" version. As a reminder, in the TSP, we try to find the shortest path between different cities that eaches each city once and comes back to the source city. The Graph modelisation in Giraph lets us complexify the original TSP :</div><div>-the edges are oriented, thus we the distance from city A to city B can be different to the distance from city B to city A</div><div>-the values of the vertexes are taken into account : it means that passing by a city also adds a distance</div><div>Now, we can then focus on how implement it on Giraph : we are then in possession of a graph representing cities, linked with asymetrical edges. At each superstep, Giraph will compute the active nodes : this node will send a new message to the remaining "cities", in order to try all the possible paths, and during the last superstep, the source node will collect all the distances, and take the shortest.</div><div>Here is a little animation showing how it works :</div><div><iframe src="http://fr.slideshare.net/slideshow/embed_code/14127612" width="427" height="356" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC;border-width:1px 1px 0;margin-bottom:5px" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="http://fr.slideshare.net/EliasDaboussi/giraph-travelling-salesman-example-14127612" title="Giraph Travelling Salesman Example" target="_blank">Giraph Travelling Salesman Example</a> </strong> from <strong><a href="http://fr.slideshare.net/EliasDaboussi" target="_blank">EliasDaboussi</a></strong> </div></div><div>The source code is available on gitHub <a href="https://github.com/edaboussi/Giraph">here</a>, and all the necessary instructions.</div>