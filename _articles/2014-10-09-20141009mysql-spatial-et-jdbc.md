---
ID: 146
post_title: MySQL Spatial et JDBC
author: Gérald Quintana
post_date: 2014-10-09 14:00:00
post_excerpt: |
  <p>MySQL possède quelques fonctionnalités géographiques: un type de données "Geometry", quelques fonctions sur ce type et un type d'index spatial (R-Tree). La version 5.6 apporte un lot de <a href="http://dev.mysql.com/doc/refman/5.6/en/spatial-relation-functions-object-shapes.html">fonctions supplémentaires</a> dont l'objectif est le support de la norme OpenGIS For SQL.</p> <p>Comment manipuler ce type de données SQL en Java? Contrairement à PostgreSQL ou Oracle, pour lesquelles les drivers JDBC contiennent des objets <code>PGgeometry</code> ou <code>JGeometry</code>, MySQL ne propose rien.</p>
layout: post
permalink: http://blog.zenika-offres.com/?p=146
published: true
---
<p>MySQL possède quelques fonctionnalités géographiques: un type de données "Geometry", quelques fonctions sur ce type et un type d'index spatial (R-Tree). La version 5.6 apporte un lot de <a href="http://dev.mysql.com/doc/refman/5.6/en/spatial-relation-functions-object-shapes.html">fonctions supplémentaires</a> dont l'objectif est le support de la norme OpenGIS For SQL.</p> <p>Comment manipuler ce type de données SQL en Java? Contrairement à PostgreSQL ou Oracle, pour lesquelles les drivers JDBC contiennent des objets <code>PGgeometry</code> ou <code>JGeometry</code>, MySQL ne propose rien.</p>
<!--more-->
<p>Pour palier à ce manque, on peut s'appuyer sur <a href="http://www.vividsolutions.com/jts/">JTS (Java Topology Suite)</a>. JTS contient les classes nécessaires pour décrire des points, lignes brisées et surfaces.</p> <p>Nous verrons dans cet article comment lire/écrire des géométries depuis du code Java.</p> <h4>Préparation du modèle</h4> <p>Pour commencer, on crée une table avec une colonne de type <code>GEOMETRY</code>:</p> <pre>     create table VILLE (         ID_VILLE int not null primary key,         GEOM geometry not null     ) ENGINE=MyISAM; </pre> <p>Seul le storage engine MyISAM supporte les index spatiaux; InnoDB supporte seulement les colonnes géométriques. On est donc contraint de faire un choix: InnoDB ou index spatiaux.</p> <pre>     create spatial index IDX_VILLE_GEOM     on VILLE(GEOM); </pre> <p>Une fois la table et l'index spatial créés voyons comment écrire dedans.</p> <h4>Conversion WKB/WKT</h4> <p>La norme OpenGIS SQL définit 2 formats pour décrire et échanger des géométries: un format textuel, le WKT (Well Known Text), et un format binaire, le WKB (Well Known Binary).</p> <p>La première possibilité est d'utiliser le format WKT comme format pivot entre le monde Java et MySQL. Pour une écriture:</p> <pre>   insert into VILLE(ID_VILLE, GEOM) values (?, GeomFromText(?));   Geometry geometry = new Point(...);   String wkt = new WKTWriter().write(geometry);   preparedStatement.setString(2, wkt); </pre> <p>On procède de même pour une lecture:</p> <pre>   select AsWKT(GEOM) from VILLE where ID_VILLE=?   String wkt = resultSet.getString(1);   Geometry geometry = new WKTReader().read(wkt); </pre> <p>On peut appliquer cette même stratégie avec WKB:</p> <ul> <li>En SQL: <code>GeomFromText</code> et <code>AsWKT</code> deviennent <code>GeomFromBinary</code> et <code>AsWKB</code></li> <li>En Java: <code>WKTReader</code> et <code>WKTWriter</code> deviennent <code>WKBReader</code> et <code>WKBWriter</code></li> </ul> <h4>Format interne</h4> <p>Une autre stratégie est de passer directement par le format interne MySQL. On manipule alors les colonnes de type GEOMETRY comme des BLOBs. La structure binaire de ce type de colonne est:</p> <ul> <li>4 octets (soit un entier 32 bits): le SRID (référentiel spatial dans lequel sont exprimées les coordonnées)</li> <li>Tout le reste du flux: la géometrie au format binaire WKB</li> </ul> <p>Du coup pour les écritures:</p> <pre>   insert into VILLE(ID_VILLE, GEOM) values (?, ?);   int byteOrder = ByteOrderValues.LITTLE_ENDIAN;   // SRID   ByteArrayOutputStream outputStream = new ByteArrayOutputStream();   byte[] sridBytes = new byte[4];   ByteOrderValues.putInt(userObject.getSRID(), sridBytes, byteOrder);   outputStream.write(sridBytes);   // Geometry   WKBWriter wkbWriter = new WKBWriter(2, byteOrder);   wkbWriter.write(geometry, new OutputStreamOutStream(outputStream));   byte[] bytes = outputStream.toByteArray();   preparedStatement.setBytes(2, bytes); </pre> <p>Et pour les lectures:</p> <pre>   select GEOM from VILLE where ID_VILLE=?   int byteOrder = ByteOrderValues.LITTLE_ENDIAN;   byte[] bytes = resultSet.getBytes(1);   ByteArrayInputStream inputStream = new ByteArrayInputStream(bytes);   // SRID   byte[] sridBytes = new byte[4];   inputStream.read(sridBytes);   int srid = ByteOrderValues.getInt(sridBytes, byteOrder);   // Geometry   GeometryFactory geometryFactory = new GeometryFactory(precisionModel, srid, coordinateSequenceFactory);   WKBReader wkbReader = new WKBReader(geometryFactory);   Geometry geometry = wkbReader.read(new InputStreamInStream(inputStream)); </pre> <p>Le code Java de cette variante est plus compliqué, mais on s'évite les conversions dans le code SQL. Correctement enveloppé dans notre framework JDBC favori (<code>TypeHandler</code> dans MyBatis, <code>Converter</code> dans jOOQ, <code>DataType</code> dans DBUnit), cette stratégie simplifie le SQL.</p> <p>Les heureux utilisateurs d'Hibernate n'auront rien à faire, puisque Hibernate Spatial fait déjà tout le boulot (en utilisant le format interne).</p>