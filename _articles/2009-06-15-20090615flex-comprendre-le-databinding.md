---
ID: 75
post_title: 'Flex : comprendre le databinding'
author: glebonniec
post_date: 2009-06-15 11:23:00
post_excerpt: '<p>Quand on découvre Flex et le databinding, on est dans un premier temps bluffé par la "magie" du mécanisme, puis très vite, on se retrouve confronté à des comportements totalement imprévisibles. Très souvent, les développeurs préfèrent alors se passer de cet outil.</p>'
layout: post
permalink: http://blog.zenika-offres.com/?p=75
published: true
---
<p>Quand on découvre Flex et le databinding, on est dans un premier temps bluffé par la "magie" du mécanisme, puis très vite, on se retrouve confronté à des comportements totalement imprévisibles. Très souvent, les développeurs préfèrent alors se passer de cet outil.</p>
<!--more-->
<p>Il y a quelques jours de ça, nous avons eu une discussion, avec mon collègue Benjamin Houdu, sur un cas de databinding extrêmement simple syntaxiquement mais dont le comportement était de prime abord étonnant&nbsp;:</p> <pre> &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;mx:Application xmlns:mx=&quot;http://www.adobe.com/2006/mxml&quot; layout=&quot;vertical&quot; creationComplete=&quot;init()&quot;&gt; 	&lt;mx:Script&gt; 		&lt;![CDATA[ 			[Bindable] public var varText:String; 			[Bindable] public var varXML:XML; 			public function init():void {   				varText = &quot;&lt;user&gt;&lt;name&gt;Zenika&lt;/name&gt;&lt;/user&gt;&quot;;   				varXML = &lt;user&gt;&lt;name&gt;Zenika&lt;/name&gt;&lt;/user&gt;; 			} 		]]&gt; 	&lt;/mx:Script&gt; 	&lt;mx:HBox&gt; 		&lt;mx:TextArea id=&quot;textareaText&quot; text=&quot;{varText}&quot; width=&quot;200&quot; height=&quot;200&quot;/&gt; 		&lt;mx:TextArea id=&quot;textareaXML&quot; text=&quot;{varXML}&quot; width=&quot;200&quot; height=&quot;200&quot;/&gt; 	&lt;/mx:HBox&gt; 	&lt;mx:Button label=&quot;INIT&quot; click=&quot;init()&quot;/&gt; &lt;/mx:Application&gt; </pre> <p>Ce code lie respectivement deux variables (une variable de type String et une de type XML) à des composants <em>TextArea</em>&nbsp;; dès que l'une des deux variables est modifiée, son composant associé est automatiquement mis à jour&nbsp;: c'est le principe même du databinding.</p> <p>Si nous exécutons l'application ci-dessus, nous constatons que le comportement du databinding est différent en fonction du type de la variable. En effet, si nous venons à modifier chaque composant manuellement, et que nous réinitialisons les variables "bindées" à l'aide du bouton <em>INIT</em>, nous pouvons observer que seul le composant lié à la variable XML est remis à jour&nbsp;: le databinding de la variable de type String n'est pas pris en compte. Pour comprendre cela, il suffit d'aller au-delà de l'apparente magie du databinding.</p> <p><img src="/wp-content/uploads/2015/07/schema.png" alt="Databinding" style="display:block; margin:0 auto;" title="Databinding" /></p> <p>En effet, il n'y a rien de magique dans le databinding...pour s'en convaincre le compilateur Flex nous fournit un paramètre fort utile&nbsp;: le paramètre <strong>keep-generated-actionscript</strong>. Ce paramètre permet de récupérer l'ensemble du code généré par le compilateur. On peut alors se rendre compte que pour une annotation <em>Bindable</em>, plus d'une centaine de lignes de code est générée par Flex&nbsp;! Et c'est dans ces lignes de code que se trouve la solution à notre mystère et tout particulièrement dans la classe <em>BindableProperty</em> (fichier <strong>_Application-binding-generated.as</strong> ) qui est chargée par Flex de mettre à jour les composants liés. Si on regarde en détail le contenu de cette classe, on peut voir que la fonction d'affectation se présente ainsi&nbsp;:</p> <pre> public function set varText(value:String):void { 	var oldValue:Object = this._236164340varText; 	if (oldValue !== value) 	{     		this._236164340varText = value;     		this.dispatchEvent(mx.events.PropertyChangeEvent.createUpdateEvent(this, &quot;varText&quot;, oldValue, value)); 	} } </pre> <p>Une comparaison est effectuée avant d'affecter la valeur&nbsp;: si le nouveau contenu de la variable est différent du contenu précédent, le databinding est exécuté, sinon tout s'arrête là. Il faut noter que le databinding est unilatéral en Flex (ie. la modification par l'utilisateur des <em>TextAreas</em> n'entraîne pas la mise à jour des variables "bindées"). Aussi, quand nous appelons la fonction <em>init()</em>, nous ne faisons qu'écraser nos variables avec la même valeur que précédemment.</p> <p>Or l'opérateur utilisé, la différence stricte (ie. <em>!==</em>) induit un comportement différent pour le Databinding de type String et celui de type XML. En effet, la différence stricte compare les variables String par valeur et les variables XML par référence (ie. emplacement mémoire). Ainsi, dans le cas qui nous intéresse, seule la variable XML apparait comme différente&nbsp;; cela a pour conséquence que seul le composant XML est mis à jour. Afin de rétablir le comportement attendu pour le composant String, il suffit, par exemple, de vider la variable (ie. <em>varText = null;</em>) avant de la réinitialiser ou encore de mettre en place un databinding bijectif afin de répercuter les modifications manuelles au sein de la variable <em>varText</em>.</p> <p>Il est donc fondamental de connaître le comportement du Databinding afin d'éviter des effets de bord imprévus et ainsi utiliser toute la puissance du langage Flex.</p>