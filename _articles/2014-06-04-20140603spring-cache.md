---
ID: 482
post_title: Spring Cache
author: Anis Ben Hamda
post_date: 2014-06-04 14:30:00
post_excerpt: "<h3>Introduction</h3> <p>La mise en cache a toujours été un besoin important pour à la fois améliorer les performances d’une application et alléger sa charge de travail. De plus, son utilité est particulièrement évidente aujourd'hui avec les applications Web qui peuvent être amenées à gérer des milliers de visiteurs concurrents.D'un point de vue architectural, la gestion du cache est  orthogonale à la logique métier de l'application et pour cette raison, elle devrait avoir un impact minimal sur le développement de l'application elle-même.</p>"
layout: post
permalink: http://blog.zenika-offres.com/?p=482
published: true
---
<h3>Introduction</h3> <p>La mise en cache a toujours été un besoin important pour à la fois améliorer les performances d’une application et alléger sa charge de travail. De plus, son utilité est particulièrement évidente aujourd'hui avec les applications Web qui peuvent être amenées à gérer des milliers de visiteurs concurrents.D'un point de vue architectural, la gestion du cache est  orthogonale à la logique métier de l'application et pour cette raison, elle devrait avoir un impact minimal sur le développement de l'application elle-même.</p>
<!--more-->
<p>Depuis la version 3.1, Spring fournit une api pour la gestion de cache, semblable à la gestion déclarative des transactions. L'abstraction de la mise en cache permet une utilisation cohérente des différentes solutions de mise en cache avec un impact minimal sur le code.</p> <p>Le cache Spring est appliqué à des méthodes Java. Au premier appel d'une méthode avec une combinaison de paramètres, Spring stocke sa valeur de retour dans le cache. Ainsi, l'appel suivant se verra directement servir la valeur venant du cache sans avoir besoin d'appeler le traitement derrière qui peut être couteux. Le tout est appliqué de façon transparente sans impacter l'appelant.</p> <p>Dans cet article nous allons voir deux implémentations différentes du stockage de cache avec Spring.</p> <ul> <li>Implémentation á base des ConcurrentHashMap de Java</li> <li>Implémentation ehcache</li> </ul> <h3>Utilisation</h3> <p>La mise en cache d’une méthode avec Spring est une opération simple et transparente, on doit annoter notre méthode via l’annotation @Cacheable.</p> <pre class="java code java" style="font-family:inherit">@Cacheable<span style="color: #009900;">&#40;</span>value<span style="color: #339933;">=</span> <span style="color: #0000ff;">&quot;dataCache&quot;</span><span style="color: #009900;">&#41;</span> <span style="color: #000000; font-weight: bold;">public</span> Reponse getDatas<span style="color: #009900;">&#40;</span><span style="color: #003399;">Long</span> param1,<span style="color: #003399;">String</span> param2<span style="color: #009900;">&#41;</span><span style="color: #009900;">&#123;</span> <span style="color: #009900;">&#125;</span></pre> <p>dataCache est le nom du gestionnaire de cache associé.</p> <p>Au premier appel a la méthode, Spring cache la reponse, identifiée par une clé unique calculer sur la base de hashcode des paramètres d’appels &lt; param1, param2&gt;, et pour le énième appel avec les mêmes paramètres, Spring retourne la réponse déjà cacher sans avoir ré-exécuter la méthode.</p> <p>Aussi, il est possible d’associé plus qu’un seul cache à notre méthode</p> <pre class="java code java" style="font-family:inherit">@Cacheable<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#123;</span><span style="color: #0000ff;">&quot;dataCache&quot;</span>,”<span style="color: #000000; font-weight: bold;">default</span>”<span style="color: #009900;">&#125;</span><span style="color: #009900;">&#41;</span>   <span style="color: #000000; font-weight: bold;">public</span> Reponse getDatas<span style="color: #009900;">&#40;</span><span style="color: #003399;">Long</span> param1,<span style="color: #003399;">String</span> param2<span style="color: #009900;">&#41;</span><span style="color: #009900;">&#123;</span>   <span style="color: #009900;">&#125;</span></pre> <p>Dans ce cas, chacun des caches sera vérifié avant d'exécuter la méthode, si au moins un cache est trouvé, alors la valeur associée sera retourné.</p> <h3>Génération des clés de cache</h3> <p>L'algorithme de base d'une gestion de cache est relativement trivial. Le cache est une zone mémoire dans laquelle on stocke des objets dont chacun est identifié par une clé unique calculée, on utilise en général les Maps  pour stocker un cache. L'algorithme de récupération d'un objet est donc le suivant&nbsp;:</p> <ul> <li>On calcule sa clé (généralement hashCode ou combinaison de hashCode)</li> <li>On recherche l'objet dans le cache (recherche par clé)</li> <li>Si l'objet est trouvé</li> </ul> <p>on le renvoie</p> <ul> <li>Sinon</li> </ul> <p>on recalcule l'objet réel<br />
on met l'objet dans le cache associé à sa clé<br />
on renvoie l'objet</p> <p>De même Spring utilise un KeyGenerator basé sur le hachage simple, qui calcule la clé sur la base des tables de hachage des objets passés en paramètre de la méthode.</p> <h3>Cache personnalisé</h3> <h4>La clé de cache (key)</h4> <p>Il est tout à fait probable que les méthodes cibles ont différentes signatures qui ne peuvent pas être simplement mappées, cela tend à devenir évident lorsque la méthode cible a plusieurs arguments dont seulement certains sont adaptés pour la mise en cache (alors que le reste n’est utilisé que par la logique de la méthode)</p> <pre class="java code java" style="font-family:inherit">@Cacheable<span style="color: #009900;">&#40;</span>value<span style="color: #339933;">=</span> <span style="color: #0000ff;">&quot;dataCache&quot;</span><span style="color: #009900;">&#41;</span>   <span style="color: #000000; font-weight: bold;">public</span> Reponse getDatas<span style="color: #009900;">&#40;</span><span style="color: #003399;">Long</span> param1,<span style="color: #003399;">String</span> param2,<span style="color: #000066; font-weight: bold;">boolean</span> param3<span style="color: #009900;">&#41;</span><span style="color: #009900;">&#123;</span>   <span style="color: #009900;">&#125;</span></pre> <p>Pour de tels cas, l'annotation @ Cacheable permet au développeur de spécifier la manière dont la clé de cache est générée. Le développeur peut utiliser SpEL pour choisir les arguments d'intérêt (ou leurs propriétés imbriquées).</p> <pre class="java code java" style="font-family:inherit">@Cacheable<span style="color: #009900;">&#40;</span>value<span style="color: #339933;">=</span> <span style="color: #0000ff;">&quot;dataCache&quot;</span>,key<span style="color: #339933;">=</span><span style="color: #0000ff;">&quot;#param2&quot;</span><span style="color: #009900;">&#41;</span>   <span style="color: #000000; font-weight: bold;">public</span> Reponse getDatas<span style="color: #009900;">&#40;</span><span style="color: #003399;">Long</span> param1,<span style="color: #003399;">String</span> param2,<span style="color: #000066; font-weight: bold;">boolean</span> param3<span style="color: #009900;">&#41;</span><span style="color: #009900;">&#123;</span> &nbsp;   <span style="color: #009900;">&#125;</span></pre> <p>Dans ce cas, la clé de cache sera calculée seulement avec le deuxième paramètre &lt;param2&gt;.</p> <p>Spring permet aussi de spécifier des propriétés imbriquées&nbsp;:</p> <pre class="java code java" style="font-family:inherit">@Cacheable<span style="color: #009900;">&#40;</span>value<span style="color: #339933;">=</span> <span style="color: #0000ff;">&quot;dataCache&quot;</span>,key<span style="color: #339933;">=</span><span style="color: #0000ff;">&quot;#param2.name&quot;</span><span style="color: #009900;">&#41;</span>   <span style="color: #000000; font-weight: bold;">public</span> Reponse getDatas<span style="color: #009900;">&#40;</span><span style="color: #003399;">Long</span> param1,Data param2,<span style="color: #000066; font-weight: bold;">boolean</span> param3<span style="color: #009900;">&#41;</span><span style="color: #009900;">&#123;</span>   <span style="color: #009900;">&#125;</span></pre> <p>Dans ce cas, la clé de cache sera calculée avec l’attribut name du paramètre &lt;param2&gt;</p> <p>Les exemples ci-dessus montrent comment il est simple de sélectionner certain arguments ou une de ses propriétés.</p> <h4>Condition de la mise en cache</h4> <p>Parfois, une méthode pourrait ne pas être appropriée pour mettre en cache tout le temps mais sous certaines conditions. Les annotations de cache supportent cette fonctionnalité. Le paramètre condition  prend une expression SpEL qui est évaluée à true ou false. Donc si la condition est vraie, la méthode sera mise en cache.</p> <pre class="java code java" style="font-family:inherit">@Cacheable<span style="color: #009900;">&#40;</span>value<span style="color: #339933;">=</span> <span style="color: #0000ff;">&quot;dataCache&quot;</span>,key<span style="color: #339933;">=</span><span style="color: #0000ff;">&quot;#param2&quot;</span>,condition<span style="color: #339933;">=</span><span style="color: #0000ff;">&quot;#param2.length&lt;64&quot;</span><span style="color: #009900;">&#41;</span>   <span style="color: #000000; font-weight: bold;">public</span> Reponse getDatas<span style="color: #009900;">&#40;</span><span style="color: #003399;">Long</span> param1,<span style="color: #003399;">String</span> param2,<span style="color: #000066; font-weight: bold;">boolean</span> param3<span style="color: #009900;">&#41;</span><span style="color: #009900;">&#123;</span>   <span style="color: #009900;">&#125;</span></pre> <p>Dans ce cas, la méthode est mise en cache si et seulement si la taille du deuxième paramètre est inferieure a  64.</p> <h3>L’annotation @CacheEvict</h3> <p>Le cache Spring permet non seulement la population d'un magasin de cache mais aussi son expulsion. Ce processus est utile pour supprimer les données obsolètes ou inutilisées de la mémoire cache. Opposée à @ Cacheable, l’annotation @ CacheEvict délimite des méthodes qui effectuent l’expulsion de cache, ce sont des méthodes qui agissent comme des déclencheurs de suppression des données à partir du cache. @ CacheEvict nécessite un (ou plusieurs) caches qui sont touchés par l'action.</p> <pre class="java code java" style="font-family:inherit">@CacheEvict<span style="color: #009900;">&#40;</span>value<span style="color: #339933;">=</span> <span style="color: #0000ff;">&quot;dataCache&quot;</span><span style="color: #009900;">&#41;</span>   <span style="color: #000000; font-weight: bold;">public</span> <span style="color: #000066; font-weight: bold;">void</span> reloadData<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #009900;">&#123;</span>   <span style="color: #009900;">&#125;</span></pre> <p>Cette option est très pratique lorsqu’une région de cache entier doit être vidée. Il est important de noter que les méthodes void peuvent être utilisées avec @ CacheEvict, ces méthodes agissent comme des déclencheurs de suppression de cache, les valeurs de retour sont ignorées (comme elles n'interagissent pas avec le cache) .ce n'est pas le cas avec @ Cacheable qui ajoute / mettre à jour les données dans le cache et nécessite donc un retour.</p> <h3>L’annotation @CachePut</h3> <p>Forcer la mise à jour d’une entrée de cache. Par opposition à l’annotation @Cacheable, cette annotation provoque toujours l’exécution de la méthode et le stockage de son résultat dans la mémoire cache.</p> <pre class="java code java" style="font-family:inherit">@CachePut<span style="color: #009900;">&#40;</span>value<span style="color: #339933;">=</span> <span style="color: #0000ff;">&quot;dataCache&quot;</span>,key<span style="color: #339933;">=</span><span style="color: #0000ff;">&quot;#param2.name&quot;</span><span style="color: #009900;">&#41;</span>   <span style="color: #000000; font-weight: bold;">public</span> Reponse getDatas<span style="color: #009900;">&#40;</span><span style="color: #003399;">Long</span> param1,Data param2,<span style="color: #000066; font-weight: bold;">boolean</span> param3<span style="color: #009900;">&#41;</span><span style="color: #009900;">&#123;</span>   <span style="color: #009900;">&#125;</span></pre> <p>Donc le @CachePut, est nécessaire pour forcer la création ou la mise à jour d’une entrée dans le cache, sans attendre son expiration.</p> <p>Le seul cas où la méthode n'est pas exécutée, c'est quand vous fournissez l’option condition de @CachePut, et votre condition est évaluée a false.</p> <h3>Activation de cache</h3> <p>Il est important de noter que les annotations de cache ne déclenchent automatiquement pas leurs exécutions.</p> <p>Pour activer le support de cache dans un projet Spring, on commence par activer le traitement des annotations @Cacheable via la balise annotation-driven du namespace cache&nbsp;:</p> <pre class="xml code xml" style="font-family:inherit"><span style="colo
r: #009900;"><span style="color: #000000; font-weight: bold;">&lt;beans</span> <span style="color: #000066;">xmlns</span>=<span style="color: #ff0000;">&quot;http://www.springframework.org/schema/beans&quot;</span></span> <span style="color: #009900;">       <span style="color: #000066;">xmlns:cache</span>=<span style="color: #ff0000;">&quot;http://www.springframework.org/schema/cache&quot;</span></span> <span style="color: #009900;">       <span style="color: #000066;">xmlns:xsi</span>=<span style="color: #ff0000;">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span> <span style="color: #009900;">       <span style="color: #000066;">xmlns:context</span>=<span style="color: #ff0000;">&quot;http://www.springframework.org/schema/context&quot;</span></span> <span style="color: #009900;">       <span style="color: #000066;">xsi:schemaLocation</span>=<span style="color: #ff0000;">&quot;http://www.springframework.org/schema/beans</span> <span style="color: #009900;">           http://www.springframework.org/schema/beans/spring-beans-3.2.xsd</span> <span style="color: #009900;">           http://www.springframework.org/schema/cache</span> <span style="color: #009900;">           http://www.springframework.org/schema/cache/spring-cache.xsd</span> <span style="color: #009900;">           http://www.springframework.org/schema/context&quot;</span><span style="color: #000000; font-weight: bold;">&gt;</span></span> &nbsp;   <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;cache:annotation-driven</span> <span style="color: #000000; font-weight: bold;">/&gt;</span></span></pre> <p>Notez qu'il suffit de supprimer cette balise pour désactiver le cache.</p> <p>On peut aussi activer le support de cache par annotation en ajoutant @enableCaching dans l’un de nos classes de configuration (@Configuration classes)&nbsp;:</p> <pre class="java code java" style="font-family:inherit">@Configuration   @EnableCaching   <span style="color: #000000; font-weight: bold;">public</span> <span style="color: #000000; font-weight: bold;">class</span> AppConfig <span style="color: #009900;">&#123;</span>   <span style="color: #009900;">&#125;</span></pre> <h3>Contraintes techniques</h3> <ul> <li>Les objets passés en paramètre de la méthode doivent avoir leurs propres comportements haschode() afin que Spring puisse calculer les clés.</li> </ul> <ul> <li>Les objets passés en paramètre et l’objet de retour (ainsi leurs propriétés imbriquées) doivent être serialisable.</li> </ul> <h3>Choix de l’implémentation</h3> <p>Spring offre deux implémentations différentes du stockage de cache&nbsp;:</p> <ul> <li>Implémentation á base des ConcurrentHashMap de Java</li> <li>Implémentation ehcache</li> </ul> <p>Pour les utiliser, il faut simplement déclarer un CacheManager approprié et une entité qui contrôle et gère les caches.</p> <h4>Implémentation cache de base ConcurrentHashMap de Java</h4> <p>Il faut déclarer les gestionnaires de caches SimpleCacheManager dans le contexte de l’application.</p> <pre class="xml code xml" style="font-family:inherit"><span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;bean</span> <span style="color: #000066;">id</span>=<span style="color: #ff0000;">&quot;cacheManager&quot;</span>  <span style="color: #000066;">class</span>=<span style="color: #ff0000;">&quot;org.springframework.cache.support.SimpleCacheManager&quot;</span><span style="color: #000000; font-weight: bold;">&gt;</span></span>   <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;property</span> <span style="color: #000066;">name</span>=<span style="color: #ff0000;">&quot;caches&quot;</span><span style="color: #000000; font-weight: bold;">&gt;</span></span>   <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;set<span style="color: #000000; font-weight: bold;">&gt;</span></span></span>   <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;bean</span> <span style="color: #000066;">class</span>=<span style="color: #ff0000;">&quot;org.springframework.cache.concurrent.ConcurrentMapCacheFactoryBean&quot;</span> <span style="color: #000066;">name</span>=<span style="color: #ff0000;">&quot;default&quot;</span><span style="color: #000000; font-weight: bold;">/&gt;</span></span>   <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;bean</span> <span style="color: #000066;">class</span>=<span style="color: #ff0000;">&quot;org.springframework.cache.concurrent.ConcurrentMapCacheFactoryBean&quot;</span> <span style="color: #000066;">name</span>=<span style="color: #ff0000;">&quot;dataCache&quot;</span><span style="color: #000000; font-weight: bold;">/&gt;</span></span>   <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;/set<span style="color: #000000; font-weight: bold;">&gt;</span></span></span>   <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;/property<span style="color: #000000; font-weight: bold;">&gt;</span></span></span>   <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;/bean<span style="color: #000000; font-weight: bold;">&gt;</span></span></span></pre> <p>Chaque gestionnaire nécessite un nom (name) unique afin de l'identifier par annotation.</p> <p>On peut déclarer plusieurs caches gérés par un seul manager SimpleCacheManager</p> <p>Cette implémentation est basique, elle  n’as pas besoin d’une bibliothèque supplémentaire, mais elle n’est pas trop prévue pour des grosses charges qui nécessitent de paramétrages supplémentaires.</p> <h4>Implémentation ehcache</h4> <p>Cette implémentation  utilise ehcache, elle est beaucoup plus puissante et flexible.et elle permet un paramétrage avancé du cache de l’application.</p> <p>L’implémentation ehcache est localisée sous le package  org.springframework.cache.ehcache. Pour l’utiliser on doit déclarer le CacheManager approprié.</p> <pre class="xml code xml" style="font-family:inherit"><span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;bean</span> <span style="color: #000066;">id</span>=<span style="color: #ff0000;">&quot;cacheManager&quot;</span>      <span style="color: #000066;">class</span>=<span style="color: #ff0000;">&quot;org.springframework.cache.ehcache.EhCacheCacheManager&quot;</span><span style="color: #000000; font-weight: bold;">&gt;</span></span>   <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;property</span> <span style="color: #000066;">name</span>=<span style="color: #ff0000;">&quot;cacheManager&quot;</span> <span style="color: #000066;">ref</span>=<span style="color: #ff0000;">&quot;ehcache&quot;</span><span style="color: #000000; font-weight: bold;">/&gt;</span></span>   <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;/bean<span style="color: #000000; font-weight: bold;">&gt;</span></span></span>   <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;bean</span> <span style="color: #000066;">id</span>=<span style="color: #ff0000;">&quot;ehcache&quot;</span>    <span style="color: #000066;">class</span>=<span style="color: #ff0000;">&quot;org.springframework.cache.ehcache.EhCacheManagerFactoryBean&quot;</span><span style="color: #000000; font-weight: bold;">&gt;</span></span>   <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;property</span> <span style="color: #000066;">name</span>=<span style="color: #ff0000;">&quot;configLocation&quot;</span> <span style="color: #000066;">value</span>=<span style="color: #ff0000;">&quot;classpath:ehcache.xml&quot;</span><span style="color: #000000; font-weight: bold;">/&gt;</span></span>   <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;property</span> <span style="color: #000066;">name</span>=<span style="color: #ff0000;">&quot;shared&quot;</span> <span style="color: #000066;">value</span>=<span style="color: #ff0000;">&quot;true&quot;</span><
span style="color: #000000; font-weight: bold;">/&gt;</span></span>   <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;/bean<span style="color: #000000; font-weight: bold;">&gt;</span></span></span></pre> <p>Le fichier ehcache.xml est le fichier de paramétrage des caches de l’application&nbsp;:</p> <pre class="xml code xml" style="font-family:inherit"><span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;ehcache</span>  </span> <span style="color: #009900;">    <span style="color: #000066;">xsi:noNamespaceSchemaLocation</span>=<span style="color: #ff0000;">&quot;ehcache.xsd&quot;</span> </span> <span style="color: #009900;">    <span style="color: #000066;">updateCheck</span>=<span style="color: #ff0000;">&quot;true&quot;</span> </span> <span style="color: #009900;">    <span style="color: #000066;">monitoring</span>=<span style="color: #ff0000;">&quot;autodetect&quot;</span> </span> <span style="color: #009900;">    <span style="color: #000066;">dynamicConfig</span>=<span style="color: #ff0000;">&quot;true&quot;</span></span> <span style="color: #009900;">    <span style="color: #000066;">maxBytesLocalHeap</span>=<span style="color: #ff0000;">&quot;150M&quot;</span>    </span> <span style="color: #009900;">    <span style="color: #000000; font-weight: bold;">&gt;</span></span>   <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;diskStore</span> <span style="color: #000066;">path</span>=<span style="color: #ff0000;">&quot;java.io.tmpdir&quot;</span><span style="color: #000000; font-weight: bold;">/&gt;</span></span>   <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;defaultCache</span> </span> <span style="color: #009900;">    <span style="color: #000066;">eternal</span>=<span style="color: #ff0000;">&quot;false&quot;</span> </span> <span style="color: #009900;">    <span style="color: #000066;">maxElementsInMemory</span>=<span style="color: #ff0000;">&quot;100&quot;</span> </span> <span style="color: #009900;">    <span style="color: #000066;">overflowToDisk</span>=<span style="color: #ff0000;">&quot;false&quot;</span>    <span style="color: #000000; font-weight: bold;">/&gt;</span></span>   <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;cache</span> <span style="color: #000066;">name</span>=<span style="color: #ff0000;">&quot;dataCache&quot;</span> </span> <span style="color: #009900;">    <span style="color: #000066;">eternal</span>=<span style="color: #ff0000;">&quot;false&quot;</span></span> <span style="color: #009900;">    <span style="color: #000066;">timeToIdleSeconds</span>=<span style="color: #ff0000;">&quot;300&quot;</span></span> <span style="color: #009900;">    <span style="color: #000066;">maxBytesLocalHeap</span>=<span style="color: #ff0000;">&quot;30M&quot;</span></span> <span style="color: #009900;">    <span style="color: #000066;">timeToLiveSeconds</span>=<span style="color: #ff0000;">&quot;300&quot;</span></span> <span style="color: #009900;">    <span style="color: #000066;">overflowToDisk</span>=<span style="color: #ff0000;">&quot;true&quot;</span></span> <span style="color: #009900;">    <span style="color: #000066;">diskPersistent</span>=<span style="color: #ff0000;">&quot;false&quot;</span></span> <span style="color: #009900;">    <span style="color: #000066;">diskExpiryThreadIntervalSeconds</span>=<span style="color: #ff0000;">&quot;120&quot;</span></span> <span style="color: #009900;">    <span style="color: #000066;">memoryStoreEvictionPolicy</span>=<span style="color: #ff0000;">&quot;LRU&quot;</span><span style="color: #000000; font-weight: bold;">/&gt;</span></span>   <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;/ehcache<span style="color: #000000; font-weight: bold;">&gt;</span></span></span></pre> <p>En utilisant l’ehcache, on peut définir plusieurs caches avec différents paramètres d’une manière très simple</p> <ul> <li><strong> name</strong>:un identifiant de la cache</li> <li><strong>maxBytesLocalHeap</strong>&nbsp;: définit le nombre d'octets que le cache peut utiliser de la VM. Si un CacheManager maxBytesLocalHeap a été défini, la  taille déterminée de ce cache sera soustraite du CacheManager. D'autres caches partage le reste. Les valeurs de cet attribut sont données à titre &lt;nombre&gt; k | K | M | M | g | G pour kilo-octets (k | K), mégaoctets (m | M), ou gigaoctets (g | G).</li> <li><strong>eternal</strong>: définit si les éléments sont éternels. Si c’est le cas, le timeout sera  ignoré et l'élément n'est jamais expiré.</li> <li><strong>timeToIdleSeconds</strong>: C'est le nombre de secondes que l'élément doit vivre depuis sa dernière utilisation.La valeur par défaut est 0, l'élément reste toujours en repos</li> <li><strong>timeToLiveSeconds</strong>: C'est le nombre de secondes que l'élément doit vivre depuis sa création en cache.La valeur par défaut est 0, l’élément vivra éternellement.</li> <li><strong>memoryStoreEvictionPolicy</strong>: Politique d'éviction :<br />LRU - le moins récemment utilisé <br />LFU - moins fréquemment utilisé <br />FIFO - premier entré, premier sorti, l'élément le plus ancien par date de création</li> <li><strong>diskExpiryThreadIntervalSeconds</strong>: Nombre de secondes entre deux exécutions du processus de contrôle d'éviction.</li> <li><strong>diskPersistent</strong>: Permet la mémorisation des objets sur le disque pour une récupération des objets entre deux démarrages de la VM.</li> <li><strong>overflowToDisk</strong>: Détermine si les objets peuvent être stockés sur le disque en cas d'atteinte du maximum d'éléments en mémoire</li> </ul> <p>Pour résumer avec une simple formule mathématique&nbsp;:</p> <pre> expirationTime = Math.min((creationTime + timeToLive),(mostRecentTime + timeToIdle)) </pre> <h3>Conclusion</h3> <p>La gestion de cache est une problématique critique pour les applications Web, ainsi que la définition d'un système de cache applicatif est généralement considérée comme relativement complexe à mettre en œuvre par les développeurs, pour cela Spring a proposé un système générique de définition de cache complètement transparent, et simple.</p> <p>Une démo est disponible sous&nbsp;: https://github.com/Zenika/Blogs/tree/master/20140527demoSpringCache</p>