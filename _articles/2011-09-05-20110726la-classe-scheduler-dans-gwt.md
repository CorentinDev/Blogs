---
ID: 435
post_title: La classe Scheduler dans GWT
author: glebonniec
post_date: 2011-09-05 15:24:00
post_excerpt: |
  <p>GWT possède, depuis la version 2.0, une classe <a href="http://google-web-toolkit.googlecode.com/svn/javadoc/2.3/com/google/gwt/core/client/Scheduler.html">Scheduler</a> qui fournit un ensemble de méthodes de planification de tâches et de gestion de l'event loop du navigateur. Nous allons voir dans cet article les possibilités offertes par cette classe.</p>
layout: post
permalink: http://blog.zenika-offres.com/?p=435
published: true
slide_template:
  - ""
---
<p>GWT possède, depuis la version 2.0, une classe <a href="http://google-web-toolkit.googlecode.com/svn/javadoc/2.3/com/google/gwt/core/client/Scheduler.html">Scheduler</a> qui fournit un ensemble de méthodes de planification de tâches et de gestion de l'event loop du navigateur. Nous allons voir dans cet article les possibilités offertes par cette classe.</p>
<!--more-->
<h2>Planification de tâches</h2> <h3>ScheduleFixedDelay &amp; ScheduleFixedPeriod</h3> <p>Ces 2 méthodes permettent d'exécuter une tâche répétitive à intervalles fixes. ScheduleFixedDelay permet d'assurer un temps fixe entre la fin d'une tâche et le début d'une autre (exemple&nbsp;: si une tâche prend 30 ms pour s'exécuter et si un délai de 100 ms est fixé, la tâche suivante s'executera 130 ms après l’exécution de la première). ScheduleFixedPeriod permet, elle, d'assurer un temps fixe entre l'ensemble des invocations (exemple&nbsp;: si une tâche prend 30 ms pour s'exécuter et si un délai de 100 ms est fixé, la tâche suivante s’exécutera 100 ms après l’exécution de la première).</p> <p>Remarque&nbsp;: ces 2 méthodes prennent (en plus du délai/période fixé) un objet Scheduler.RepeatingCommand en paramètre qui est exécuté tant qu'il renvoie la valeur true en sortie.</p> <h3>ScheduleEntry &amp; ScheduleFinally</h3> <p>Afin d'appréhender ces 2 méthodes, il est nécessaire de comprendre les mécanismes de base de GWT de traitement des évènements natifs et applicatifs. Il faut tout d'abord savoir que l'ensemble des évènements du navigateur sont interceptés par GWT (mouse, keyboard, load, xhr, timer ...) même si le développeur n'estime pas en avoir besoin (ie. pas d'EventHandler associé).</p> <p>Dès qu'un événement est intercepté, ce dernier est redispatché vers l'application&nbsp;; Le renvoi de l’évènement est "encadré" par une méthode $entry (méthode proxy). L'objectif principal de cette fonction est de "décorer" tout appel à du code GWT (handler, RPC, timer et load pour faire simple) afin d'assurer la gestion des tâches de type "entry" et "finally".</p> <p>Premièrement, la méthode $entry dépile l'ensemble des commandes entry en cours et les exécute. Une fois cette étape terminée, $entry lance le code GWT cible. Finalement, $entry exécute l'ensemble des commandes finally en attente.</p> <p>Pour résumer, une méthode créant des commandes "entry" et "finally" aura pour comme conséquences l'exécution&nbsp;: - des commandes finally une fois le code GWT en cours exécuté - des commandes entry lors du prochain évènement natif ou applicatif</p> <p>Exemple&nbsp;: dans l'application suivante, nous détectons les mouvements effectuées sur le label principal. Dès que la souris entre sur le composant, le label est modifié et une commande entry est enregistrée. On constate qu'au premier mouvement, la zone est modifiée mais que le popup d'alerte, lui n’apparaît pas&nbsp;: Pour ce faire, il suffit de déclencher un évènement quelconque (autre mouvement de souris ou appui sur une touche du clavier par exemple).</p> <pre class="java code java" style="font-family:inherit"><span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">void</span> onModuleLoad<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> 	<span style="color: #7F0055; font-weight: bold;">final</span> <span style="color: #000000;">Label</span> label = <span style="color: #7F0055; font-weight: bold;">new</span> <span style="color: #000000;">Label</span><span style="color: #000000;">&#40;</span><span style="color: #888888;">&quot;MOVE AREA&quot;</span><span style="color: #000000;">&#41;</span>; 	label.<span style="color: #000000;">setStyleName</span><span style="color: #000000;">&#40;</span><span style="color: #888888;">&quot;label&quot;</span><span style="color: #000000;">&#41;</span>; 	RootPanel.<span style="color: #000000;">get</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>.<span style="color: #000000;">add</span><span style="color: #000000;">&#40;</span>label<span style="color: #000000;">&#41;</span>; &nbsp; 	label.<span style="color: #000000;">addMouseMoveHandler</span><span style="color: #000000;">&#40;</span><span style="color: #7F0055; font-weight: bold;">new</span> MouseMoveHandler<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> &nbsp; 		<span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">void</span> onMouseMove<span style="color: #000000;">&#40;</span>MouseMoveEvent event<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> 			label.<span style="color: #000000;">setText</span><span style="color: #000000;">&#40;</span><span style="color: #888888;">&quot;MOVE DETECTED&quot;</span><span style="color: #000000;">&#41;</span>; 			label.<span style="color: #000000;">setStyleName</span><span style="color: #000000;">&#40;</span><span style="color: #888888;">&quot;move&quot;</span><span style="color: #000000;">&#41;</span>; &nbsp; 			Scheduler.<span style="color: #000000;">get</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>.<span style="color: #000000;">scheduleEntry</span><span style="color: #000000;">&#40;</span><span style="color: #7F0055; font-weight: bold;">new</span> ScheduledCommand<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> 				<span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">void</span> execute<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> 					<span style="color: #000000;">Window</span>.<span style="color: #000000;">alert</span><span style="color: #000000;">&#40;</span><span style="color: #888888;">&quot;ENTRY EXECUTED&quot;</span><span style="color: #000000;">&#41;</span>; 				<span style="color: #000000;">&#125;</span> 			<span style="color: #000000;">&#125;</span><span style="color: #000000;">&#41;</span>; 		<span style="color: #000000;">&#125;</span> 	<span style="color: #000000;">&#125;</span><span style="color: #000000;">&#41;</span>; <span style="color: #000000;">&#125;</span></pre> <p><img src="/wp-content/uploads/2015/07/.scheduler_m.jpg" alt="scheduleEntry" style="display:block; margin:0 auto;" title="scheduleEntry" /></p> <p>On comprend mieux maintenant pourquoi la javadoc indique que les commandes entry permettent d'effectuer une action <a href="http://google-web-toolkit.googlecode.com/svn/javadoc/2.3/com/google/gwt/core/client/Scheduler.html#scheduleEntry(com.google.gwt.core.client.Scheduler.RepeatingCommand)">"dès qu'il se passe quelquechose"</a> (sic).</p> <h2>Gestion de l'Event Loop</h2> <p>Tout navigateur fonctionne sur le principe d'une event loop. Un moteur javascript est mono-threadé et ne peut donc traiter qu'un événement à la fois et donc de facto une seule action à la fois (d'où l'importance de l'asynchronisme dans Javascript)&nbsp;: les événements sont positionnés dans une file d'attente (ie. FIFO) avant d'être traités un à un.</p> <p>Nativement, Javascript ne fournit aucune méthode permettant de prendre la main sur l'event loop du navigateur. C'est afin de pallier cette limitation que GWT fournit deux méthodes&nbsp;: scheduleDeferred et scheduleIncremental.</p> <h3>ScheduleIncremental</h3> <p>Nous avons tous déjà connu cette situation qui consiste à attendre pendant plusieurs secondes l'affichage d'une liste de données volumineuse. En effet, le fonctionnement mono-threadé du Javascript fait qu'il ne peut pas gérer simultanément la construction de l'arbre et son affichage (layout &amp; paint event).</p> <p>ScheduleIncremental permet de répondre au besoin d'affichage "en temps réel". Le principe est relativement simple&nbsp;: ScheduleIncremental laisse "souffler" à intervalle régulier le moteur javascript pour lui permettre de gérer l'affichage de l'arbre en construction. En effet, une commande incrémentale doit, une fois le travail effectué, indiquer si elle doit être relancée ou pas. Si c'est le cas, un timer (ie. setTimeout) est lancé 1ms plus tard.</p> <p>1 ms est la période minimale autorisée par les moteurs Javascript, c'est large
ment assez pour laisser le temps au navigateur de mettre à jour l'affichage&nbsp;: durant l'exécution de la commande, toute modification de l'arbre engendre une demande de mise à jour de l'affichage (layout event) qui est alors mis en fil d'attente au niveau de l'event loop. L'événement timeout arrive donc après la mise à jour de l'affichage permettant ainsi d'alterner construction de l'arbre et mise à jour de l'affichage (comme dans l'exemple suivant).</p> <pre class="java code java" style="font-family:inherit"><span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">void</span> onModuleLoad<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> 	Scheduler.<span style="color: #000000;">get</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>.<span style="color: #000000;">scheduleIncremental</span><span style="color: #000000;">&#40;</span><span style="color: #7F0055; font-weight: bold;">new</span> RepeatingCommand<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> 		<span style="color: #7F0055; font-weight: bold;">private</span> <span style="color: #7F0055; font-weight: bold;">int</span> count = 0; &nbsp; 		<span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">boolean</span> execute<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> 			RootPanel.<span style="color: #000000;">get</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>.<span style="color: #000000;">add</span><span style="color: #000000;">&#40;</span><span style="color: #7F0055; font-weight: bold;">new</span> <span style="color: #000000;">Label</span><span style="color: #000000;">&#40;</span><span style="color: #888888;">&quot;****&quot;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>; 			count++; 			<span style="color: #7F0055; font-weight: bold;">return</span> count <span style="color: #000000;">&lt;</span> <span style="color: #cc66cc;">1000</span>; 		<span style="color: #000000;">&#125;</span> 	<span style="color: #000000;">&#125;</span><span style="color: #000000;">&#41;</span>; <span style="color: #000000;">&#125;</span></pre> <p>Dans l'outil de Google Speed Tracer, on peut voir l'alternance timer/affichage.</p> <p><img src="/wp-content/uploads/2015/07/.ScreenShot200_m.jpg" alt="ScreenShot200.png" style="display:block; margin:0 auto;" /></p> <p>Remarque&nbsp;: Pour chaque appel, deux timers sont en fait lancés (Flusher et Rescuer&nbsp;: le premier exécute la tâche, le deuxième relance éventuellement le flusher en cas d'échec de celui-ci).</p> <h3>ScheduleDeferred</h3> <p>L'objectif est d'assurer l'exécution d'une tâche une fois l'ensemble des évènements en attente traités alors que scheduleFinally exécute cette tâche avant. Par exemple, si vous voulez effectuer une tâche avant la mise à jour de l'affichage, vous utiliserez scheduleFinally et scheduleDeferred si vous voulez l'exécuter après la mise à jour de l'affichage (exemple&nbsp;: focus sur un champ donné).</p> <p>Pour ce faire, l'implémentation est assez proche de scheduleIncremental&nbsp;: un timer de 1ms est lancé permettant ainsi de mettre la tâche en file d'attente au sein de l'Event Loop et donc de lancer la commande une fois les évènements en attente traités.</p> <h2>Conclusion</h2> <p>La classe Scheduler est aujourd'hui une boîte à outils indispensable au sein de la plateforme GWT. ScheduleDeferred permet notamment de gérer des problématiques d'affichage assez fines (positionnement du curseur, calage des ascenseurs ...). Il est donc important de la garder sous le coude afin de répondre à l'ensemble des nouveaux besoins des utilisateurs web.</p>