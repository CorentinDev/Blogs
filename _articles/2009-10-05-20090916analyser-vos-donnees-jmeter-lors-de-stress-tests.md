---
ID: 477
post_title: >
  Analyser vos résultats JMeter lors de
  stress tests
author: arazafimahefa
post_date: 2009-10-05 14:08:00
post_excerpt: |
  <p>L'analyse des résultats constitue l'étape la plus importante lors de tests de charge. En effet, c'est à ce moment précis que les données récoltées doivent trouver tout leur sens et nous permettre d'effectuer des choix éclairés afin d'améliorer les performances des applications.</p> <p>Dans ce billet, vous apprendrez à mettre en place une chaine d'analyse complète des résultats de tests de charge en utilisant exclusivement des outils Open-Source&nbsp;: <a href="http://jakarta.apache.org/jmeter/">JMeter</a>, <a href="http://fr.talend.com/">Talend</a>, <a href="http://www.mysql.fr/">MySql</a> et <a href="http://www.eclipse.org/birt">BIRT</a>.</p> <p>Vous remarquerez la "très forte similarité" avec une chaine Décisionnelle. En effet, pourquoi de telles capacités seraient exclusivement réservées aux choix métiers et non aux choix techniques&nbsp;?</p>
layout: post
permalink: http://blog.zenika-offres.com/?p=477
published: true
---
<p>L'analyse des résultats constitue l'étape la plus importante lors de tests de charge. En effet, c'est à ce moment précis que les données récoltées doivent trouver tout leur sens et nous permettre d'effectuer des choix éclairés afin d'améliorer les performances des applications.</p> <p>Dans ce billet, vous apprendrez à mettre en place une chaine d'analyse complète des résultats de tests de charge en utilisant exclusivement des outils Open-Source&nbsp;: <a href="http://jakarta.apache.org/jmeter/">JMeter</a>, <a href="http://fr.talend.com/">Talend</a>, <a href="http://www.mysql.fr/">MySql</a> et <a href="http://www.eclipse.org/birt">BIRT</a>.</p> <p>Vous remarquerez la "très forte similarité" avec une chaine Décisionnelle. En effet, pourquoi de telles capacités seraient exclusivement réservées aux choix métiers et non aux choix techniques&nbsp;?</p>
<!--more-->
<h3>Les fichiers de logs JMeter</h3> <p>Lors des tests de charge sur des applications, <a href="http://jakarta.apache.org/jmeter/">JMeter</a> génère un fichier de log xml (extension .jtl) qui journalise l'ensemble des résultats des requêtes effectuées sur l'application. Par exemple, pour une application web, nous collecterons des données concernant le temps de réponse, le code de réponse, le timestamp de l'envoi de la requête etc. L'analyse des résultats consiste à traiter et consolider ces données et à générer des rapports et graphiques pertinents en utilisant généralement un outils de génération de rapports. Dans notre cas, nous utiliserons <a href="http://www.eclipse.org/birt">BIRT</a>.<br /></p> <p>Dans bien des cas cependant, ce fichier "brute" est très volumineux et ne peut être traité directement par l'outil de reporting. Par exemple, un fichier XML contenant plusieurs centaines de milliers d'éléments ne peut pas toujours être lu par une JVM avec une approche DOM. D'autre part, il est souvent intéressant d'agréger des échantillons récents et plus anciens pour comparer l'impact des différents choix sur les performances.</p> <h3>Solution&nbsp;: utilisation d'un ETL et d'une base de données</h3> <p>Pour remédier à ce problème, nous pouvons opter pour une solution qui fait intervenir un <a href="http://fr.wikipedia.org/wiki/Extract_Transform_Load">ETL</a> et une base de données en amont de BIRT en nous rapprochant ainsi d'une véritable plateforme de <a href="http://fr.wikipedia.org/wiki/Informatique_d%C3%A9cisionnelle">Business Intelligence</a>. Un ETL ou "Extract-Transform-Load" est un dispositif logiciel qui permet d'importer/exporter des données vers/depuis une "base" (au sens large) en opérant d'éventuels traitements intermédiaires sur ces données. Dans notre cas, nous utiliserons <a href="http://fr.talend.com/">Talend</a> pour effectuer l'extraction des données depuis le fichier jtl vers une base de données <a href="http://www.mysql.fr/">MySql</a> qui nous servira ensuite de <a href="http://fr.wikipedia.org/wiki/Datawarehouse">DataWarehouse</a>/<a href="http://fr.wikipedia.org/wiki/Datamart">Datamart</a>.<br /></p> <p>L'avantage de l'utilisation d'une base de données est également de pouvoir effectuer une première agrégation des données au niveau de la base (ex: "group by" en SQL) et donc de décharger l'outil de reporting de ce premier niveau de traitement. BIRT se chargera ensuite des traitements restants et de la génération des rapports.</p> <h3>1ere étape&nbsp;: Extraction des données avec Talend</h3> <p>Pour faciliter le travail de Talend, il est intéressant de splitter le fichier xml principal en plusieurs parties et d'extraire les données à partir de ces fichiers. <br />
<br />
Pour extraire les données avec Talend, nous créons d'abord un job qui définit l'enchaînement des traitements pour l'extraction des données depuis le fichier xml vers la base de données. Pour le moment, rien n'est renseigné au niveau du job, il faut au préalable créer les éléments qui le constituent. <br /></p> <p><img src="/wp-content/uploads/2015/07/.creation_job_m.jpg" alt="Création du job" title="Création du job" /></p> <p>Nous créons alors les éléments nécessaires à l'extraction&nbsp;: une metadata xml (input) qui représentera la source de données <br />
<br /></p> <p><img src="/wp-content/uploads/2015/07/.meta_xml_m.jpg" alt="Xml metadata" title="Xml metadata" /> <br /></p> <p><img src="/wp-content/uploads/2015/07/.meta_xml_name_m.jpg" alt="Xml metadata name" title="Xml metadata name" /> <br />
<br /></p> <p>A partir du fichier xml fourni, Talend pourra en extraire le schéma. Ce dernier étant identique pour tous les fichiers splittés, il suffira de modifier à chaque "run" le nom du fichier xml en entrée (metadata xml) pour injecter les différentes données dans notre DataWarehouse (MySql). <br />
<img src="/wp-content/uploads/2015/07/.extracted_xml_schema_m.jpg" alt="Extracted xml schema" title="Extracted xml schema" /> <br /></p> <p><img src="/wp-content/uploads/2015/07/.configuring_xml_meta_schema_m.jpg" alt="Xml schema configuration" title="Xml schema configuration" /> <br /></p> <p><img src="/wp-content/uploads/2015/07/.configuring_primarykey_data_m.jpg" alt="Primary key configuration" title="Primary key configuration" /> <br />
<br /></p> <p>Déclarons ensuite une metadata database (output) qui sera la destination des données. <br /></p> <p><img src="/wp-content/uploads/2015/07/.new_meta_dbase_m.jpg" alt="New database metadata" title="New database metadata" /> <br /></p> <p><img src="/wp-content/uploads/2015/07/.nom_meta_db_m.jpg" alt="Database metadata name" title="Database metadata name" /> <br /></p> <p><img src="/wp-content/uploads/2015/07/.db_connexion_info_m.jpg" alt="Db connection parameters" title="Db connection parameters" /> <br /></p> <p>Enfin, après avoir créé les éléments du job, nous créons les enchaînements pour effectuer le traitement sur les données et nous lançons le job :<br />
<img src="/wp-content/uploads/2015/07/.inject_m.jpg" alt="Injection des données" title="Injection des données" /> <br /></p> <h3>2ème étape&nbsp;: Génération des rapports avec BIRT</h3> <p>Pour générer les rapports dans BIRT, il suffit maintenant de déclarer la base de données alimentée ci-dessus en tant que source de données&nbsp;: <br />
<img src="/wp-content/uploads/2015/07/.new_datasource_m.jpg" alt="New datasource" title="New datasource" /> <br /></p> <p>renseigner BIRT sur le pilote JDBC à utiliser pour communiquer avec la base de données <img src="/wp-content/uploads/2015/07/.manage_datasource_jdbc_m.jpg" alt="Manage datasource" title="Manage datasource" /> <br /></p> <p>Puis créer les datasets, qui seront traités et affichés sur les graphiques. Dans notre cas, nous allons par exemple voir la variation du temps de réponse des requêtes&nbsp;:</p> <p><img src="/wp-content/uploads/2015/07/.dataset_sql_m.jpg" alt="Dataset SQL filter" title="Dataset SQL filter" /> <br /></p> <p>Ici, nous remarquons la capacité à <strong>filtrer les données</strong> à traiter dans BIRT en utilisant <strong>une requête SQL</strong> qui sera traitée par le SGBD. BIRT est donc déchargé du traitement des filtres et donc des traitements éventuellement coûteux en ressource.<br /></p> <p>Enfin, vient la phase de création du graphe&nbsp;:</p> <p><img src="/wp-content/uploads/2015/07/.type_graphe_m.jpg" alt="Type de graphe" title="Type de graphe" /> <br /></p> <p>Nous choisissons les données à afficher à partir du DataSet configuré, dans notre cas en abscisse les id des requêtes et en ordonnée les temps de réponse&nbsp;:</p> <p><img src="/wp-content/uploads/2015/07/.config_chart_m.jpg" alt="Chart configuration" title="Chart configuration" /> <br /></p> <p>Enfin, nous pouvons génèrer le graphe final&nbsp;:</p> <p><img src="/wp-content/uploads/2015/07/.generate_graph_m.jpg" alt="Générer" title="Générer" /> <br /></p> <p>Permettant d'obtenir le rendu final en pdf suivant&nbsp;:</p> <p><a href="/wp-content/uploads/2015/07/generated_graph.pdf">Fichier pdf généré</a></p> <p>Dans ce billet, vous avez appris à mettre en place une chaine d'analyse de résultats de tests de charge avec <a href="http://jakarta.apache.org/jmeter/">JMeter</a>, <a href="http://fr.talend.com/">Talend</a>, <a href="http://www.mysql.fr/">MySql</a> et <a href="http://www.eclipse.org/birt">BIRT</a>.</p> <p>Fichier du billet&nbsp;: <a href="/wp-content/uploads/2015/07/BirtETL.zip">Fichiers du demo</a></p>