---
ID: 413
post_title: >
  Introducing the ElasticSearch View
  Plugin
author: tleroux
post_date: 2012-12-21 09:00:00
post_excerpt: '<p>The ElasticSearch View Plugin provides a simple way to render ElasticSearch documents in HTML, XML or text. This plugin can also be used to generate web pages that show a list of documents based on predefined search queries.</p>'
layout: post
permalink: http://blog.zenika-offres.com/?p=413
published: true
slide_template:
  - ""
---
<p>The ElasticSearch View Plugin provides a simple way to render ElasticSearch documents in HTML, XML or text. This plugin can also be used to generate web pages that show a list of documents based on predefined search queries.</p>
<!--more-->
<p>Elasticsearch provides a fast and simple way to retrieve a document with the <a href="http://www.elasticsearch.org/guide/reference/api/get.html">GET API</a>:</p> <pre> curl -XGET 'http://localhost:9200/catalog/product/1' </pre> <p>Until now, this API only allows to get the document in JSON format:</p> <pre> {     &quot;_index&quot;: &quot;catalog&quot;,     &quot;_type&quot;: &quot;product&quot;,     &quot;_id&quot;: &quot;1&quot;,     &quot;_version&quot;: 1,     &quot;exists&quot;: true,     &quot;_source&quot;: {         &quot;name&quot;: &quot;1969 Harley Davidson Ultimate Chopper&quot;,         &quot;type&quot;: &quot;Motorcycles&quot;,         &quot;brand&quot;: &quot;Harley Davidson&quot;,         ...     } } </pre> <p>Although this format is really useful, it is not directly presentable to a final user. The JSON format is more dedicated to be used by third party applications located at client or server side. These applications are in charge of parsing the JSON content, extracting meaningful data and rendering them in a more graphical way, for instance within a HTML page. With ElasticSearch, anyone who wants to have a graphical rendering of these documents shall install, configure and maintain such an application, which can become quite complex and may require regular redelivery every time the graphic content of a document is modified.</p> <p>The ElasticSearch View Plugin can be used when you don't want to develop a dedicated application or when you wish to control not only the document searches but also the way the document are displayed.</p> <p>The project is located on GitHub: <a href="https://github.com/tlrx/elasticsearch-view-plugin">https://github.com/tlrx/elasticsearch-view-plugin</a>.</p> <p>This plugin allows to create views using different templating engines (for now <a href="http://mvel.codehaus.org/MVEL+2.0+Basic+Templating">MVEL</a> and <a href="http://mustache.github.com/">Mustache</a> can be used) in order to generate a HTML (or XML, or anything which is text) display of your document and access to it threw an URL.</p> <p>For example, the plugin can be used to generate a HTML page that displays our product and to access it with <code>http://localhost:9200/_view/catalog/product/1</code>:<br />
<br />
<br />
<img src="/wp-content/uploads/2015/07/.render_html_s.jpg" alt="HTML view of document #1" style="display:block; margin:0 auto;" title="HTML view of document #1" /> <br />
<br /></p> <p>The plugin can also be used to create several formats of views for a same type of document, if necessary with the help of predefined scripts. It can also be used to generate a specific view to show the results of predefined search queries:<br />
<br />
<br />
<img src="/wp-content/uploads/2015/07/.render_html_list_brand_s.jpg" alt="List of Products and Brands" style="display:block; margin:0 auto;" title="List of Products and Brands" /> <br />
In this article, we explain how to install and configure the ElasticSearch View Plugin in order to generate HTML and XML views of documents indexed in ElasticSearch. <br />
<br /></p> <h4>Installing the plugin</h4> <p>The plugin can be installed as any other ElasticSearch's plugins:</p> <pre> bin/plugin -install tlrx/elasticsearch-view-plugin/0.0.1 </pre> <p>The current version of the plugin is compatible with <a href="http://www.elasticsearch.org/download/2012/12/07/0.20.1.html">ElasticSearch 0.20.1</a>. <br />
<br /></p> <h4>Creating views for existing documents</h4> <p>Let's imagine that we have a <code>catalog</code> index and few documents of <code>product</code> type:</p> <pre> curl -XPUT 'http://localhost:9200/catalog/product/1' -d ' {    &quot;name&quot;: &quot;1969 Harley Davidson Ultimate Chopper&quot;,    &quot;type&quot;: &quot;Motorcycles&quot;,    &quot;brand&quot;: &quot;Harley Davidson&quot;,    &quot;code&quot;: &quot;S10_1678&quot;,    &quot;since&quot;: &quot;1969&quot;,    &quot;price&quot;: 48.34,    &quot;description&quot;: &quot;This replica features working kickstand, front suspension, gear-shift lever, footbrake lever, drive chain, wheels and steering.&quot;,    &quot;scale&quot;: &quot;10&quot; }' </pre> <p>ElasticSearch View Plugin uses the mapping's <a href="http://www.elasticsearch.org/guide/reference/mapping/meta.html">meta data</a> to store all the views that are associated with a specific document type. Each view has a unique name, a scripting language, a content and potentially a content type.</p> <p>Be careful: as the <a href="http://www.elasticsearch.org/guide/reference/api/update.html">Update API</a>, the <code>_source</code> field need to be enabled for this feature to work.</p> <p>First, we can create a basic view using the <a href="http://mvel.codehaus.org/MVEL+2.0+Basic+Templating">MVEL templating</a> language:</p> <pre> curl -XPUT 'http://localhost:9200/catalog/product/_mapping' -d ' {     &quot;product&quot;: {         &quot;_meta&quot;: {             &quot;views&quot;: {                 &quot;default&quot;: {                     &quot;view_lang&quot;: &quot;mvel&quot;,                     &quot;view&quot;: &quot;Rendering the document #@{_id} in version @{_version} of type @{_type} from index @{_index}&quot;                 }             }         }     } }' </pre> <p>The previous command creates a view called <code>default</code>. The property <code>view_lang</code> can be used to specify the templating engine to use (default is <code>mvel</code>) whereas the <code>view</code> property holds the content of the view. When needed, a specific <code>content_type</code> can be set. Note that the view named <code>default</code> will be used by default to render the documents of type <code>product</code>.</p> <p>In MVEL, the coordinates of the document are available with <code>@{_id}</code>, <code>@{_type}</code> and <code>@{_index}</code> instructions. The original <code>_source</code> of the document can be accessed with <code>@{_source.<em>x</em>}</code> where <em>x</em> is a document property name.</p> <p>Now the view is created, opening the URL <code>http://localhost:9200/_view/catalog/product/1</code> in a web browser will trigger the rendering of document with id 1. The result looks like: <br />
<br />
<img src="/wp-content/uploads/2015/07/.render_default_m.jpg" alt="Default view for product #1" style="display:block; margin:0 auto;" title="Default view for product #1" /> <br />
Simple, no?</p> <h5>Using multiple views</h5> <p>In most use cases, a unique view is not sufficient. That's why the plugins allows to define many views for the same type of document, allowing differents renderings of the same document:</p> <pre> curl -XPUT 'http://localhost:9200/catalog/product/_mapping' -d ' {     &quot;product&quot;: {         &quot;_meta&quot;: {             &quot;views&quot;: {                 &quot;default&quot;: {                     &quot;view_lang&quot;: &quot;mvel&quot;,                     &quot;view&quot;: &quot;Rendering the document #@{_id} in version @{_version} of type @{_type} from index @{_index}&quot;                 },                 &quot;xml&quot;: {                     &quot;view_lang&quot;: &quot;mvel&quot;,                     &quot;content_type&quot;: &quot;text/xml&quot;,                     &quot;view&quot;: &quot;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;product id=&quot;@{_id}&quot;&gt;&lt;name&gt;@{_source.name}&lt;/name&gt;&lt;brand&gt;@{_source.brand}&lt;/brand&gt;&lt;/product&gt;&quot;                 }             }         }     } }' </pre> <p>This way the URL <code>http://localhost:9200/_view/catalog/product/1/xml</code> can be used to access to the XML view of document 1: <br />
<br />
<img src="/wp-content/uploads/2015/07/.render_xml_s.jpg" alt="XML view for product #1" style="display:block; margin:0 auto;" title="XML view for product #1" /> <br />
<br /></p> <h5>Rendering binary fields</h5> <p>If the document contains a <a href="http://www.elasticsearch.org/guide/reference/mapping/core-types.html">binary field</a>, the <code>binary</code> view language can be used to get an octet stream corresponding to the field value.</p> <p>To illustrate that, we can add a new picture field to document 1 (the full JSON content is available on <a href="https://gist.github.com/4337853">gist</a>):</p> <pre> curl -XPUT 'http://localhost:9200/catalog/product/1' -d ' {    &quot;name&quot;: &quot;1969 Harley Davidson Ultimate Chopper&quot;,    &quot;type&quot;: &quot;Motorcycles&quot;,    &quot;brand&quot;: &quot;Harley Davidson&quot;,    &quot;code&quot;: &quot;S10_1678&quot;,    &quot;since&quot;: &quot;1969&quot;,    &quot;price&quot;: 48.34,    &quot;description&quot;: &quot;This replica features working kickstand, front suspension, gear-shift lever, footbrake lever, drive chain, wheels and steering.&quot;,    &quot;scale&quot;: &quot;10&quot;,    &quot;picture&quot;: &quot;/9j/4AAQSkZJRgABAQAAAQABAAD//gA7...&quot; }' </pre> <p>The picture field contains a base64 encoded image of the Harley Davidson's logo.</p> <p>We can now define two more views:</p> <ul> <li><strong>logo</strong>: which renders the picture as binary content</li> <li><strong>full</strong>: which renders the document as  HTML block</li> </ul> <pre> curl -XPUT 'http://localhost:9200/catalog/product/_mapping' -d ' {     &quot;product&quot;: {         &quot;_meta&quot;: {             &quot;views&quot;: {                 &quot;default&quot;: {                     &quot;view_lang&quot;: &quot;mvel&quot;,                     &quot;view&quot;: &quot;Rendering the document #@{_id} in version @{_version} of type @{_type} from index @{_index}&quot;                 },                 &quot;xml&quot;: {                     &quot;view_lang&quot;: &quot;mvel&quot;,                     &quot;content_type&quot;: &quot;text/xml&quot;,                     &quot;view&quot;: &quot;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;product id=&quot;@{_id}&quot;&gt;&lt;name&gt;@{_source.name}&lt;/name&gt;&lt;brand&gt;@{_source.brand}&lt;/brand&gt;&lt;/product&gt;&quot;                 },                 &quot;logo&quot;: {                     &quot;view_lang&quot;: &quot;binary&quot;,                     &quot;view&quot;: &quot;_source.picture&quot;                 },                 &quot;full&quot;: {                     &quot;view_lang&quot;: &quot;mvel&quot;,                     &quot;view&quot;: &quot;&lt;div id=&quot;product-@{_id}&quot;&gt;&lt;img src=&quot;/_view/catalog/product/@{_id}/logo&quot;/&gt;&lt;h2&gt;Detail of @{_source.name.toUpperCase()}&lt;/h2&gt;&lt;p&gt;Year: @{_source.since}, price: @{_source.price}€&lt;/p&gt;&lt;p&gt;@{_source.description}&lt;/p&gt;&lt;p&gt;© Copyright @{_source.brand}&lt;/p&gt;&lt;/div&gt;&quot;                 }             }         }     } }' </pre> <p>The URL <code>http://localhost:9200/_view/catalog/product/1/logo</code> can be used to get the picture of the product, whereas <code>http://localhost:9200/_view/catalog/product/1/full</code> renders the full HTML view: <br />
<br />
<img src="/wp-content/uploads/2015/07/.render_html_s.jpg" alt="HTML view of document #1" style="display:block; margin:0 auto;" title="HTML view of document #1" /> <br />
<br /></p> <h5>Using preloaded templates</h5> <p>Similar to the <a href="http://www.elasticsearch.org/guide/reference/modules/scripting.html">scripting module</a>, the ElasticSearch View Plugin supports predefined templates scripts.</p> <p>The scripts must be placed under the <code>config/views</code> directory and then referencing them by the script name. The way to reference a script differs according to the view language.</p> <p>For example, we can create the file <code>config/views/copyright.mv</code> with the following content:</p> <pre> &lt;p&gt;© Copyright @{_source.brand}&lt;/p&gt; </pre> <p>The <code>.mv</code> extension indicates that the file contains a template written in MVEL.</p> <p>After a cluster restart, we will be able to update the <code>full</code> view in order to use the preloaded template script (note the @includeNamed{} instruction):</p> <pre> ...      &quot;full&quot;: {          &quot;view_lang&quot;: &quot;mvel&quot;,          &quot;view&quot;: &quot;&lt;div id=&quot;product-@{_id}&quot;&gt;&lt;img src=&quot;/_view/catalog/product/@{_id}/logo&quot;/&gt;&lt;h2&gt;Detail of @{_source.name.toUpperCase()}&lt;/h2&gt;&lt;p&gt;Year: @{_source.since}, price: @{_source.price}€&lt;/p&gt;&lt;p&gt;@{_source.description}&lt;/p&gt;@includeNamed{&quot;copyright&quot;}&lt;/div&gt;&quot;      } ...  </pre> <p>Preloaded templates are great candidates for code/text that is used in mulitple views.</p> <h4>Creating complete views from queries</h4> <p>The plugin allows to create custom views from query hits. Everytime such a view is requested, a set of predefined queries are executed and the results are used to create the view. Such views are stored in ElasticSearch as standard documents.</p> <p>This kind of view is really powerful and are a simple way to create complete web pages.</p> <p>First, let's create a more complex template called <code>list-of-products</code> and stored in the file <code>config/views/list-of-products.mv</code>:</p> <pre> &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt;   &lt;head&gt;     &lt;meta charset=&quot;utf-8&quot;&gt;     &lt;title&gt;@{title}&lt;/title&gt;     &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;     &lt;meta name=&quot;description&quot; content=&quot;&quot;&gt;     &lt;meta name=&quot;author&quot; content=&quot;&quot;&gt;     &lt;link href=&quot;http://twitter.github.com/bootstrap/assets/css/bootstrap.css&quot; rel=&quot;stylesheet&quot;&gt;     &lt;style&gt;       body {         padding-top: 60px; /* 60px to make the container go all the way to the bottom of the topbar */       }     &lt;/style&gt;     &lt;!-- HTML5 shim, for IE6-8 support of HTML5 elements --&gt;     &lt;!--[if lt IE 9]&gt;       &lt;script src=&quot;http://html5shim.googlecode.com/svn/trunk/html5.js&quot;&gt;&lt;/script&gt;     &lt;![endif]--&gt;   &lt;/head&gt;   &lt;body&gt;     &lt;div class=&quot;navbar navbar-inverse navbar-fixed-top&quot;&gt;       &lt;div class=&quot;navbar-inner&quot;&gt;         &lt;div class=&quot;container&quot;&gt;           &lt;a class=&quot;btn btn-navbar&quot; data-toggle=&quot;collapse&quot; data-target=&quot;.nav-collapse&quot;&gt;             &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;             &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;             &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;           &lt;/a&gt;           &lt;a class=&quot;brand&quot; href=&quot;#&quot;&gt;Catalog&lt;/a&gt;           &lt;div class=&quot;nav-collapse collapse&quot;&gt;             &lt;ul class=&quot;nav&quot;&gt;               &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;List of products&lt;/a&gt;&lt;/li&gt;             &lt;/ul&gt;           &lt;/div&gt;         &lt;/div&gt;       &lt;/div&gt;     &lt;/div&gt;     &lt;div class=&quot;container&quot;&gt;         &lt;h1&gt;List of products with scale 1:10&lt;/h1&gt;         &lt;table class=&quot;table table-striped&quot;&gt;             &lt;thead&gt;                 &lt;tr&gt;                     &lt;th&gt;Code&lt;/th&gt;                     &lt;th&gt;Name&lt;/th&gt;                     &lt;th&gt;Brand&lt;/th&gt;                     &lt;th&gt;Year&lt;/th&gt;                 &lt;/tr&gt;             &lt;/thead&gt;             &lt;tbody&gt;                 @foreach{item : _queries.products_with_size_1_10}                     &lt;tr&gt;                         &lt;td&gt;@{item._source.code}&lt;/td&gt;                         &lt;td&gt;@{item._source.name}&lt;/td&gt;                         &lt;td&gt;@{item._source.brand}&lt;/td&gt;                         &lt;td&gt;@{item._source.since}&lt;/td&gt;                     &lt;/tr&gt;                 @end{}             &lt;/tbody&gt;         &lt;/table&gt;     &lt;/div&gt;   &lt;/body&gt; &lt;/html&gt; </pre> <p>Next, we can create a view:</p> <pre> curl -XPUT &quot;http://localhost:9200/catalog/list-of-products-by-size/1:10&quot; -d &quot;{     &quot;views&quot;:{         &quot;default&quot;:{             &quot;view_lang&quot;: &quot;mvel&quot;,             &quot;queries&quot;: {                 &quot;products_with_size_1_10&quot;: {                     &quot;indices&quot;: &quot;catalog&quot;,                     &quot;types&quot;: [&quot;product&quot;],                     &quot;query&quot; : {                           &quot;constant_score&quot; : {                               &quot;filter&quot; : {                                   &quot;term&quot; : { &quot;scale&quot; : &quot;10&quot;}                               }                           }                     }                 }             },             &quot;view&quot; : &quot;@includeNamed{'list-of-products'; title='List of products'}&quot;         }     } }&quot; </pre> <p>Note that the view is indexed in <code>catalog</code> index with the <code>list-of-products-by-size</code> document type and id <code>1:10</code>. It defines a view called <code>default</code> (but could have another name) and uses the <code>list-of-products.mv</code> template to render a list of products.</p> <p>The list of products is defined by the <code>products_with_size_1_10</code> query in the <code>queries</code> field of the view. This query selects 10 products that have a scale of 1:10.</p> <p>If you look closely at the previous template, you can see the following code:</p> <pre> @foreach{item : _queries.products_with_size_1_10}     &lt;tr&gt;         &lt;td&gt;@{item._source.code}&lt;/td&gt;         &lt;td&gt;@{item._source.name}&lt;/td&gt;         &lt;td&gt;@{item._source.brand}&lt;/td&gt;         &lt;td&gt;@{item._source.since}&lt;/td&gt;     &lt;/tr&gt; @end{} </pre> <p>This code uses a MVEL templating syntax <code>@foreach{}...@end{}</code> that iterates over the hits provided by the <code>products_with_size_1_10</code> query in order to construct a dynamic table of products that will be rendered in the final HTML page. Of course, multiple queries can be used in the same view.</p> <p>The result is available at <code>http://localhost:9200/_view/catalog/list-of-products-by-size/1:10</code> and looks like: <br />
<br />
<img src="/wp-content/uploads/2015/07/.render_html_list_s.jpg" alt="List of products with scale 1:10" style="display:block; margin:0 auto;" title="List of products with scale 1:10" /> <br />
<br /></p> <h4>Going further...</h4> <h5>Using Mustache</h5> <p>The plugin <a href="https://github.com/tlrx/elasticsearch-view-mustache-plugin">elasticsearch-view-mustache-plugin</a> adds <a href="http://mustache.github.com/">Mustache</a> as templating language for views.</p> <p>Mustache is a great templating engine that supports template encapsulation. To defined views with Mustache template engine, use <code>"view_lang": "mustache"</code>.</p> <p>Some sample usage of this plugin can be found in the Github project.</p> <h5>Rewriting URLs with Apache2</h5> <p>Apache2 server with mod_proxy and mod_rewrite can be used to redirect ElasticSearch Views Plugin URLs to better looking URLs.</p> <p>The goal is to have nicer URLs like <code>http://www.domain.com/catalog/list-of-products-by-size/1:10</code> that points to internal <code>http://localhost:9200/_view/catalog/list-of-products-by-size/1:10</code>.</p> <p>Here is a basic sample of such URL rewriting:</p> <pre> RewriteEngine on RewriteRule ^catalog/(.*)$ http://localhost:9200/_view/catalog/$1 [P,L] </pre> <p><br />
The source code of the samples are available on the GitHub project <a href="https://github.com/tlrx/elasticsearch-view-plugin/tree/master/src/test/resources">here</a>. <br />
<br />
We hope that this plugin will be as useful for you as it is for us, and we welcome your feedback and comments about this new plugin.</p>