---
ID: 99
post_title: 'Spring 3.1 &#8211; Profils et environments (partie 1)'
author: chebert
post_date: 2011-06-28 10:02:00
post_excerpt: |
  <p><em></em>Le framework Spring, <a href="/index.php?post/2009/12/16/Sortie-de-Spring-3.0">que l'on ne présente plus</a>, est en évolution constante. Chaque version ajoute son lot de nouveauté pour augmenter autant la flexibilité que la facilité d'utilisation des outils. La prochaine version majeure en date est la version 3.1 annoncée pour le mois de Juin 2011 (si tout va bien !).<br />
  Bien qu'encore en développement, une première version du framework (milestone 1) est déjà disponible et permet de prévisualiser certaines fonctionnalités d'ores et déjà implémentées.<br />
  Cette suite de billets à pour but de présenter ces nouveautés annoncées/disponibles.</p> <p>Le premier billet sera une introduction au concept de Profils et Environnements, présents dans la première milestone.</p>
layout: post
permalink: http://blog.zenika-offres.com/?p=99
published: true
---
<p><em></em>Le framework Spring, <a href="/index.php?post/2009/12/16/Sortie-de-Spring-3.0">que l'on ne présente plus</a>, est en évolution constante. Chaque version ajoute son lot de nouveauté pour augmenter autant la flexibilité que la facilité d'utilisation des outils. La prochaine version majeure en date est la version 3.1 annoncée pour le mois de Juin 2011 (si tout va bien !).<br />
Bien qu'encore en développement, une première version du framework (milestone 1) est déjà disponible et permet de prévisualiser certaines fonctionnalités d'ores et déjà implémentées.<br />
Cette suite de billets à pour but de présenter ces nouveautés annoncées/disponibles.</p> <p>Le premier billet sera une introduction au concept de Profils et Environnements, présents dans la première milestone.</p>
<!--more-->
<h2>Exemples de code</h2> <p>Pour illustrer chaque fonctionnalité, un projet est disponible sur <a href="https://github.com/ColinHebert/Spring-3.1-Demo">GitHub</a> permettant de retracer l'évolution d'une application et de voir quelles sont les modifications apportées. Chaque point où le code sera mis à jour, un tag ou un identifiant Git permettront d'obtenir le projet en état sur GitHub.<br />
<em>Attention</em>, ce projet servant uniquement de démonstration, il pourrait potentiellement voir son historique réécrit pour plus de clarté (l'article serait mis à jour évidemment).</p> <p>Pour récupérer le code, il suffit de faire&nbsp;:</p> <pre> git clone git://github.com/ColinHebert/Spring-3.1-Demo.git git checkout &lt;branch_name&gt; </pre> <p><strong>DEMO :</strong> Une première version de l'application (qui n'utilise pas Spring) est disponible au tag <a href="https://github.com/ColinHebert/Spring-3.1-Demo/tree/springless">springless</a>.</p> <h2>Spring 3.1, Quoi de neuf&nbsp;?</h2> <p><img src="/wp-content/uploads/2015/07/Milestone2.png" alt="Milestone" style="float:right; margin: 0 0 1em 1em;" title="Milestone" /> La version majeure actuelle de Spring Framework (3.0) est disponible depuis le mois de décembre 2009.<br />
Cette version a apporté entre autres une forte compatibilité avec les nouveautés accompagnant JEE6, telles que Bean Validation (JSR 303), Dependency Injection for Java (JSR-330), JPA 2.0 (JSR 317 et bien d'autres, dans un même temps un nouveau système de configuration d'application Spring en java a été mis en avant. Basé sur les classes, ce système permet de créer des classes décrivant la configuration souhaitée, grâce à l'annotation @Configuration.</p> <p>Dans la continuité de cette amélioration du framework, la version 3.1 propose une plus forte interaction avec d'autres frameworks et outils tout en continuant à améliorer l'utilisabilité par les développeurs.</p> <p>Ces features ont étés étalées sur deux version milestone de Spring 3.1, l'une sortie au mois de février proposant&nbsp;:</p> <ul> <li>La gestion des profils et environnements.</li> <li>L'amélioration de la configuration Spring en java (@FeatureConfiguration).</li> <li>L'ajout d'un namespace supplémentaire c: pour aider et simplifier la configuration XML.</li> <li>Une abstraction des systèmes de cache.</li> </ul> <p>La seconde milestone, initialement prévue pour le mois d'avril, devrait intégrer&nbsp;:</p> <ul> <li>Une personnalisation de la gestion de l'annotation @MVC</li> <li>La gestion des conversations</li> <li>Le support des Servlets 3.0</li> <li>L'amélioration du support de Groovy</li> </ul> <p><em><strong>Attention</strong>, dû à la nature "work in progress" de Spring 3.1, certaines de ces fonctionnalités pourraient de pas figurer sur la version finale et être reportées à des versions ultérieures.</em></p> <h2>Profils et Environnements</h2> <p><img src="/wp-content/uploads/2015/07/Untitled_2.png" alt="Environment" style="display:block; margin:0 auto;" title="Environment" /> Parmi les fonctionnalités attendues et déjà disponibles dans la première milestone, figure la gestion des <strong>profils et environnements</strong>.</p> <h3>Pourquoi&nbsp;?</h3> <p>L'idée, relativement simple, est de donner la possibilité de créer une configuration spring s'adaptant automatiquement à l'environnement dans lequel l'application est exécutée.</p> <p>L'une des utilisations clefs est le changement et la définition de l'environnement d'execution. Par exemple, si l'on a une application qui utilise de la persistance, il est fort probable que durant les différentes phases de développement, la persistance se fasse au travers de systèmes différents&nbsp;:</p> <ul> <li>Durant le développement en soit, les tests unitaires sont exécutés avec une base de données embarquée.</li> <li>Pour certains des tests unitaires une véritable base de données n'est peut-être même pas nécéssaire (par exemple si l'on veut tester la couche service sans que la couche DAO puisse interférer avec les résultats) et c'est une Map/List qui sera utilisée pour un stockage sous la forme la plus simple possible.</li> <li>Durant l'intégration et le déploiement, la connection à la base est obtenue via une DataSource récupérée par JNDI.</li> </ul> <p>Tant de configurations possibles qui demandent chaque fois un nouveau fichier de configuration. Chaque configuration est totalement adaptée aux conditions d'execution, cependant la plupart les configurations ont de fortes similarités, ce qui donne des configurations copiées/collées/modifiées, pour chaque variante que l'on a.<br />
Une autre solution est de composer une configuration à base d'import d'autre fichiers de configuration. Outre le fait que ce système implique d'avoir un florilège de fichiers XML éparpillant la configuration, il faut être extrèmenent prudent lorsque l'on fait les imports pour éviter qu'un import transitif soit fait et rentre en conflict avec d'autres éléments déjà déclarés.<br />
Et généralement pour retourner le couteau dans la plaie, le fait d'avoir plusieurs fichiers de configuration signifie que l'on ne peut pas (sauf si l'on a appliqué une nomenclature de bonne qualité) charger simplement tous les fichiers de configuration avec un masque et que l'on doit charger manuellement tous les fichiers un par un.</p> <p><strong>DEMO :</strong> Le contact book configuré avec un fichier XML de Spring est disponible sur le tag <a href="https://github.com/ColinHebert/Spring-3.1-Demo/tree/spring-xml">spring-xml</a>.<br />
L'application étant plutôt petite, la configuration est relativement légère et ne subit pas fortement les problèmes cités au dessus, cependant une application de plus grande envergure pourrait plus facilement y être exposée.</p> <h3>Comment&nbsp;?</h3> <p>Le principe choisi est d'assigner aux différentes portions de configuration un <strong>profil</strong> (une simple chaine de caractères). Si le profil est activé au chargement de la configuration, alors la portion de configuration associée est effective, dans le cas contraire, elle est purement ignorée.<br />
Si les profils permettent de modulariser la configuration leur état (actif/inactif) est lui conservé au sein de l'<strong>environnement</strong> qui permet donc de déduire quelles portions de configuration sont utilisées.</p> <h4>Charger des fichiers de configuration en bloc</h4> <p>La première étape est de proposer une configuration modulaire.<br />
Pour ça la dernière version du XSD de configuration spring a été remaniée de manière à ajouter un attribut <em>profile</em> sur la balise racine.</p> <pre> &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;        xsi:schemaLocation=&quot;&quot;http://www.springframework.org/schema/beans            http://www.springframework.org/schema/beans/spring-beans-3.1.xsd&quot;        profile=&quot;myProfile&quot;&gt;     ... &lt;/beans&gt; </pre> <p>Spécifier le profil "myProfile" dans la configuration permet, lorsque le fichier de configuration est chargé, de ne prendre en compte le contenu que si le profil "<em>myProfile</em>" est activé dans l'environnement actuel.<br />
Si aucun profil n'est spécifié, le fonctionnement habituel est appliqué; le fichier est simplement traité.</p> <p>Ceci implique donc qu'il est possible de charger en même temps deux fichiers de configuration en conflit si ceux-ci ont des profils différents.<br />
Le problème de chargement de fichiers de configuration manuel est donc réduit, puisqu'il est potentiellement possible de charger tous les fichiers de configuration Spring, tant que les conflits sont évités dans un même profil.</p> <h4>Fusionner les fichiers de configuration</h4> <p>Toujours dans l'idée de proposer de faire des modules au sein d'une configuration, une autre modification a été faite sur le XSD de configuration. Il est maintenant possible d'ajouter une nouvelle balise &lt;beans&gt; (avec un 's') en fin d'un fichier de configuration.<br />
Ces balises peuvent contenir une configuration complète (comme la balise racine) et avoir un profil particulier.</p> <pre> &lt;beans ...&gt;     &lt;bean ... /&gt;     &lt;beans profile=&quot;myProfile&quot;&gt;         &lt;bean ... /&gt;     &lt;/beans&gt; &lt;/beans&gt; </pre> <p>Le fonctionnement est exactement le même qu'un profil sur la racine; le contenu n'est pris en compte que si le profil "<em>myProfile</em>" est activé.<br />
Il est maintenant possible d'ajouter des portions de configuration, basées sur l'activation de profils, au sein d'un même fichier de configuration. <br />
Grâce à ce système, le nombre de "<em>micro-fichiers</em>" inclus pour une configuration peut être fortement réduit.</p> <h4>DRY (Don't Repeat Yourself)</h4> <p>Le dernier point important est d'éviter d'avoir à copier des morceaux de configuration pour deux profils ayant des similarités. Pour ça, l'attribut profile permet de déclarer plusieurs profils pour un même "groupe".</p> <pre> &lt;beans ... profile=&quot;myProfile, myOtherProfile&quot;&gt;      ... &lt;/beans&gt; </pre> <p>De cette manière, si l'un des deux profils ("<em>myProfile</em>" ou "<em>myOtherProfile</em>") est activé, alors le contenu est appliqué dans la configuration Spring.<br />
Le résultat est donc un fichier plus compact avec moins de répétition et de fait beaucoup plus facilement maintenable.</p> <h4>Activer les profils</h4> <p>Maintenant que la configuration est définie par profils, il suffit de spécifier s'ils sont activés ou non.<br />
Il est possible d'activer plusieurs profils simultanément, attention cependant de ne pas activer deux profils incompatibles&nbsp;!</p> <h5>Option en ligne de commande</h5> <p>Le moyen le plus classique de choisir le ou les profils actifs est de lancer l'application avec l'option -Dspring.profiles.active="myProfile".<br />
Si plusieurs profils sont à activer simultanément, il suffit de tous les lister en les séparant par une virgule&nbsp;:  -Dspring.profiles.active="myProfile,myOtherProfile".</p> <h5>Dans une application web</h5> <p>Dans le cas d'une application web il est possible de spécifier dans le web.xml la liste des profils en paramètre de la servlet&nbsp;:</p> <pre> &lt;servlet&gt;     &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;     &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;     &lt;init-param&gt;         &lt;param-name&gt;spring.profiles.active&lt;/param-name&gt;         &lt;param-value&gt;myProfile&lt;/param-value&gt;     &lt;/init-param&gt; &lt;/servlet&gt; </pre> <h5>Manuellement au chargement de la configuration</h5> <p>Il est aussi possible de configurer manuellement les profils au chargement du fichier de configuration.<br />
Pour cela il faut récupérer l'environnement à partir du contexte Spring; et de là  assigner les profils voulus&nbsp;:</p> <p>// context.getEnvironment().setActiveProfiles("myProfile", "myOtherProfile"); //</p> <p><strong>DEMO :</strong> Voici le contact book ayant été remanié pour ajouter la gestion des profils&nbsp;: <a href="https://github.com/ColinHebert/Spring-3.1-Demo/tree/profile-xml">profile-xml</a>.<br />
Cette démonstration ne montre pas un cas "réel" en soit, puisque par exemple il aurait été préférable d'avoir tout de même une séparation entre les fichiers de configuration de test et de production. Seulement pour conserver une application de taille raisonnable et une visualisation simple quelques petites entorses ont été faites.<br />
La sélection des profils est faite manuellement pour éviter d'avoir des résultats différents si ceux-ci n'ont pas été sélectionnés, il est évidemment possible de supprimer la selection manuelle pour utiliser la propriété <em>spring.profiles.active</em>.</p> <h2>Conclusion</h2> <p>Ceci conclu la première partie sur les profils et environnements dans Spring 3.1, un second article détaillera le fonctionnement des profils dans une configuration Spring en Java (@Configuration).</p> <p>Petit message d'avertissement tout de même, cette fonctionnalité, qui est très pratique a n'en pas douter, ne doit pas être abusée. S'il est plus facile d'obtenir une configuration plus succinte grâce aux profils, un seul fichier de configuration monolithique pour une application de taille pourrait rendre le tout inmaintenable.<br />
De la même manière, il est toujours bon de garder séparé les profils de test des profils disponibles en production, inutile d'encombrer l'application distribuée d'un ensemble de profils qui ne seront globalement pas utilisés.</p>