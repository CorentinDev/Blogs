---
ID: 505
post_title: 'Apache Zookeeper: facilitez vous les systèmes distribués'
author: jbaylon
post_date: 2014-10-15 11:30:00
post_excerpt: '<p>Vous (ou votre client) avez besoin de coder un site web en Java. Il ne vous viendrait pas à l’idée d’écrire un serveur d’application en entier, en partant des sockets. De la même manière, si vous avez besoin d’écrire une énorme application distribuée, vous n’allez pas coder tous vos algorithmes de gestion des verrous, de messages, ou vos annuaires de services. Vous utiliserez <strong>Zookeeper</strong> de la fondation <strong>Apache</strong>. Le but de cet article est de vous présenter cet outil.</p>'
layout: post
permalink: http://blog.zenika-offres.com/?p=505
published: true
slide_template:
  - ""
---
<p>Vous (ou votre client) avez besoin de coder un site web en Java. Il ne vous viendrait pas à l’idée d’écrire un serveur d’application en entier, en partant des sockets. De la même manière, si vous avez besoin d’écrire une énorme application distribuée, vous n’allez pas coder tous vos algorithmes de gestion des verrous, de messages, ou vos annuaires de services. Vous utiliserez <strong>Zookeeper</strong> de la fondation <strong>Apache</strong>. Le but de cet article est de vous présenter cet outil.</p>
<!--more-->
<h3>Pour toi qui ne connait pas forcément les systèmes distribués</h3> <p>On est tout à fait conscient que tout le monde ne connait pas sur le bout des doigts les problématiques des <strong>systèmes distribués</strong>. Alors, voici quelques rappels&nbsp;: Un système distribué, fondamentalement, consiste en plusieurs machines connectées entre elles et qui résolvent ensemble un problème, par opposition avec un <strong>système centralisé</strong>, donc une grosse machine unique qui prend tout à sa charge. Le cas d’école est Google, pour lequel aucune machine unique ne saurait traiter toutes les requêtes. Un bon exemple de l’usage qu’on peut en faire est décrit <a href="http://blog.octo.com/sharding/" hreflang="fr" title="ici"></a> . Le simple fait d’avoir plusieurs machines qui doivent travailler ensemble est une source non négligeable de problèmes, parmi lesquels&nbsp;:</p> <ul> <li>La <strong>résistance aux pannes</strong>&nbsp;: si une machine tombe en panne dans le réseau, que faire&nbsp;? Si elle est la seule à porter des informations importantes, celles-ci sont perdues. Dans ce cas, on règle la question avec la <strong>redondance</strong> des informations, <strong>dupliquées</strong> sur plusieurs machines.</li> <li>La <strong>consistance de l’information</strong>, en particulier si elle est dupliquée. Le but est d’offrir une indépendance de la valeur de la donnée par rapport à sa source&nbsp;: on veut éviter que chaque machine porte une version différente, donc surement obsolète, d’une information dont on a besoin.</li> <li>La <strong>répartition de la charge</strong>&nbsp;: comment bien gérer ses ressources pour éviter qu’une seule machine ne soit trop sollicitée, alors que les autres sont inactives&nbsp;?</li> <li>Comment une requête émise par un client est-elle traitée&nbsp;? Qui le fait&nbsp;? Et comment garantir que le résultat est le bon, indépendamment de la machine qui a traité la question&nbsp;? C’est le problème dit du <strong>consensus</strong>&nbsp;: on dit qu’il y a consensus si deux machines ayant les mêmes données initiales donnent le même résultat pour le même traitement.</li> </ul> <p>La liste ci-dessus n’est pas exhaustive, mais il est important de comprendre qu’il s’agit d’un problème fortement non trivial, sur lequel des esprits brillants se sont penchés pendant des années. Ces questions sont donc connues, et il existe des techniques de programmation et des patterns pour y faire face. Ainsi, il est hors de question de redévelopper soi-même son propre système. Ce qu’on attend d’un framework qui prend en charge une telle architecture est&nbsp;:</p> <ul> <li>La <strong>communication entre les instances</strong> (ou machines. Mais si vous voulez faire impression dans une soirée technique, parlez de <strong>nœud</strong> ou d’<strong>instance</strong>). Par exemple, vous voulez envoyer un message à un ensemble d’instances (un <strong>cluster</strong>) pour lancer un traitement. Vous avez aussi besoin de savoir si une instance est opérationnelle, par exemple. Pour bien communiquer, une méthode utilisée consiste en une <strong>queue</strong>. Celle-ci permet d’envoyer des messages directement ou par sujet, de les lire de manière asynchrone, etc. La communication, exactement comme en local avec plusieurs processus, passe par la coordination dans l’usage des ressources. Concrètement, quand un nœud écrit sur un fichier, il est préférable qu’il pose un <strong>verrou</strong>, visible par tous les autres nœuds, sur le dit fichier.</li> <li>Un <strong>système de fichiers distribué</strong>&nbsp;: on ne souhaite pas  savoir que tel fichier est sur l’instance machin. On veut avoir l’illusion de manipuler un unique système de fichiers, exactement comme sur une seule machine. La gestion de la répartition des ressources, avec ce qu’il faut faire si une instance ne répond pas, n’est pas utile à savoir.</li> <li>Un <strong>service de nommage</strong>&nbsp;: pour le présenter, certes de manière approximative, on aimerait une sorte de Map&lt;String,Object&gt; qui soit répartie sur le réseau, que toutes les instances puissent utiliser. Un exemple type serait <strong>JNDI</strong>. Le but du service de nommage consiste à avoir un système distribué d’accès aux objets.</li> <li>Un <strong>système robuste de traitement des requêtes</strong>&nbsp;: imaginons une architecture répartie qui accueille des ordres boursiers en temps réel. On n’est pas à l’abri d’une instance qui ne répond pas, ou d’une connexion réseau qui échoue. Dans ce cas-ci, l’ordre est perdu, la transaction n’est pas réalisée, un trader ne touche pas sa commission, et vous recevez un coup de fil peu aimable dans la minute. Ce n’est pas souhaitable, et il serait bien que le système soit assez robuste pour faire face à une défaillance locale. Plusieurs modèles (commit en deux temps, en trois temps, <strong>algorithme de Paxos</strong>) ont été soumis. Il en ressort que l’on peut donner des rôles à des instances&nbsp;: <strong>leader</strong> d’un traitement métier, ou <strong>follower</strong>. Le premier, pas forcément unique, ordonne et <strong>supervise</strong> un traitement. Le second, pas unique, calcule le résultat. Si le leader fait défaut, un autre prend la relève. Plusieurs followers sont sollicités pour parer au défaut de l’un d’eux. Toujours la même idée&nbsp;: <strong>la redondance créé de la robustesse</strong>.</li> </ul> <h3>Qu’offre Zookeeper&nbsp;?</h3> <p>Si vous suivez ce blog de manière assidue, le nom vous sera déjà familier parce qu’<strong>Apache Storm</strong> utilise Zookeeper pour ses nœuds ( source: <a href="http://blog.zenika.com/index.php?post/2014/01/31/Storm-Ajouter-du-temps-reel-a-votre-BigData" hreflang="fr" title="source"></a> ). Le projet ne se réduit pas à une brique de Storm, il sert à résoudre toute une famille de problèmes qu’on aura forcément dans la conception d’un système distribué&nbsp;:</p> <p><img src="/wp-content/uploads/2015/07/zookeeper_usecases.jpg" alt="zookeeper_usecases.jpg" style="display:block; margin:0 auto;" /></p> <p>Travailler avec un système distribué pose un certain nombre de problèmes qui sont pris en charge par Zookeeper (dont c’est, au fond, la raison d’être)&nbsp;:</p> <ul> <li>Des instances reçoivent des traitements à exécuter, et le traitement doit finir. Cela veut dire qu’il faut en plus un système robuste et résistant aux pannes. Pour cela, pas de secret, Zookeeper utilise un <strong>système de gestion de nœuds redondants</strong> qui réduit considérablement la probabilité d’échec. En substance, un <strong>leader</strong> demande à un groupe (le <strong>quorum</strong>) de <strong>followers</strong> de traiter la requête. Zookeeper implémente une solution pour que le leader soit remplacé s’il est défaillant, et le groupe de followers est suffisamment vaste pour gérer la panne d’un des nœuds, et donc, avoir une réponse. En conséquence, plus d’instance améliore drastiquement la résistance aux pannes…</li> <li>Pour réaliser ces traitements, ces instances communiquent sur un système de fichiers commun, dit système de fichiers distribué. Zookeeper en propose une version <strong>hiérarchique</strong> dont les nœuds sont des <strong>ZNodes</strong>, avec authentification au besoin. Coordonner la lecture et l’écriture est un problème qui se règle avec l’utilisation de <strong>verrous</strong>.</li> <li>Ces instances ont besoin de s’échanger des informations par un moyen direct.  Une <strong>queue</strong> est mise en place pour l’envoi de messages, et il est possible de notifier des nœuds.</li> <li>Ces instances ont besoin d’accéder à des objets partagés, et nommés. C’est précisément le rôle d’un <strong>service de nommage</strong>.</li> </ul> <h4>Pourquoi Zookeeper est-il plus fiable&nbsp;?</h4> <p>Zookeeper utilise plusieurs grandes idées pour garantir que la panne de nœuds n’affecte pas le système dans son ensemble. Sur le principe,
 il définit son propre algorithme, le <strong>Zookeeper Atomic Broadcast</strong> en se basant sur l’<strong>algorithme de Paxos</strong> qu’il améliore. La première question qu’on a envie de poser est celle du <strong>consensus</strong>&nbsp;: on souhaite que toutes les instances sollicitées répondent la même chose si elles ont la même donnée initiale. En 1985, tout espoir s’envole avec le théorème de Lynch, Fisher et Paterson&nbsp;: c’est <em>impossible</em> dans le cas général. L’<strong>algorithme de Paxos</strong> garantit une forme de consensus, ce qui est aussi le cas chez Zookeeper. Il y a plusieurs grandes étapes&nbsp;:</p> <ol> <li>Un client soumet une requête</li> <li>Un nœud leader est élu et se charge de la requête. <strong>L’élection</strong> se base sur un numéro de version&nbsp;: le nœud qui a le plus élevé est considéré comme leader.</li> <li>Le leader demande à un ensemble de followers (ensemble appelé <strong>quorum</strong>) leur aide pour traiter le problème. Les followers reçoivent donc une demande et répondent au leader. Si celui-ci ne répond pas, un nouveau leader est choisi. Ainsi, on évite que le leader ne devienne un <strong>SPOF</strong>, c’est-à-dire un Single Point of Failure.</li> <li>Le leader établit une connexion point à point avec chaque élément du quorum et leur soumet la requête. L’intérêt d’avoir tout un quorum à disposition est que si un nœud du quorum ne répond pas, les autres peuvent réussir à le faire.</li> <li>Le quorum envoie le résultat au leader. Celui-ci envoie l’ordre de fin de traitement (<strong>commit</strong>). Le consensus est respecté, le résultat est utilisable.</li> </ol> <h3>Comment s’en servir&nbsp;?</h3> <p>La classe principale, celle qui porte la grande majorité des opérations utiles, est <em>Zookeeper</em>. Les main sont là pour lancer les instances en fonction de leur rôle.</p> <p><img src="/wp-content/uploads/2015/07/zookeeper_classes.jpg" alt="zookeeper_classes.jpg" style="display:block; margin:0 auto;" /></p> <h4>En Zookeeper, tout est fichier</h4> <p>Conceptuellement, le système de fichier est structuré comme un arbre. Chaque nœud porte un nom contenant des / et suivant le principe de <strong>hiérarchie</strong>&nbsp;: / est le nœud racine, /zksupernode un de ses enfants et /zksupernode /zknode un enfant de l’enfant. Les nœuds ont un double rôle&nbsp;: ils portent du contenu et peuvent avoir des enfants. Les permissions sont gérées par les <strong>ACL</strong> (AC pour access control). En résumé, Zookeeper propose un système de fichier hiérarchique. Il existe deux types de nœuds&nbsp;: les nœuds <strong>persistants</strong> et les nœuds <strong>éphémères</strong>. Les premiers, comme leur nom l’indique, survivront au traitement en cours. Les seconds sont plus utiles comme fichier de travail pendant une session, et sont ensuite perdus.</p> <h5>Mais où sont les classes Queue et Lock&nbsp;?</h5> <p>Eh bien, autant vous le dire tout de suite, il n’y en a absolument pas, parce que <strong>tout est géré par des ZNodes ayant des noms particuliers</strong>&nbsp;! Autrement dit, le système de fichiers est la base de la gestion des verrous et de queues. En effet, sur la gestion des queues, il suffit de créer un ZNode dont le nom termine par queue-M avec M un nombre relatif à la priorité. De même, un nom de ZNode avec read- créé un verrou en lecture, et on utilise write- pour un verrou en écriture.</p> <h5>Tout est fichier&nbsp;: choisir un leader</h5> <p>Parler du processus d’élection du leader est un excellent exemple d’utilisation des conventions de nommage sur les nœuds. L’algorithme se décrit en pseudo-code comme suit, à partir d’un chemin absolu ELECTION dans les ZNodes. Pour qu’un nœud demande le rôle de leader, il déroule les étapes suivantes&nbsp;:</p> <ol> <li>Création d’un ZNode séquentiel et éphémère ayant comme chemin "ELECTION/n_" où n est un numéro servant de numéro de version de la demande, en substance.</li> <li>Les nœuds ELECTION/n_i vont être créés par les prétendants pour avoir le rôle de leader. La valeur de i suit une séquence croissante.</li> <li>Le leader est celui qui a créé le nœud avec le numéro le plus élevé.</li> <li>En général, on utilise un autre nœud pour dire qu’un leader a été choisi et que celui-ci commence un traitement.</li> </ol> <h3>Apache Curator&nbsp;: le complément indispensable</h3> <p><img src="http://curator.apache.org/images/curator-logo.png" alt="" /></p> <p><strong>Netflix</strong> a développé les bases d’une API de plus haut niveau sur Zookeeper, et le projet est passé dans l’incubateur d’Apache, il s’agit d’<strong>Apache Curator</strong> (actuellement en version 0.7, mais son usage par Netflix lui confère une certaine légitimité).</p> <p>L’apport de cette API est de faciliter l’usage de Zookeeper en fournissant des abstractions qui cachent tout ce qu’on vous a expliqué précédemment. Curator propose en effet&nbsp;:</p> <ul> <li>Un système de <strong>gestion de leader</strong> avec un algorithme de sélection garantissant à la fin un leader unique.</li> <li>Un système complet de <strong>gestion des verrous</strong>&nbsp;: mise en place de verrous partagés, mise en place d’un système de <strong>barrières</strong>. Les barrières sont une condition bloquante sur un nœud et ses enfants. Tant que la condition n’est pas vérifiée, le nœud reste bloqué.</li> <li>Un système de <strong>caches</strong> sur le contenu d’un nœud.</li> <li>Un système de <strong>compteur</strong> (exactement comme une séquence en Oracle) distribué. C’est particulièrement utile pour savoir qui a la dernière version d’une information.</li> <li>La gestion de la communication avec des <strong>queues</strong>&nbsp;: queue avec id, queue avec priorité sont deux exemples</li> </ul> <p>Par exemple, sur la documentation officielle ( <a href="http://curator.apache.org/index.html" hreflang="fr" title="ici"></a> ) on trouve ce fragment de code qui vaut bien mieux qu’on long discours&nbsp;:</p> <pre class="java code java" style="font-family:inherit">InterProcessMutex lock <span style="color: #339933;">=</span> <span style="color: #000000; font-weight: bold;">new</span> InterProcessMutex<span style="color: #009900;">&#40;</span>client, lockPath<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span> <span style="color: #000000; font-weight: bold;">if</span> <span style="color: #009900;">&#40;</span> lock.<span style="color: #006633;">acquire</span><span style="color: #009900;">&#40;</span>maxWait, waitUnit<span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span>     <span style="color: #000000; font-weight: bold;">try</span>     <span style="color: #009900;">&#123;</span>         <span style="color: #666666; font-style: italic;">// do some work inside of the critical section here</span>     <span style="color: #009900;">&#125;</span>     <span style="color: #000000; font-weight: bold;">finally</span>     <span style="color: #009900;">&#123;</span>         lock.<span style="color: #006633;">release</span><span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>     <span style="color: #009900;">&#125;</span> <span style="color: #009900;">&#125;</span></pre> <h3>Conclusion</h3> <p>Nous avons mis en place, sur une mission précédente, un outil de synchronisation de processus par une queue stockée en base sans se baser sur un framework. Le retour d’expérience est simple&nbsp;: il est indispensable de ne pas réinventer la roue sur des problématiques complexes comme la conception d’un système distribué. Donc, Zookeeper a vraiment sa place dans une architecture. Pour autant, est-ce la solution ultime, celle qui répond forcément à chaque besoin client&nbsp;? Non, mais en tant que brique logicielle avec un outil complémentaire par dessus, elle prend tout son sens. A ce titre, connaitre ce framework est
 une étape nécessaire pour administrer ou concevoir un système distribué. Mais Storm est un bon exemple de l’abstraction qu’on peut attendre au-dessus de Zookeeper.</p> <h4>Et si vous voulez en savoir plus</h4> <ul> <li>Storm et Zookeeper: <a href="http://ptgoetz.github.io/blog/2013/12/18/running-apache-storm-on-windows/" hreflang="en" title="Installer Storm au dessus de Zookeeper"></a></li> <li>Présentation en français de Zookeeper <a href="http://fr.slideshare.net/barkbay/prsentation-de-apache-zookeeper" hreflang="fr" title="Un présentation de Zookeeper un peu théorique"></a></li> <li>Zookeeper en pratique: <a href="http://fr.slideshare.net/sauravhaloi/introduction-to-apache-zookeeper" hreflang="en" title="Zookeeper en pratique"></a></li> <li>Paxos, la base de la coordination: <a href="http://fr.wikipedia.org/wiki/Paxos_(informatique)" hreflang="fr" title="Paxos: l&#039;algorithme de base sur les systèmes distribués"></a></li> <li>Le ZAB en détail <a href="https://zookeeper.apache.org/doc/r3.1.2/zookeeperInternals.html#sc_atomicBroadcast" hreflang="en" title="En savoir plus sur le ZAB"></a></li> <li>Comprendre les queues en Zookeeper&nbsp;: <a href="http://zookeeper.apache.org/doc/r3.4.6/recipes.html#sc_recipes_Queues" hreflang="en" title="Pour comprendre les queues en Zookeeper"></a></li> </ul>