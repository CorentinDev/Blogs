---
ID: 405
post_title: 'Coherence Part III : Filtres'
author: team-bourgain-tinon
post_date: 2011-11-25 09:59:00
post_excerpt: |
  <p>Les datagrids fournissent des mécanismes de recherche de données adaptés à leur caractère distribué. Chaque requête est envoyée à chaque noeud du cluster qui retourne une partie du résultat, à la manière de Map/Reduce. En parallélisant le traitement, les datagrids tirent parti de toute la puissance de calcul du cluster. <br />
  Dans cet article, nous allons voir comment utiliser les filtres Coherence pour effectuer des recherches optimisées.</p>
layout: post
permalink: http://blog.zenika-offres.com/?p=405
published: true
slide_template:
  - ""
---
<p>Les datagrids fournissent des mécanismes de recherche de données adaptés à leur caractère distribué. Chaque requête est envoyée à chaque noeud du cluster qui retourne une partie du résultat, à la manière de Map/Reduce. En parallélisant le traitement, les datagrids tirent parti de toute la puissance de calcul du cluster. <br />
Dans cet article, nous allons voir comment utiliser les filtres Coherence pour effectuer des recherches optimisées.</p>
<!--more-->
<p>Les caches Coherence implémentent l'interface <strong><a href="http://download.oracle.com/docs/cd/E23332_01/coh.360/e15725/com/tangosol/util/QueryMap.html">QueryMap</a></strong> qui fournit entre autres des méthodes de recherche spécifiques. Quand une recherche est lancée, le nœud d'origine distribue la requête sur les autres noeuds qui vont effectuer la recherche sur les données qu'ils contiennent localement puis attend le retour de chaque nœud pour constituer le résultat final.</p> <p>Ces méthodes de recherche font appel à l'API <strong><a href="http://download.oracle.com/docs/cd/E23332_01/coh.360/e15725/com/tangosol/util/Filter.html">Filter</a></strong>. Le <strong>Filter</strong>  est appliqué sur chaque entrée du cache et détermine si elle appartient au résultat, Coherence fournit un ensemble plutôt complet de <strong>Filter</strong>s pour les comparaisons de base&nbsp;: <strong>EqualsFilter</strong>, <strong>LessFilter</strong>, <strong>LessEqualsFilter</strong>, <strong>RegexpFilter</strong> etc .  Il existe aussi des filtres sur les <strong>Collections</strong> comme le <strong>ContainsAnyFilter</strong>.</p> <h3>A la recherche du Owner perdu&nbsp;!</h3> <p>Nous allons remplacer la boucle inefficace de la méthode <strong>findOwner()</strong> par une recherche par filtre. Dans notre cas, le <strong>Filter</strong> le plus adapté est le <strong>LikeFilter</strong> qui permet de comparer des String avec wildcard. C'est l'équivalent du like en SQL. Nous lui passons le nom de la méthode à appeler sur l'entrée du cache. Le prochain article traitera les cas plus complexes de recherche.</p> <pre class="java code java" style="font-family:inherit"><span style="color: #000000; font-weight: bold;">public</span> Collection<span style="color: #339933;">&lt;</span>Owner<span style="color: #339933;">&gt;</span> findOwners<span style="color: #009900;">&#40;</span><span style="color: #003399;">String</span> lastName<span style="color: #009900;">&#41;</span> <span style="color: #000000; font-weight: bold;">throws</span> DataAccessException <span style="color: #009900;">&#123;</span> 	<span style="color: #666666; font-style: italic;">// create the filter, search  is the escape char and the last param is set to true to be case insensitive</span> 	Filter lastNameFilter <span style="color: #339933;">=</span> <span style="color: #000000; font-weight: bold;">new</span> LikeFilter<span style="color: #009900;">&#40;</span><span style="color: #0000ff;">&quot;getLastName&quot;</span>, lastName <span style="color: #339933;">+</span> <span style="color: #0000ff;">&quot;%&quot;</span>, <span style="color: #0000ff;">'<span style="color: #000099; font-weight: bold;">\</span>'</span>, <span style="color: #000066; font-weight: bold;">true</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span> &nbsp; 	<span style="color: #666666; font-style: italic;">// execute the request synchronously</span> 	Set<span style="color: #339933;">&lt;</span>Entry<span style="color: #339933;">&lt;</span>Integer, Owner<span style="color: #339933;">&gt;&gt;</span> entrySet <span style="color: #339933;">=</span> getOwnersCache<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span>.<span style="color: #006633;">entrySet</span><span style="color: #009900;">&#40;</span>lastNameFilter<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span> &nbsp; 	<span style="color: #666666; font-style: italic;">// build the result</span> 	List<span style="color: #339933;">&lt;</span>Owner<span style="color: #339933;">&gt;</span> result <span style="color: #339933;">=</span> <span style="color: #000000; font-weight: bold;">new</span> ArrayList<span style="color: #339933;">&lt;</span>Owner<span style="color: #339933;">&gt;</span><span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span> 	<span style="color: #000000; font-weight: bold;">for</span> <span style="color: #009900;">&#40;</span>Entry<span style="color: #339933;">&lt;</span>Integer, Owner<span style="color: #339933;">&gt;</span> entry <span style="color: #339933;">:</span> entrySet<span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span> 		result.<span style="color: #006633;">add</span><span style="color: #009900;">&#40;</span>entry.<span style="color: #006633;">getValue</span><span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span> 	<span style="color: #009900;">&#125;</span> 	<span style="color: #000000; font-weight: bold;">return</span> result<span style="color: #339933;">;</span> <span style="color: #009900;">&#125;</span></pre> <h3>Combo&nbsp;!</h3> <p>Coherence propose aussi un ensemble de filtres particuliers pour matcher des entrées avec des critères complexes. Par exemple, le <strong>AndFilter</strong> combine les conditions de deux filtres sur chaque entrée. Dans la même veine, on trouve les <strong>OrFilter</strong>  et <strong>XorFilter</strong> ainsi que les variantes avec plus de deux filtres en entrée. On a donc&nbsp;:</p> <pre class="java code java" style="font-family:inherit">Filter filter1 <span style="color: #339933;">=</span> <span style="color: #000000; font-weight: bold;">new</span> LikeFilter<span style="color: #009900;">&#40;</span><span style="color: #0000ff;">&quot;getSomeAttribute&quot;</span>, theStringToMatch<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span> Filter filter2 <span style="color: #339933;">=</span> <span style="color: #000000; font-weight: bold;">new</span> EqualsFilter<span style="color: #009900;">&#40;</span><span style="color: #0000ff;">&quot;getAnotherAttribute&quot;</span>, <span style="color: #cc66cc;">2</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span> Filter andFilter <span style="color: #339933;">=</span> <span style="color: #000000; font-weight: bold;">new</span> AndFilter<span style="color: #009900;">&#40;</span>filter1, filter2<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span> <span style="color: #003399;">Set</span> theResult <span style="color: #339933;">=</span> cache.<span style="color: #006633;">entrySet</span><span style="color: #009900;">&#40;</span>andFilter<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span></pre> <h3>Optimiser la consommation mémoire</h3> <p>La recherche est distribuée sur le cluster mais le résultat finira dans la JVM qui a lancé la recherche, il peut donc parfois être utile de limiter la consommation mémoire du résultat. Il y a deux solutions à ce problème. La première est d'utiliser la méthode <strong>keySet(Filter)</strong> de <strong>QueryMap</strong>, qui va retourner uniquement les clés dont la valeur associée est retournée par le <strong>Filter</strong>, on évite ainsi de faire monter toutes les graphes d'objets contenus dans les valeurs dans la mémoire. Ainsi, il est possible d'itérer sur le keySet et de récupérer les valeurs une par une ou par petit groupe avec <strong>get()</strong> et <strong>getAll()</strong>, c'est du lazy loading. Attention avec <strong>get()</strong>, chaque appel effectue un appel réseau pour récupérer la donnée, ce qui est déconseillé dans le cas d'un grand nombre d'objets et devrait être limité à des cas particuliers pour lesquels le <strong>getAll()</strong> pose des problèmes.</p> <p>L'autre manière de faire est d'utiliser un <strong>LimitFilter</strong>. Ce filtre prend en paramètre un autre filtre et va simplement limiter le nombre de résultats, on peut donc faire de la pagination coté serveur, au niveau de l'accès aux données.</p> <pre class="java code java" style="font-family:inherit"><span style="color: #000000; font-weight: bold;">public</span> Collection<span style="color: #339933;">&lt;</span>Owner<span style="color: #339933;">&gt;</span> findOwners<span style="color: #009900;">&#40;</span><span style="color: #003399;">String</span> lastName<span style="co
lor: #009900;">&#41;</span> <span style="color: #000000; font-weight: bold;">throws</span> DataAccessException <span style="color: #009900;">&#123;</span> 	Filter lastNameFilter <span style="color: #339933;">=</span> <span style="color: #000000; font-weight: bold;">new</span> LikeFilter<span style="color: #009900;">&#40;</span><span style="color: #0000ff;">&quot;getLastName&quot;</span>, lastName <span style="color: #339933;">+</span> <span style="color: #0000ff;">&quot;%&quot;</span>, <span style="color: #0000ff;">'<span style="color: #000099; font-weight: bold;">\</span>'</span>, <span style="color: #000066; font-weight: bold;">true</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span> 	Filter limitFilter <span style="color: #339933;">=</span> <span style="color: #000000; font-weight: bold;">new</span> LimitFilter<span style="color: #009900;">&#40;</span>lastNameFilter, <span style="color: #cc66cc;">30</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span> &nbsp; 	<span style="color: #666666; font-style: italic;">// fetch the 30 first Owners matching the lastNameFilter</span> 	Set<span style="color: #339933;">&lt;</span>Entry<span style="color: #339933;">&lt;</span>Integer, Owner<span style="color: #339933;">&gt;&gt;</span> entrySet <span style="color: #339933;">=</span> getOwnersCache<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span>.<span style="color: #006633;">entrySet</span><span style="color: #009900;">&#40;</span>limitFilter<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span> &nbsp; 	List<span style="color: #339933;">&lt;</span>Owner<span style="color: #339933;">&gt;</span> result <span style="color: #339933;">=</span> <span style="color: #000000; font-weight: bold;">new</span> ArrayList<span style="color: #339933;">&lt;</span>Owner<span style="color: #339933;">&gt;</span><span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span> 	<span style="color: #000000; font-weight: bold;">for</span> <span style="color: #009900;">&#40;</span>Entry<span style="color: #339933;">&lt;</span>Integer, Owner<span style="color: #339933;">&gt;</span> entry <span style="color: #339933;">:</span> entrySet<span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span> 		result.<span style="color: #006633;">add</span><span style="color: #009900;">&#40;</span>entry.<span style="color: #006633;">getValue</span><span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span> 	<span style="color: #009900;">&#125;</span> 	<span style="color: #000000; font-weight: bold;">return</span> result<span style="color: #339933;">;</span> <span style="color: #009900;">&#125;</span></pre> <p>Pour accéder aux autres pages, il faut appeler la méthode <strong>setPage(int)</strong>  (ou <strong>nextPage()</strong> et <strong>previousPage()</strong> qui ne font qu'incrémenter ou décrémenter à partir du numéro de page actuel) puis réexéctuer la requête (eg entrySet() ou keySet()) avec le filtre. La documentation de Coherence précise qu'il faut utiliser la même instance de <strong>LimitFilter</strong> à chaque appel.</p> <h3>C'est tout pour aujourd'hui</h3> <p>Les filtres peuvent utiliser des index pour accélérer les recherches en évitant de parcourir et donc de-sérialiser l'ensemble des données du cache et ils serviront aussi à exécuter des traitements distribués sur le cluster mais ceci est une autre histoire et d'autres articles.</p> <p>Comme toujours, le code peut être récupéré&nbsp;:</p> <p>GitHub&nbsp;:</p> <pre class="bash code bash" style="font-family:inherit"><span style="color: #c20cb9; font-weight: bold;">git</span> clone <span style="color: #c20cb9; font-weight: bold;">git</span>:<span style="color: #000000; font-weight: bold;">//</span>github.com<span style="color: #000000; font-weight: bold;">/</span>obourgain<span style="color: #000000; font-weight: bold;">/</span>petclinic-coherence.git <span style="color: #c20cb9; font-weight: bold;">git</span> checkout article3-end</pre> <p>et en <a href="/wp-content/uploads/2015/07/petclinic-coherence-article3-end.zip">zip</a></p> <p>Index des articles de la série Coherence&nbsp;:</p> <ul> <li><a href="index.php?post/2011/08/12/Coherence-PetCinic">Introduction à Coherence: Part I</a></li> <li><a href="index.php?post/2011/08/25/Introduction-à-Coherence%3A-Part-II">Introduction à Coherence: Part II</a></li> <li><a href="index.php?post/2011/10/07/Introduction-à-Coherence%3A-Part-III">Coherence Part III&nbsp;: Filtres</a></li> <li><a href="index.php?post/2012/01/09/Coherence-Part-IV-%3A-extracteurs-et-recherches-distribuées-sur-le-cluster">Coherence Part IV&nbsp;: extracteurs et recherches distribuées sur le cluster</a></li> <li><a href="index.php?post/2012/01/03/Coherence-Part-IV-%3A-optimisations-des-requêtes-avec-des-index6">Coherence Part V&nbsp;: optimisations des requêtes avec des index</a></li> <li><a href="index.php?post/2012/01/06/Coherence-Part-VI-%3A-traitement-de-données-distribuées%2C-in-place-processing4">Coherence Part VI&nbsp;: traitement de données distribuées, concurrence et in-place processing</a></li> </ul>