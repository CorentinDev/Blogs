---
ID: 102
post_title: Désérialisation et cycle
author: vpernin
post_date: 2011-06-13 19:00:00
post_excerpt: '<p>Je vais vous exposer dans ce billet le cas de la désérialisation objets contenant des références circulaires et les problèmes que cela peut poser.</p>'
layout: post
permalink: http://blog.zenika-offres.com/?p=102
published: true
---
<p>Je vais vous exposer dans ce billet le cas de la désérialisation objets contenant des références circulaires et les problèmes que cela peut poser.</p>
<!--more-->
<h2>Introduction</h2> <p>Si deux objets :<br /></p> <ul> <li>se référencent l'un et l'autre et qu'une des deux références est présente dans une collection de type <code>Set</code>, c'est à dire une collection assurant l'unicité des ses éléments et donc utilisant la méthode <code>hashCode()</code></li> <li>que la méthode <code>hashCode()</code> utilise (comme les bonnes pratiques le définissent) un membre non primitif immuable</li> <li>sont désérialisés</li> </ul> <p>Alors on peut obtenir un magnifique <code>NullPointerException</code> (NPE).</p> <p>Ce cas de figure est en réalité assez fréquent, on peut le retrouver sur un mapping Hibernate/JPA bidirectionnel de type OneToMany et ManyToOne dans une architecture où les objets transitent entre le client lourd et le serveur via du remoting utilisant la sérialisation/désérialisation Java (Spring HTTP Remoting).<br />
Effectuer une modélisation avec des références circulaires n'est certes pas idéal mais plutôt pratique dans la vie réelle des projets.</p> <h2>Démonstration</h2> <p>Illustrons le cas avec un test unitaire simplifié au maximum.<br /></p> <h3>Modèle</h3> <p>On va s'appuyer sur un modèle simple composé d'un parent, la classe Root contenant une association sur ses enfants, la classe Child.</p> <pre> public class Child implements Serializable { 	private static final long serialVersionUID = 1L; 	// Immuable et unique 	private String code; 	// ManyToOne 	private Root root; 	public Child(String code, Root root) { 		this.code = code; 		this.root = root; 	} 	public String getCode() { 		return code; 	} 	public Root getRoot() { 		return root; 	} 	@Override 	public int hashCode() { 		// KO - NPE 		return code.hashCode(); 	} 	@Override 	public boolean equals(Object obj) { 		if (this == obj) 			return true; 		if (obj == null) 			return false; 		if (getClass() != obj.getClass()) 			return false; 		Child other = (Child) obj; 		if (code == null) { 			if (other.code != null) 				return false; 		} else if (!code.equals(other.code)) 			return false; 		return true; 	} } public class Root implements Serializable { 	private static final long serialVersionUID = 1L; 	// OneToMany 	private Collection&lt;Child&gt; children; 	public Collection&lt;Child&gt; getChildren() { 		return children; 	} 	public void setChildren(Collection&lt;Child&gt; children) { 		this.children = children; 	} }</pre> <p>On a donc bien une classe <code>Root</code> avec une collection de <code>Child</code> ayant eux mêmes une référence en retour sur leur <code>Root</code>. La collection de <code>Child</code> est un <code>HashSet</code> vérifiant donc l'unicité des ses éléments.<br /></p> <h3>Test</h3> <p>On va créer une instance de <code>Root</code> contenant deux instances de <code>Child</code> puis sérialiser et désérialiser un des <code>Child</code>.<br />
Le child désérialisé devrait être le même que le child originel.<br /></p> <pre> public class UnserializeCycle { 	private Root root; 	private Child child1; 	private Child child2; 	@Before 	public void initObjects() { 		root = new Root(); 		child1 = new Child(&quot;child1&quot;, root); 		child2 = new Child(&quot;child2&quot;, root); 		Collection&lt;Child&gt; children = new HashSet&lt;Child&gt;(); 		children.add(child1); 		children.add(child2); 		root.setChildren(children); 	} 	@Test 	public void testUnserialization() throws Exception { 		Child unserializedChild = serializeAndUnserializeChild(child1); 		Assert.assertNotNull(unserializedChild); 		Assert.assertEquals(child1, unserializedChild); 		Assert.assertEquals(&quot;child1&quot;, unserializedChild.getCode()); 		Assert.assertEquals(child1.hashCode(), unserializedChild.hashCode()); 		Collection&lt;Child&gt; children = root.getChildren(); 		Collection&lt;Child&gt; unserializedChildren = unserializedChild.getRoot().getChildren(); 		Assert.assertEquals(children, unserializedChildren); 		Assert.assertTrue(unserializedChildren.contains(child1)); 	} 	private Child serializeAndUnserializeChild(Child child) throws Exception { 		String fileName = &quot;child.ser&quot;; 		FileOutputStream fileOut = new FileOutputStream(fileName); 		ObjectOutputStream out = new ObjectOutputStream(fileOut); 		out.writeObject(child); 		fileOut.close(); 		FileInputStream fileIn = new FileInputStream(fileName); 		ObjectInputStream in = new ObjectInputStream(fileIn); 		return (Child) in.readObject(); 	} } </pre> <h3>Résultat du test</h3> <p>Le test échoue sur une exception. Plus précisément, la méthode <code>hashCode()</code> de <code>Child</code> lève un NPE car le code est <code>null</code>. Voici un extrait de la stacktrace :<br /></p> <pre> java.lang.NullPointerException 	at Child.hashCode(UnserializeCycle.java:135) 	at java.util.HashMap.put(HashMap.java:372) 	at java.util.HashSet.readObject(HashSet.java:292) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:597) 	at java.io.ObjectStreamClass.invokeReadObject(ObjectStreamClass.java:974) 	at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:1848) 	at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:1752) 	at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1328) 	at java.io.ObjectInputStream.defaultReadFields(ObjectInputStream.java:1946) 	at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:1870) 	at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:1752) 	at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1328) 	at java.io.ObjectInputStream.defaultReadFields(ObjectInputStream.java:1946) 	at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:1870) 	at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:1752) 	at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1328) 	at java.io.ObjectInputStream.readObject(ObjectInputStream.java:350) 	at UnserializeCycle.serializeAndUnserializeChild(UnserializeCycle.java:90) 	at UnserializeCycle.testUnserialization(UnserializeCycle.java:24) </pre> <p>En effet, au moment d'insérer le <code>child1</code> dans le <code>Set</code>, l'instance n'est pas encore complétement initialisée, tous ses membres sont donc <code>null</code>.<br />
Cela fait un peu penser aux cas de lignes en base se référençant l'une et l'autre. On ne peut les insérer directement du fait des contraintes de clés étrangères. On insère donc les deux lignes avec null dans la colonne de lien d'une des deux lignes, puis on met à jour la colonne null avec l'identifiant de l'autre ligne. <br />
La JVM sait très bien gérer les références circulaires lors de la désérialisation mais pas lorsqu'un <code>Set</code> est de la partie.<br />
<br /></p> <p>A noter qu'il faut se méfier de l'utilisation du helper <code>HashCodeBuilder</code> du la librairie Commons Lang qui ignore silencieusement une variable qui lui est passée si elle est <code>null</code>.<br />
Notons également que le test n'échouerait pas sur un NPE si le code était de type primitif, tel qu'un int, sa valeur étant en effet initialisée. Cela pourrait faire l'objet d'un prochain billet afin de creuser les mécanismes de désérialisation internes de la JVM.</p> <h2>Recherche de solution</h2> <p>Tentons de trouver une solution.<br />
Le hashCode de la classe <code>Child</code> pourrait être tolérant au NPE. On l'implémenterait de la sorte :<br /></p> <pre> return (code != null) ? code.hashCode() : super.hashCode(); </pre> <p>La méthode <code>hashCode()</code> ne lève alors plus de NPE. Toutefois, le test n'est toujours pas "vert". On va voir pourquoi dans un instant.<br />
Revenons rapidement sur cette alternative qui peut sembler séduisante à premier abord.<br />
On dispose désormais de deux moyens de calculer le hashCode pour un même objet. Cela peut poser problème car rien ne garanti que le hashCode produit par la classe mère (Object ou autre) ne produira pas de collision avec le hashCode généré à partir du code lorsqu'il est non <code>null</code>.<br />
<br />
Le test n'échoue donc pas sur la désérialisation et l'assertion de vérification d'égalité des deux collections originelles et désérialisées de <code>Child</code> renvoie bien true <code>Assert.assertEquals(children, unserializedChildren);</code>.<br /></p> <p>Toutefois, le test ne serait pas complet si l'on ne vérifiait pas que la collection désérialisée contient bien le child1 d'origine. C'est l'objet de l'assert <code>Assert.assertTrue(unserializedChildren.contains(child));</code><br />
Ce dernier nous donne un test "rouge" car la <code>Entry<a href=""></a> table</code> sous jacente à la <code>HashMap</code> derrière le <code>Set</code> possède bien le child1 mais "rangée" ailleurs. En effet les membres utilisés par le hashCode sont censés être immuables. Etant donné que la méthode <code>hashCode()</code> est invoquée par la JVM alors que l'objet n'est pas encore complètement initialisé, il se retrouve être "rangé" à la mauvaise position dans le tableau.<br />
<br />
La récupération du child1 s'appuyant sur son hashCode et ce dernier renvoyant la bonne valeur car l'objet est maintenant complètement initialisé, on va chercher au mauvais endroit dans le tableau et on ne retrouve pas le child1.<br />
<br />
Au final le <code>Set</code> de <code>Child</code> désérialisé est différent de celui d'origine même si le assert <code>Assert.assertEquals(children, unserializedChildren);</code> nous dit le contraire.<br />
<br />
L'explication est toute simple à la lecture du code. En effet, le <code>equals()</code> sur les deux <code>Set</code> fonctionne car il utilise en sous main en un <code>HashIterator</code> et l'extrait de code suivant montre qu'il avance jusqu'au bon index en incrémentant ce dernier jusqu'à trouver l'objet même si il est rangé dans le mauvais bucket. <code>while (index &lt; t.length &amp;&amp; (next = t[index++]) == null)</code><br />
<br />
Un bug de la JVM semble référencer ce problème&nbsp;: <a href="http://bugs.sun.com/view_bug.do?bug_id=4957674">Hash entries placed into wrong buckets during deserialization</a><br />
Il est ouvert depuis la version 1.4 et même si des commentaires suggèrent des solutions, la correction n'est toujours pas dans nos JVM.</p> <p>Quelles seraient les autres solutions en continuant de s'appuyer sur la sérialisation Java native&nbsp;:</p> <ul> <li>recharger le <code>Set</code> avec un <code>addAll()</code> sur un nouveau <code>HashSet</code> de manière à ranger correctement les objets sur la base des bons hashCode&nbsp;: ce n'est pas propre et c'est difficilement industrialisable.</li> <li>utiliser une <code>ArrayList</code> au lieu d'un <code>HashSet</code> pour peu que l'on n'ait pas besoin de contrôler l'unicité et que l'on soit attentif aux problèmes de produits cartésien sur des fetch de ces collections.</li> <li>faire des manipulations de génie avec les méthodes magiques <code>readObject()</code>, <code>writeObject()</code> ou <code>readResolve()</code> mais c'est très dangereux et déconseillé pour notre cas de recherche de contournement.</li> <li>...&nbsp;?</li> </ul> <h2>Sérialisation alternative</h2> <p>Un rapide test avec la librairie <a href="http://hessian.caucho.com/">Hessian</a> qui fournit une alternative à la sérialisation Java se montre concluant.<br />
Remplaçons la méthode de sérialisation par la méthode suivante&nbsp;:</p> <pre> 	private Child serializeAndUnserializeChild(Child child) throws Exception { 		ByteArrayOutputStream bos = new ByteArrayOutputStream(); 		Hessian2Output out = new Hessian2Output(bos); 		out.startMessage(); 		out.writeObject(child); 		out.completeMessage(); 		out.close(); 		byte []data = bos.toByteArray(); 		ByteArrayInputStream bin = new ByteArrayInputStream(data); 		Hessian2Input in = new Hessian2Input(bin); 		in.startMessage(); 		Child unserializedChild = (Child) in.readObject(); 		in.completeMessage(); 		in.close(); 		bin.close(); 		return unserializedChild; 	} </pre> <p>Le test passe même sans devoir modifier la génération du hashCode. A noter tout de même qu'au premier passage dans la méthode <code>hashCode()</code> de <code>Child</code>, la variable <code>root</code> du child1 est à null tout comme dans la solution initiale à base de sérialisation Java. Ceci est "normal", la JVM initialise la référence circulaire en deux fois. Le child1 est au final bien initialisé avec son membre root.<br /></p> <h2>Conclusion</h2> <p>J'ai rencontré ce problème au cours d'un projet et ai été très surpris de découvrir, a priori, un vieux bug JVM que l'on ne sait pas résoudre proprement ou sans faire de compromis.<br />
Heureusement, d'autres solutions de sérialisation Java existent, elles sont en outre plus performantes mais pas forcément non intrusives. Celle que l'on a vue, à savoir Hessian n'est pas la plus rapide mais présente justement l'avantage de ne pas être intrusive sur les objets à traiter et ne nécessite pas non plus l'écriture de classe de mapping.</p>