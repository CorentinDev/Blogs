---
ID: 429
post_title: >
  Un client Rest pour Android avec
  Spring-Android
author: Guillaume Gerbaud
post_date: 2011-03-16 14:58:00
post_excerpt: |
  <p><a href="http://www.springsource.org/spring-android">Spring Android</a> est une extension du framework Spring qui, comme son nom l'indique, vise à simplifier les développements Android. Plus précisément, il s'agit du "portage" sur Android de certains modules du framework. Âgée de seulement quelques mois, Spring-Android contient pour le moment RestTemplate et CommonsLogging.</p> <p>Dans cet article, je vais présenter RestTemplate dans une application Android minimale qui interroge le service web de Google Maps pour récupérer la liste des adresses correspondant à la requête. <a href="http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/web/client/RestTemplate.html">RestTemplate</a>, pour faire court, facilite le développement d'un client Rest.</p>
layout: post
permalink: http://blog.zenika-offres.com/?p=429
published: true
slide_template:
  - ""
---
<p><a href="http://www.springsource.org/spring-android">Spring Android</a> est une extension du framework Spring qui, comme son nom l'indique, vise à simplifier les développements Android. Plus précisément, il s'agit du "portage" sur Android de certains modules du framework. Âgée de seulement quelques mois, Spring-Android contient pour le moment RestTemplate et CommonsLogging.</p> <p>Dans cet article, je vais présenter RestTemplate dans une application Android minimale qui interroge le service web de Google Maps pour récupérer la liste des adresses correspondant à la requête. <a href="http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/web/client/RestTemplate.html">RestTemplate</a>, pour faire court, facilite le développement d'un client Rest.</p>
<!--more-->
<h2>Configuration</h2> <p><br />
Commençons par installer Spring-Android. J'utilise Maven pour builder mon application, je déclare donc mes dépendances dans mon pom.xml. En plus de Spring-Android, je vais également utiliser Jackson.</p> <pre> &lt;dependency&gt;     &lt;groupId&gt;org.springframework.android&lt;/groupId&gt;     &lt;artifactId&gt;spring-android-rest-template&lt;/artifactId&gt;     &lt;version&gt;1.0.0.M2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; 	&lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt; 	&lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt; 	&lt;version&gt;1.7.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; 	&lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt; 	&lt;artifactId&gt;jackson-core-asl&lt;/artifactId&gt; 	&lt;version&gt;1.7.1&lt;/version&gt; &lt;/dependency&gt; </pre> <h2>UI</h2> <p><br />
La partie UI de l'application (constituée d'une seule Activity) est très simple&nbsp;: un champs d'édition, un bouton et une ListView qui nous permettra d'afficher les résultats. Voici le layout</p> <pre> &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;     android:orientation=&quot;vertical&quot;     android:layout_width=&quot;fill_parent&quot;     android:layout_height=&quot;fill_parent&quot;&gt;     &lt;EditText     	android:id=&quot;@+id/adress&quot;     	android:layout_width=&quot;fill_parent&quot;     	android:layout_height=&quot;wrap_content&quot;/&gt;     &lt;Button     	android:id=&quot;@+id/find&quot;     	android:text=&quot;Find&quot;     	android:layout_width=&quot;fill_parent&quot;     	android:layout_height=&quot;wrap_content&quot;/&gt;     &lt;ListView     	android:id=&quot;@+id/results&quot;     	android:layout_width=&quot;fill_parent&quot;     	android:layout_height=&quot;fill_parent&quot;/&gt; &lt;/LinearLayout&gt; </pre> <p>et la méthode onCreate de l'activity correspondante</p> <pre> @Override public void onCreate(Bundle savedInstanceState) { 	super.onCreate(savedInstanceState); 	setContentView(R.layout.main); 	find = (Button) findViewById(R.id.find); 	address = (EditText) findViewById(R.id.adress); 	listView = (ListView) findViewById(R.id.results); 	adapter = new ArrayAdapter&lt;Address&gt;(getApplicationContext(), android.R.layout.simple_list_item_1); 	listView.setAdapter(adapter); 	find.setOnClickListener(this); } </pre> <h2>Google Geocode</h2> <p><br />
Le service que je vais utiliser est le service <a href="http://code.google.com/intl/fr-FR/apis/maps/documentation/geocoding/" hreflang="fr" title="The Google Geocoding API">geocode de Google</a>. Il s'interroge de la manière suivante: <code>http://maps.googleapis.com/maps/api/geocode/{format}?address={address}&amp;amp;sensor=false</code> avec format à choisir parmi json et xml et address à remplir par notre requête. Voici donc la manière la plus simple d'interroger ce service.</p> <pre> String address = &quot;18 rue de la monnaie&quot;; String url = &quot;http://maps.googleapis.com/maps/api/geocode/json?address={address}&amp;sensor=false&quot;; RestTemplate restTemplate = new RestTemplate(); String result = restTemplate.getForObject(url, String.class, address); </pre> <p>La méthode getForObject prend en paramètres l'url du service, le type de retour - ici j'ai utilisé le type String pour obtenir la réponse Json brute, mais je vais montrer par la suite qu'on peut faire beaucoup plus acceptable - et les paramètres de l'url. Ici je n'avais qu'un seul paramètre mais on peut en mettre autant qu'on veut.</p> <h2>Jackson</h2> <p><br />
Je vais montrer maintenant comment facilement parser le réponse Json pour obtenir un objet représentant le résultat. Notre requête nous retourne une réponse Json au format décrit dans <a href="http://code.google.com/intl/fr-FR/apis/maps/documentation/geocoding/#JSON">ce document</a>. On commence par indiquer à notre RestTemplate le convertisseur à utiliser pour les réponses Json. J'utilise ici le convertisseur Json Jackson.</p> <pre> restTemplate = new RestTemplate(); MappingJacksonHttpMessageConverter jsonConverter = new MappingJacksonHttpMessageConverter(); List&lt;MediaType&gt; supportedMediaTypes = new ArrayList&lt;MediaType&gt;(); supportedMediaTypes.add(MediaType.APPLICATION_JSON); jsonConverter.setSupportedMediaTypes(supportedMediaTypes); List&lt;HttpMessageConverter&lt;?&gt;&gt; listHttpMessageConverters = restTemplate.getMessageConverters(); listHttpMessageConverters.add(jsonConverter); restTemplate.setMessageConverters(listHttpMessageConverters); </pre> <p>On écrit ensuite les classes de mapping.</p> <pre> public static class Addresses { 	public String status; 	public Address[] results; } @JsonIgnoreProperties({&quot;address_components&quot;, &quot;types&quot;, &quot;geometry&quot;, &quot;partial_match&quot;}) public static class Address { 	public String formatted_address; 	@Override 	public String toString() { 		return formatted_address; 	} } </pre> <p>Ce que nous renvoie notre service est donc un objet Addresses constitué d'un statut et d'un tableau d'objets de type Address. Il suffit de nommer les propriétés de la même manière qu'elles sont nommées en Json. Pour les adresses, je ne m’intéresse qu'à leur champ formatted_adress, j'utilise donc l’annotation <code>@JsonIgnoreProperties</code> pour lister toutes les propriétés qui ne m’intéressent pas. J'en profite pour redéfinir toString() en vue de l'affichage ultérieur. Il ne me reste plus qu'à demander à mon RestTemplate de m'obtenir un objet Addresses.</p> <pre> Addresses addresses = restTemplate.getForObject(URL, Addresses.class, address); </pre> <h2>Requête Asynchrone</h2> <p><br />
Il est temps maintenant d’insérer notre RestTemplate dans notre Activity. J'appelle le RestTemplate au clic sur le bouton. Mais pour ne pas figer l'UI, j'ai utilisé une <a href="http://developer.android.com/reference/android/os/AsyncTask.html" title="Tâche asynchrone">AsyncTask</a>.</p> <pre> public void onClick(View view) { 	if(view.getId() == R.id.find){ 		CharSequence csAddress = address.getText(); 		if(!TextUtils.isEmpty(csAddress)){ 			new GetRestTask().execute(csAddress); 		} 	} } private class GetRestTask extends AsyncTask&lt;CharSequence, Void, Addresses&gt; { 	@Override 	protected Addresses doInBackground(CharSequence... address) { 		if(address != null &amp;&amp; address.length &gt; 0) 		{ 			try 			{ 				return getRestTemplate().getForObject(URL, Addresses.class, address[0]); 			} 			catch (RestClientException e) { 				return null; 			} 		} 		return null; 	} 	@Override 	protected void onPostExecute(Addresses addresses) { 		adapter.clear(); 		if(addresses == null || addresses.status.equals(NO_RESULTS)) 		{ 			Toast.makeText(getApplicationContext(), &quot;Non trouvée ou erreur&quot;, Toast.LENGTH_SHORT).show(); 		} 		else 		{ 			Log.d(TAG, &quot;onPostExecute : &quot;+addresses.status); 			for(Address addr : addresses.results) 			{ 				adapter.add(addr); 			} 		} 	} 	private RestTemplate getRestTemplate() { 		if(restTemplate == null) 		{ 			restTemplate = new RestTemplate(); 			[...] 		}                 return restTemplate;        } } </pre> <h2>Résultat</h2> <p><br />
Les sources de l'application sont disponibles sur le <a href="https://github.com/Zenika/Blogs/tree/master/20110316_Client-Rest-avec-Spring-Android">Github de Zenika</a><br /></p> <p><img src="/wp-content/uploads/2015/07/spring-android-device-200x300.png" alt="Spring-Android-Device" style="display:block; margin:0 auto;" title="Spring-Android-Device" /></p>