---
ID: 444
post_title: 'NFC V &#8211; Android Beam et P2P'
author: Guillaume Gerbaud
post_date: 2012-05-09 09:04:00
post_excerpt: |
  <p>Jusqu'à présent, lors de cette série de billets sur le <a href="/index.php?tag/nfc">NFC</a>, je n'ai évoqué que des modes d'utilisation unidirectionnels. Ici, je vais maintenant détailler les possibilités offertes par Android pour les autres modes d'utilisation décrits dans <a href="/index.php?post/2012/03/13/NFC-Nouvelle-Fa%C3%A7on-de-Communiquer">le premier article</a>.</p>
layout: post
permalink: http://blog.zenika-offres.com/?p=444
published: true
slide_template:
  - ""
---
<p>Jusqu'à présent, lors de cette série de billets sur le <a href="/index.php?tag/nfc">NFC</a>, je n'ai évoqué que des modes d'utilisation unidirectionnels. Ici, je vais maintenant détailler les possibilités offertes par Android pour les autres modes d'utilisation décrits dans <a href="/index.php?post/2012/03/13/NFC-Nouvelle-Fa%C3%A7on-de-Communiquer">le premier article</a>.</p>
<!--more-->
<h2>Mode émulation de carte</h2> <p><br />
Je commence par ce mode d'utilisation car, à l'heure actuelle, il n'est pas possible avec Android d'utiliser le NFC en mode Card Emulation. Le mode émulation de carte consiste à utiliser le téléphone comme s'il s'agissait d'une carte à puce. <br /> Par exemple, le téléphone pourrait ainsi remplacer la carte bancaire; c'est le fameux paiement sans contact.<br /></p> <p>Pour fonctionner, l'application émulant la carte doit pouvoir accéder à un élément dit sécurisé (e.g. une carte Sim, une carte mémoire spécifique). Pour le moment, il n'existe aucune API sur Android permettant cet accès. Il existe toutefois <a href="http://code.google.com/p/seek-for-android/" hreflang="en">un projet qui essaye de corriger ce manque</a>.</p> <h2>Mode passif</h2> <p><br />
J’appelle <q>mode passif</q>, le mode dans lequel l'appareil NFC agit comme un Tag. Il ne faut pas confondre ce mode avec le précédent. Dans ce mode, l'appareil NFC n’interagit qu'avec un autre appareil NFC, mais ne nécessite pas d'accès à un élément sécurisé.<br /></p> <p>On peut obtenir un comportement assez proche grâce à la technologie Android Beam™.</p> <h4>Android Beam™</h4> <p>Android Beam permet le push de message Ndef. Ainsi, si un premier appareil Android utilise Beam, lorsqu'un second s'approchera, il détectera le premier comme il détecterait un Tag.</p> <p>Voici comment utiliser Beam.</p> <pre class="java code java" style="font-family:inherit">NfcAdapter nfcAdapter = NfcAdapter.<span style="color: #000000;">getDefaultAdapter</span><span style="color: #000000;">&#40;</span>getApplicationContext<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>; NdefMessage message = ...; &nbsp; nfcAdapter.<span style="color: #000000;">setNdefPushMessage</span><span style="color: #000000;">&#40;</span>message, <span style="color: #7F0055; font-weight: bold;">this</span><span style="color: #000000;">&#41;</span>;</pre> <p>Le deuxième paramètre de la méthode <em>setNdefPushMessage</em> doit être une <code>Activity</code> <q>active</q> (i.e. celle au premier plan, recevant les interactions utilisateur). Il n'est donc pas question de tenter d'utiliser Beam depuis un <code>Service</code> ou un <code>BroadcastReceiver</code>.</p> <p>Le message Ndef n'est envoyé qu'une fois que le téléphone est proche d'un autre. Il peut donc exister un délai plus ou moins long entre la création du message et son envoi. Dans le cas où ce fonctionnement serait problématique, il existe une alternative qui permet de créer le message à la volée, juste avant de l'envoyer.</p> <pre class="java code java" style="font-family:inherit"><span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">class</span> BeamActivity <span style="color: #7F0055; font-weight: bold;">extends</span> Activity <span style="color: #7F0055; font-weight: bold;">implements</span> CreateNdefMessageCallback <span style="color: #000000;">&#123;</span> &nbsp; 	@Override 	<span style="color: #7F0055; font-weight: bold;">protected</span> <span style="color: #7F0055; font-weight: bold;">void</span> onCreate<span style="color: #000000;">&#40;</span>Bundle savedInstanceState<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> 		<span style="color: #7F0055; font-weight: bold;">super</span>.<span style="color: #000000;">onCreate</span><span style="color: #000000;">&#40;</span>savedInstanceState<span style="color: #000000;">&#41;</span>; &nbsp; 		NfcAdapter nfcAdapter = NfcAdapter.<span style="color: #000000;">getDefaultAdapter</span><span style="color: #000000;">&#40;</span>getApplicationContext<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>; &nbsp; 		nfcAdapter.<span style="color: #000000;">setNdefPushMessageCallback</span><span style="color: #000000;">&#40;</span><span style="color: #7F0055; font-weight: bold;">this</span>, <span style="color: #7F0055; font-weight: bold;">this</span><span style="color: #000000;">&#41;</span>; 	<span style="color: #000000;">&#125;</span> &nbsp; 	@Override 	<span style="color: #7F0055; font-weight: bold;">public</span> NdefMessage createNdefMessage<span style="color: #000000;">&#40;</span>NfcEvent event<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> 		NdefMessage message = ...; 		<span style="color: #808080; font-style: italic;">// ...</span> 		<span style="color: #7F0055; font-weight: bold;">return</span> message; 	<span style="color: #000000;">&#125;</span> <span style="color: #000000;">&#125;</span></pre> <p>La méthode <em>setNdefPushMessageCallback</em> prend en premier paramètre un objet de callback qui doit implémenter <code>CreateNdefMessageCallback</code>, et en second une <code>Activity</code>, comme dans le premier exemple. Le <code>NdefMessage</code> est alors crée dans la méthode <em>createNdefMessage</em> qui n'est appelée qu'une fois que les 2 appareils sont proches.</p> <h4>Contraintes</h4> <p>Android Beam permet d'envoyer un message Ndef à un autre appareil Android, et d'être ainsi perçu comme un Tag. Il y a cependant plusieurs limitations à prendre en compte.<br /></p> <p>Tout d'abord, un véritable Tag NFC est alimenté par le champs magnétique produit par le lecteur. Un appareil Android est alimenté par sa batterie. Si l'appareil est éteint, il ne peut être <q>lu</q> par un lecteur.<br /></p> <p>De manière similaire, l'appareil ne peut être en veille, ni sur n'importe quelle application, Beam ne peut être activé qu'à partir d'une <code>Activity</code> au premier plan.</p> <h2>Mode P2P</h2> <p><br />
Le <a href="http://www.nfc-forum.org/specs/spec_list/" hreflang="en">NFC Forum</a> a ajouté une spécification pour réaliser des communications point-à-point car cet usage n'est pas prévu par le RFID. Cette spécification, portant le nom de Simple NDEF Exchange Protocol (SNEP), repose sur le Logical Link Control Protocol (LLCP), lui aussi défini par le NFC Forum.<br /></p> <p>Android Beam utilise le protocole SNEP mais l'Api publique offerte aux développeurs ne permet que le push de message. Il n'est donc pour le moment pas possible d'utiliser le mode P2P du NFC avec Android.<br /></p> <p>De plus, lors de l'utilisation de Beam, l'utilisateur final est contraint de valider, par un appui sur l'écran, l'envoi de chaque message, ce qui ne permet pas de remplacer l'absence de P2P par un grand nombre de push.</p> <h4>Contournement</h4> <p>NFC n'est pas le seul moyen d'établir une connexion point-à-point, c'est également possible, entre autres, en bluetooth ou en <a href="http://developer.android.com/guide/topics/wireless/wifip2p.html" hreflang="en">Wifi Direct</a>. Le NFC peut alors jouer le rôle d'entremetteur pour échanger les moyens supportés et éventuellement les données de configuration.<br /></p> <p>Le NFC Forum a justement publié une spécification appelée Connection Handover qui permet à deux appareils de s'accorder sur la manière d'établir une connexion. Le principe est le suivant&nbsp;:</p> <ul> <li>le premier envoie un message de type Handover Request contenant l'ensemble des technologies d'échange dont il dispose (bluetooth, wifi...) agrémenté éventuellement d'informations de configuration.</li> <li>le second réceptionne ce message, choisit parmi les technologies celle la plus appropriée, puis répond avec un message de type Handover Select, contenant les informations relatives à la technologie choisie.</li> <li>la connexion P2P est alors établie</li> </ul> <p>La spécification prévoit notamment les cas de conflits si les 2 appareils envoient une Handover Request.</p> <p>Bien que les constantes <code>RTD_HANDOVER_REQUEST</code> et <code>RTD_HANDOVER_SELECT</code> existent, cette spécification n'a pas été (encore ?) implémentée dans Android.</p> <h2>Conclusion</h2> <p><br />
L'Api Android dédiée au NFC souffre pour le moment de quelques lacunes pour les modes évolués d'utilisation. Concernant l'émulation de carte, Google semble peu enclin à l'inclure dans le framework (certains diront que la stratégie est de favoriser la solution maison de paiement Google Wallet, d'autres évoqueront un problème matériel). Par contre, Google semble miser davantage sur le P2P, et il est fort à parier de voir apparaître des évolutions du framework dans ce sens.</p>