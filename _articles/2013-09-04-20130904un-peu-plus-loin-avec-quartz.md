---
ID: 137
post_title: Un peu plus loin avec Quartz
author: Gérald Quintana
post_date: 2013-09-04 10:00:00
post_excerpt: |
  <p><a href="http://quartz-scheduler.org/">Quartz</a>, la plupart des développeurs en ont au moins entendu parler: c'est un planificateur de tâches en Java, initié par feu OpenSymphony et aujourd'hui maintenu par Terracotta. Cet article donne quelques astuces d'utilisation, qui pourraient faire suite à la documentation <a href="http://static.springsource.org/spring/docs/current/spring-framework-reference/html/scheduling.html#scheduling-quartz">Spring Scheduling</a>.</p>
layout: post
permalink: http://blog.zenika-offres.com/?p=137
published: true
---
<p><a href="http://quartz-scheduler.org/">Quartz</a>, la plupart des développeurs en ont au moins entendu parler: c'est un planificateur de tâches en Java, initié par feu OpenSymphony et aujourd'hui maintenu par Terracotta. Cet article donne quelques astuces d'utilisation, qui pourraient faire suite à la documentation <a href="http://static.springsource.org/spring/docs/current/spring-framework-reference/html/scheduling.html#scheduling-quartz">Spring Scheduling</a>.</p>
<!--more-->
<h3>Les concepts</h3> <p>Commençons par un bref rappel des concepts Quartz: <img src="/wp-content/uploads/2015/07/Quartz-1.png" alt="Concepts Quartz" style="display:block; margin:0 auto;" title="Concepts Quartz" /></p> <ul> <li><strong>Trigger:</strong> le <em>quand exécuter</em>, ça décrit une ou série de moments, il y a plusieurs variantes: Cron, périodique, one shot...</li> <li><strong>Job:</strong> le <em>quoi exécuter</em>, c'est un bout de code</li> <li><strong>Job Detail:</strong> l'instance de Job, elle a un ou plusieurs triggers et éventuellement des paramètres</li> <li><strong>Job Group:</strong> un ensemble de Job Details ou de Triggers que l'on manipule ensemble: arrêt, démarrage, annulation...</li> <li><strong>Scheduler:</strong> le moteur chargé de la planification et de l'exécution des tâches planifiées</li> </ul> <p>Ces concepts se traduisent en beans Spring:</p> <pre>     &lt;bean id=&quot;mailSimpleTrigger&quot; class=&quot;org.springframework.scheduling.quartz.SimpleTriggerFactoryBean&quot;&gt;         &lt;property name=&quot;jobDetail&quot; ref=&quot;mailJobDetail&quot; /&gt;         &lt;property name=&quot;startDelay&quot; value=&quot;60000&quot; /&gt; &lt;!-- 1 minute après le démarrage --&gt;         &lt;property name=&quot;repeatInterval&quot; value=&quot;360000&quot; /&gt; &lt;!-- puis toutes les heures --&gt;     &lt;/bean&gt;     &lt;bean id=&quot;mailCronTrigger&quot; class=&quot;org.springframework.scheduling.quartz.CronTriggerFactoryBean&quot;&gt;         &lt;property name=&quot;jobDetail&quot; ref=&quot;mailJobDetail&quot; /&gt;         &lt;property name=&quot;cronExpression&quot; value=&quot;0 0 4 * * ?&quot; /&gt; &lt;!-- tous les jours à 4h du matin --&gt;     &lt;/bean&gt;     &lt;bean id=&quot;mailJobDetail&quot; class=&quot;org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean&quot;&gt;         &lt;property name=&quot;targetObject&quot; ref=&quot;mailService&quot; /&gt;         &lt;property name=&quot;targetMethod&quot; value=&quot;envoyerMail&quot; /&gt;     &lt;/bean&gt;     &lt;bean id=&quot;scheduler&quot; class=&quot;org.springframework.scheduling.quartz.SchedulerFactoryBean&quot;&gt;         &lt;property name=&quot;triggers&quot;&gt;&lt;list&gt;             &lt;ref bean=&quot;mailSimpleTrigger&quot; /&gt;             &lt;ref bean=&quot;mailCronTrigger&quot; /&gt;         &lt;/list&gt;&lt;/property&gt;     &lt;/bean&gt; </pre> <p>Cette configuration invoquera la méthode <code>envoyerMail</code> du bean Spring <code>mailService</code> toutes les heures (<code>mailSimpleTrigger</code>) et tous les jours à 4h (<code>mailCronTrigger</code>).</p> <h3>Injection de dépendances (et de paramètres)</h3> <p>Au lieu d'utiliser le <code>MethodInvokingJobDetailFactoryBean</code> Spring comme ci-dessus, on peut créer ses propres classes de Job:</p> <pre>   public class EnvoyerMailJob implements Job {        private MailService mailService;        private int idVol;        // Getters + Setters        public void execute(JobExecutionContext context) {            Date date=context.getScheduledFireTime();            mailService.envoyerMail(date, idVol);        }    }</pre> <p>On le déclare dans la configuration Spring comme auparavant:</p> <pre>   &lt;bean id="envoyerMailJob" class="org.springframework.scheduling.quartz.JobDetailBean"&gt;        &lt;property name="jobClass" value="com.mycompany.test.quartz.EnvoyerMailJob"/&gt;        &lt;property name="jobDataAsMap"&gt;&lt;map&gt;            &lt;entry key="idJob" value="456" /&gt;        &lt;/map&gt;&lt;/property&gt;    &lt;/bean&gt;</pre> <p>Au moment voulu, Quartz va instancier cette classe <code>EnvoyerMailJob</code> et invoquer la méthode <code>execute</code>. Pour que l'injection de dépendances Spring s'applique à cet objet (en particulier <code>mailService</code>), il y a plusieurs stratégies:</p> <ul> <li>Utiliser AspectJ et la modification de bytecode,</li> <li>Faire hériter le Job de la classe <code>QuartzJobBean</code>,</li> <li>Remplacer la <code>JobFactory</code> que Quartz utilise pour instancier les Jobs.</li> </ul> <p>C'est cette dernière stratégie que nous allons utiliser, il faut ajouter dans la configuration du Scheduler:</p> <ul> <li>la propriété <code>jobFactory</code> recevra un <code>SpringBeanJobFactory</code>. Cette implémentation de <code>JobFactory</code> injecte dans le Job les paramètres du Job ainsi que le beans présents dans le contexte du scheduler.</li> <li>la propriété <code>schedulerContextAsMap</code> ajoutera des beans Spring dans le contexte du scheduler.</li> </ul> <pre>   &lt;bean id="scheduler" class="org.springframework.scheduling.quartz.SchedulerFactoryBean"&gt;        &lt;property name="jobFactory"&gt;            &lt;bean class="org.springframework.scheduling.quartz.SpringBeanJobFactory"/&gt;        &lt;/property&gt;        &lt;property name="schedulerContextAsMap"&gt;&lt;map&gt;            &lt;entry key="mailService" value-ref="mailService"/&gt;        &lt;/map&gt;&lt;/property&gt;    &lt;/bean&gt;</pre> <p>Il est possible d'étendre la <code>SpringBeanJobFactory</code> comme cela est fait <a href="https://gist.github.com/jelies/5085593" title="Gist">ici</a>, pour qu'elle injecte directement les beans du contexte Spring, on s'évite ainsi de remplir le contexte du scheduler. La documentation Spring fait allusion à la classe <code>QuartzJobBean</code>, avec Quartz&lt;1.5 le concept de JobFactory n'existait pas, procéder par héritage était alors l'unique solution. Mais aujourd'hui la <code>SpringBeanJobFactory</code> est un moyen bien plus élégant de faire la même chose. Il faut toutefois noter que les instances de Job utilisées à l'exécution (comme <code>EnvoyerMailJob</code>) ne sont pas des beans Spring à part entière: leur cycle de vie n'est pas géré par la <code>BeanFactory</code> Spring et l'AOP ne s'applique pas dessus.</p> <h3>Persistance des Jobs</h3> <p>On ne souhaite pas que la définition des Jobs soit figée dans la configuration Spring, et on veut pouvoir en ajouter de nouveaux à l'exécution. Par exemple, on souhaite envoyer un mail de rappel à tous les clients qui ont réservé une place sur un des vols de notre compagnie, 4h avant l'embarquement. A chaque création de vol, il faut ajouter une nouvelle tâche planifiée dont l'heure dépend de celle du vol. Ce genre de cas d'utilisation est très fréquent dans les workflows où il faut rappeler à l'utilisateur la deadline d'une tâche qui lui incombe ou bien passer la tâche dans un nouvel état (expiration).</p> <p>Quartz abstrait le stockage des Jobs dans le concept de JobStore: il existe un RAM JobStore pour les stocker en mémoire, un JDBC JobStore pour les stocker dans une base de données via JDBC, et un Terracotta JobStore pour les stocker dans un cluster du même nom. Nous opterons pour du JDBC car c'est simple à mettre en oeuvre et ultra classique. Dans une base de données relationnelle, on va donc créer un jeu de tables Quartz; des exemples de scripts SQL de création figurent dans le dossier <code>docsdbTables</code> de l'archive <a href="http://terracotta.org/downloads/open-source/destination?name=quartz-2.2.0-distribution.tar.gz&amp;bucket=tcdistributions&amp;file=quartz-2.2.0-distribution.tar.gz">quartz-2.2.0-distribution.tar.gz</a>. Puis on déclare une DataSource de manière habituelle et on l'injecte dans la <code>SchedulerFactory</code>:</p> <pre>   &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;        ...    &lt;/bean&gt;    &lt;bean id="scheduler" class="org.springframework.scheduling.quartz.SchedulerFactoryBean"&gt;        &lt;property name="dataSource" ref="dataSource"/&gt;        &lt;property name="quartzProperties"&gt;&lt;props&gt;            &lt;prop key="org.quartz.jobStore.driverDelegateClass"&gt;org.quartz.impl.jdbcjobstore.PostgreSQLDelegate&lt;/prop&gt;            &lt;prop key="org.quartz.jobStore.tablePrefix"&gt;QUARTZ_&lt;/prop&gt;        &lt;/property&gt;    &lt;/bean&gt;</pre> <p>Il est inutile de configurer soi-même le type de JobStore, Spring s'en charge et positionne une variante à lui du
 JDBC JobStore, le <a href="http://static.springsource.org/spring-framework/docs/current/javadoc-api/org/springframework/scheduling/quartz/LocalDataSourceJobStore.html">LocalDataSourceJobStore</a>. On peut éventuellement configurer le "dialecte" SQL utilisé  (appelé DriverDelegate) ainsi que le préfixe des noms de tables. Le cas échéant, le <code>StdJDBCDelegate</code> s'applique automatiquement et suffit généralement.</p> <p>Pour planifier un Job dynamiquement, on ne peut pas utiliser le <code>MethodInvokingJobDetailFactoryBean</code> car il n'est pas persistable, il faut impérativement passer par des classes de Job spécifiques. On peut à présent planifier le Job programmatiquement:</p> <pre>   public void planifierEnvoiMail(int idVol, Date date) throws SchedulerException {        JobDetail jobDetail = JobBuilder.newJob(EnvoyerMailJob.class)                .withIdentity("EnvoiMailJob#"+idVol, "EnvoiMailJobs")                .usingJobData("idVol", idVol)                .build();        Trigger trigger = TriggerBuilder.newTrigger()                .withIdentity("EnvoiMailTrig#"+idVol, "EnvoiMailTrigs")                .forJob(jobDetail)                .startAt(date)                .build();        quartzScheduler.scheduleJob(jobDetail, trigger);    }</pre> <h3>Transactions</h3> <p>Aussitôt une base de données mise en place, se pose la question des transactions. Avec Quartz, elles interviennent à plusieurs moments:</p> <ul> <li>La planification et le contrôle (pause/reprise) d'un Job: la création d'un nouveau vol s'accompagne de la planification d'un nouvel envoi de mail, les deux doivent rester cohérents.</li> <li>L'exécution d'un Job: le code métier contenu dans le Job lui-même peut être transactionnel</li> <li>La surveillance et la mise à jour du Job: le scheduler va surveiller les Jobs a exécuter. puis modifier l'état du Job avant et après son exécution. Ces accès doivent être faits dans des transactions séparées de l'exécution.</li> </ul> <h2>Planification et contrôle d'un Job</h2> <p>A ce niveau, Spring est maître de la démarcation transactionnelle.</p> <p>Si on procède de manière impérative, il faudra juste s'assurer que le service métier correspondant est transactionnel. On ajoutera par exemple <code>@Transactional</code> sur la méthode <code>planifierEnvoiMail</code> dans l'exemple ci-dessus. Si on procède de manière déclarative, il faudra injecter le transaction manager au <code>SchedulerFactoryBean</code>:</p> <pre>   &lt;bean id="quartzScheduler" class="org.springframework.scheduling.quartz.SchedulerFactoryBean"&gt;        &lt;property name="dataSource" ref="dataSource"/&gt;        &lt;property name="transactionManager" ref="transactionManager"/&gt;        &lt;property name="triggers"&gt;            ...        &lt;/property&gt;    &lt;/bean&gt;</pre> <p>Attention, la propriété <code>transactionManager</code> est seulement utilisée par Spring pour planifier les Jobs au démarrage. A l'exécution, Quartz ne sait pas s'appuyer sur le <a href="http://static.springsource.org/spring/docs/current/javadoc-api/org/springframework/transaction/PlatformTransactionManager.html">PlatformTransactionManager</a>.</p> <h2>Exécution d'un Job</h2> <p>Pour rendre l'exécution d'un Job transactionnel, il y a deux stratégies:</p> <ul> <li>soit Quartz gère la transaction: l'utilisation de JTA et d'un transaction manager XA sont alors nécessaires,</li> <li>soit Spring gère la transaction: le Job lui même ne sera pas transactionnel, mais en déléguant à un bean Spring tout le traitement, le résultat sera le même.</li> </ul> <p>Pour amener Quartz à envelopper l'exécution d'un Job dans une transaction JTA, il faut juste activer une propriété:</p> <pre>   &lt;bean id="quartzScheduler" class="org.springframework.scheduling.quartz.SchedulerFactoryBean"&gt;        &lt;property name="quartzProperties"&gt;&lt;props&gt;            &lt;prop key="org.quartz.scheduler.wrapJobExecutionInUserTransaction"&gt;true&lt;/prop&gt;            ...        &lt;/props&gt;&lt;/property&gt;    &lt;/bean&gt;</pre> <p>ou bien mettre une annotation <code>@ExecuteInJTATransaction</code> sur le Job.</p> <h2>Surveillance et mise à jour de l'état d'un Job</h2> <p>Ici Quartz est forcément maître de la transaction. Quelque soit la configuration, il ne se sert pas d'une transaction JTA, il va piloter la transaction au niveau JDBC comme le <a href="http://static.springsource.org/spring/docs/current/javadoc-api/org/springframework/jdbc/datasource/DataSourceTransactionManager.html">DataSourceTransactionManager</a> de Spring. Bref, il lui faut une DataSource non XA.</p> <pre>   &lt;bean id="quartzScheduler" class="org.springframework.scheduling.quartz.SchedulerFactoryBean"&gt;        &lt;property name="dataSource" ref="xaDataSource"/&gt;        &lt;property name="nonTransactionalDataSource" ref="nonXaDataSource"/&gt;        ...    &lt;/bean&gt;</pre> <p>Dans la configuration du <code>SchedulerFactoryBean</code>, on peut injecter deux DataSources:</p> <ul> <li><code>dataSource</code> est utilisée lors de la planification des Jobs, elle peut être XA ou pas, elle est obligatoire. Quartz ne s'occupe pas des transactions dessus, il faut le faire en amont avec Spring, au choix en JTA ou en JDBC.</li> <li><code>nonTransactionalDataSource</code> est utilisée pour surveiller et mettre à jour les Jobs lors de leur exécution, elle est forcément non XA, elle est optionnelle. Quartz l'utilise avec des transactions JDBC. Dans la documentation Quartz, elle est baptisée <code>nonManagedTXDataSource</code>, c'est un peut-être choix plus judicieux car il y a bien des transactions!</li> </ul> <p>Certaines implémentations de JTA autorisent l'utilisation d'une DataSource XA en dehors de toute transaction, on peut alors faire pointer <code>dataSource</code> et <code>nonTransactionalDataSource</code> sur une même DataSource XA.</p> <h3>Clustering</h3> <p>Afin de garantir la haute-disponibilité de notre solution, mais aussi permettre la scalabilité horizontale, on souhaite pouvoir distribuer le scheduler. Si on instancie naïvement le scheduler sur chacun des nœuds du cluster, chacun d'eux va exécuter au même instant le même Job. Or ce n'est pas notre besoin, nous voulons qu'un (et un seul) nœud du cluster prenne en charge un Job donné.</p> <p>La solution réside ici aussi dans le JobStore décrit ci-dessus, qui permet à un scheduler donné de poser un verrou sur un Job au moment de l'exécuter, et signaler ainsi aux autre membres du cluster qu'il se charge du traitement. Il faut juste configurer Quartz pour lui signaler qu'il s'agit d'un cluster:</p> <pre>     &lt;bean id=&quot;quartzScheduler&quot; class=&quot;org.springframework.scheduling.quartz.SchedulerFactoryBean&quot;&gt;         &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;!-- JDBC JobStore --&gt;         &lt;property name=&quot;schedulerName&quot; value=&quot;ZenQuartz&quot;/&gt;         &lt;property name=&quot;quartzProperties&quot;&gt;&lt;props&gt;             &lt;prop key=&quot;org.quartz.scheduler.instanceId&quot;&gt;AUTO&lt;/prop&gt;             &lt;prop key=&quot;org.quartz.jobStore.isClustered&quot;&gt;true&lt;/prop&gt;             ...         &lt;/props&gt;&lt;/property&gt;     &lt;/bean&gt; </pre> <p>La propriété <code>org.quartz.scheduler.instanceId=AUTO</code> permet d'affecter un identifiant unique à chacune des instances de scheduler pour qu'elles puissent s'identifier et se différencier au sein du cluster. Si un noeud tombe, les autres prennent la relève pour l'exécution des Jobs, rien d'extraordinaire étant donné que leur définition est partagée via la base de données.</p> <p>Évidemment, cette solution ne peut fonctionner que si tous les serveurs sont synchronisés sur une horloge commune (NTP) et pointent vers une même base de données (JDBC JobStore).</p> <p>La planification des Jobs de manière déclarative depuis la configuration Spring, c'est à dire en utilisant la propriété <code>triggers</code>, n'est plus possible. En effet, lorsque chacun des nœuds va démarrer, Spring va créer le scheduler et planifier
les Jobs. Si plusieurs nœuds démarrent en parallèle, des erreurs <a href="http://quartz-scheduler.org/api/2.2.0/org/quartz/ObjectAlreadyExistsException.html">ObjectAlreadyExistsException</a> vont survenir pour signaler la duplication des Jobs/Triggers. Une solution est de faire la planification soi-même de manière impérative pour traiter ce cas d'erreur, et éventuellement utiliser <a href="http://quartz-scheduler.org/api/2.0.0/org/quartz/core/QuartzScheduler.html#scheduleJobs%28java.util.Map,%20boolean%29">QuartzScheduler#scheduleJobs</a> avec le paramètre <code>replace</code>.</p> <h3>Threads</h3> <p>Le scheduler Quartz utilise un thread pour lui, plus N threads pour l'exécution des Jobs. Configurer le nom des threads et la taille du pool de threads de Jobs est un must</p> <pre>   &lt;bean id="quartzTaskExecutor" class="org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor"&gt;        &lt;property name="corePoolSize" value="4"/&gt;        &lt;property name="maxPoolSize" value="5"/&gt;        &lt;property name="waitForTasksToCompleteOnShutdown" value="true"/&gt;        &lt;property name="threadGroupName" value="ZenQuartzJobs"/&gt;        &lt;property name="threadNamePrefix" value="ZenQuartzJob" /&gt;    &lt;/bean&gt;    &lt;bean id="quartzScheduler" class="org.springframework.scheduling.quartz.SchedulerFactoryBean"&gt;        &lt;property name="taskExecutor" ref="quartzTaskExecutor"/&gt;        &lt;property name="quartzProperties"&gt;&lt;props&gt;            &lt;prop key="org.quartz.scheduler.threadName"&gt;ZenQuartzScheduler&lt;/prop&gt;        &lt;/props&gt;&lt;/property&gt;    &lt;/bean&gt;</pre> <p><code>quartzTaskExecutor</code> est un pool de threads pour les Jobs tandis que <code>org.quartz.scheduler.threadName</code> correspond au thread principal de Quartz.</p> <h3>Monitoring</h3> <p>Une fois le scheduler en production, le surveiller voire le piloter est un besoin simple mais évident.</p> <p>Deux propriétés suffisent à exposer Quartz via JMX:</p> <pre>   &lt;bean id="quartzScheduler" class="org.springframework.scheduling.quartz.SchedulerFactoryBean"&gt;        &lt;property name="quartzProperties"&gt;&lt;props&gt;            &lt;prop key="org.quartz.scheduler.jmx.export"&gt;true&lt;/prop&gt;            &lt;prop key="org.quartz.scheduler.jmx.objectName"&gt;com.zenika.flight:name=QuartzScheduler&lt;/prop&gt;        &lt;/props&gt;&lt;/property&gt;    &lt;/bean&gt;</pre> <p><img src="/wp-content/uploads/2015/07/.Quartz-2_m.jpg" alt="Console JMX" style="display:block; margin:0 auto;" title="Console JMX Quartz" /></p> <p>La console JMX affiche l'état et la configuration du scheduler, les Jobs et les Triggers. Des opérations permettent de mettre en pause ou de supprimer des Jobs et des Triggers.</p> <p>Pour ceux qui préfère le confort d'une console Web, il en existe <a href="http://code.google.com/p/jwatch/">JWatch</a> et <a href="http://code.google.com/p/myschedule/">MySchedule</a> en open-source, et <a href="http://www.quartzdesk.com/">QuartzDesk</a> en commercial.</p> <h3>Conclusion</h3> <p>Quartz est un outil puissant et très configurable, cette richesse se fait parfois un peu au détriment de la clarté. Pour les besoins simples, le scheduler Spring suffit: une annotation <code>@Scheduled</code> et le tour est joué. Pour les besoins plus élaborés (persistance, clustering, monitoring, etc.), Quartz devient nécessaire.</p>