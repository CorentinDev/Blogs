---
ID: 445
post_title: Editor Framework avec GWT
author: jvey
post_date: 2012-06-06 09:30:00
post_excerpt: '<p>Depuis la version 2.0 de GWT, de nombreuses fonctionnalités sont apparues, <a href="https://developers.google.com/web-toolkit/doc/latest/DevGuideMvpActivitiesAndPlaces">Activities &amp; Places</a>, <a href="https://developers.google.com/web-toolkit/doc/latest/DevGuideRequestFactory">RequestFactory</a>, <a href="https://developers.google.com/web-toolkit/doc/latest/DevGuideUiBinder">UiBinder</a>, <a href="https://developers.google.com/web-toolkit/doc/latest/DevGuideCodeSplitting">CodeSplitting</a>...</p> <p>Après avoir vu dans un précédent article différentes solutions permettant de faire transiter des beans hibernate entre le client et le serveur, notamment avec <a href="/index.php?post/2012/03/08/GWT-Hibernate-et-les-RequestFactory">l’utilisation de RequestFactory</a>, nous allons aujourd’hui nous intéresser à un autre aspect du développement GWT, le data binding entre nos objets métiers ou DTO(Data Transfer Object) et notre interface graphique.</p> <p>Pour cela GWT fournit le <a href="https://developers.google.com/web-toolkit/doc/latest/DevGuideUiEditors">framework Editor</a>, qui a pour but d’éviter d’avoir à écrire plein de "boilerplate code" en simplifiant ce binding. Je vais donc vous présenter comment, en partant d’une application utilisant un binding classique (à base de getter et setter) mettre en place les Editor et ainsi faciliter le développement et limiter le risque d’erreur.</p>'
layout: post
permalink: http://blog.zenika-offres.com/?p=445
published: true
slide_template:
  - ""
---
<p>Depuis la version 2.0 de GWT, de nombreuses fonctionnalités sont apparues, <a href="https://developers.google.com/web-toolkit/doc/latest/DevGuideMvpActivitiesAndPlaces">Activities &amp; Places</a>, <a href="https://developers.google.com/web-toolkit/doc/latest/DevGuideRequestFactory">RequestFactory</a>, <a href="https://developers.google.com/web-toolkit/doc/latest/DevGuideUiBinder">UiBinder</a>, <a href="https://developers.google.com/web-toolkit/doc/latest/DevGuideCodeSplitting">CodeSplitting</a>...</p> <p>Après avoir vu dans un précédent article différentes solutions permettant de faire transiter des beans hibernate entre le client et le serveur, notamment avec <a href="/index.php?post/2012/03/08/GWT-Hibernate-et-les-RequestFactory">l’utilisation de RequestFactory</a>, nous allons aujourd’hui nous intéresser à un autre aspect du développement GWT, le data binding entre nos objets métiers ou DTO(Data Transfer Object) et notre interface graphique.</p> <p>Pour cela GWT fournit le <a href="https://developers.google.com/web-toolkit/doc/latest/DevGuideUiEditors">framework Editor</a>, qui a pour but d’éviter d’avoir à écrire plein de "boilerplate code" en simplifiant ce binding. Je vais donc vous présenter comment, en partant d’une application utilisant un binding classique (à base de getter et setter) mettre en place les Editor et ainsi faciliter le développement et limiter le risque d’erreur.</p>
<!--more-->
<p>Toutes les sources de ce billet sont disponibles sur <a href="https://github.com/julienvey/BlogGWTEditor">Github</a>. Les différentes étapes ont été taguées et sont indiquées à chaque fois.</p> <h3>L’application initiale <br /></h3> <blockquote><p>(tag git&nbsp;: init-state)<br /></p></blockquote> <p>Pour mettre en avant l’utilisation des Editor, j’ai décidé de partir d’une application simple, un formulaire affichant des informations signalétiques d’une personne. Cette personne ayant été récupérée depuis le serveur via un simple appel RPC. Voici une capture d'écran du formulaire que l'on souhaite remplir. <img src="/wp-content/uploads/2015/07/CaptureEditor.png" alt="Formulaire Editor" style="display:block; margin:0 auto;" title="Formulaire Editor" /></p> <h2>L’organisation du code<br /></h2> <p><br />
<img src="/wp-content/uploads/2015/07/screen1.png" alt="Organisation du code" style="display:block; margin:0 auto;" title="Organisation du code" /></p> <p>Pour ceux qui ne sont pas familiers avec GWT, les trois classes et interfaces <em>PersonService</em>, <em>PersonServiceImpl</em> et <em>PersonServiceAsync</em> correspondent au service RPC (Remote Procedure Call) permettant la communication client/serveur.</p> <p>Les objets <em>ListItem</em> et <em>TextItem</em> sont une simple composition d’un label et d’un input (<em>ListBox</em> pour le premier et <em>TextBox</em> pour le second). Ils nous seront utiles plus tard dans la démonstration.</p> <p>Les objets <em>Person</em> et <em>Address</em>, dont voici le code en dessous, sont les DTO que nous allons devoir mapper dans notre formulaire. Celui-ci va être mis en place dans les vues <em>PersonView</em> et <em>AddressView</em></p> <pre class="java code java" style="font-family:inherit"><span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">class</span> Person <span style="color: #7F0055; font-weight: bold;">implements</span> <span style="color: #000000;">Serializable</span> <span style="color: #000000;">&#123;</span>     <span style="color: #7F0055; font-weight: bold;">private</span> <span style="color: #000000;">String</span> firstName;     <span style="color: #7F0055; font-weight: bold;">private</span> <span style="color: #000000;">String</span> lastName;     <span style="color: #7F0055; font-weight: bold;">private</span> <span style="color: #000000;">String</span> phoneNumber;     <span style="color: #7F0055; font-weight: bold;">private</span> Address address;     <span style="color: #7F0055; font-weight: bold;">private</span> <span style="color: #000000;">String</span> company;     ... <span style="color: #000000;">&#125;</span></pre> <pre class="java code java" style="font-family:inherit"><span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">class</span> Address <span style="color: #7F0055; font-weight: bold;">implements</span> <span style="color: #000000;">Serializable</span> <span style="color: #000000;">&#123;</span>     <span style="color: #7F0055; font-weight: bold;">private</span> <span style="color: #000000;">String</span> street;     <span style="color: #7F0055; font-weight: bold;">private</span> <span style="color: #000000;">String</span> zipCode;     <span style="color: #7F0055; font-weight: bold;">private</span> <span style="color: #000000;">String</span> city;     <span style="color: #7F0055; font-weight: bold;">private</span> <span style="color: #000000;">String</span> country;     ... <span style="color: #000000;">&#125;</span></pre> <h2>Mise en place du binding</h2> <p>Première chose à faire, récupérer notre objet métier côté serveur, dans ce cas un objet <em>Person</em>, via le service RPC mentionné précedemment.</p> <pre class="java code java" style="font-family:inherit">personService.<span style="color: #000000;">getPerson</span><span style="color: #000000;">&#40;</span><span style="color: #7F0055; font-weight: bold;">new</span> AsyncCallback<span style="color: #000000;">&lt;</span>Person<span style="color: #000000;">&gt;</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>                     @Override                     <span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">void</span> onSuccess<span style="color: #000000;">&#40;</span><span style="color: #7F0055; font-weight: bold;">final</span> Person result<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>                         setData<span style="color: #000000;">&#40;</span>result<span style="color: #000000;">&#41;</span>;                     <span style="color: #000000;">&#125;</span> &nbsp;                     @Override                     <span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">void</span> onFailure<span style="color: #000000;">&#40;</span><span style="color: #7F0055; font-weight: bold;">final</span> <span style="color: #000000;">Throwable</span> caught<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>                         <span style="color: #000000;">Window</span>.<span style="color: #000000;">alert</span><span style="color: #000000;">&#40;</span><span style="color: #888888;">&quot;Call failed&quot;</span><span style="color: #000000;">&#41;</span>;                     <span style="color: #000000;">&#125;</span>                 <span style="color: #000000;">&#125;</span><span style="color: #000000;">&#41;</span>;</pre> <p>Après avoir récupéré notre objet, nous appelons la méthode <em>setData()</em> sur la vue <em>PersonView</em> et en cascade sur la vue <em>AddressView</em>. Dans le code suivant, les objets sur lesquels nous appelons la méthode <em>setValue</em> sont des éléments graphiques de l'application GWT.</p> <pre class="java code java" style="font-family:inherit"><span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">void</span> setData<span style="color: #000000;">&#40;</span><span style="color: #7F0055; font-weight: bold;">final</span> Person result<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>     firstName.<span style="color: #000000;">setValue</span><span style="color: #000000;">&#40;</span>result.<span style="color: #000000;">getFirstName</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;     lastName.<span style="color: #000000;">setValue</span><span style="color: #000000;">&#40;</span>result.<span style="color: #000000;">getLastName</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;     phoneNumber.<span style="color: #000000;">setValue</span><span style="color: #000000;">&#40;</span>result.<span style="color: #000000;">getPhoneNumber</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;     company.<span style="color: #000000;">setValue</span><span style="color: #000000;">&#40;</span>result.<span style="color: #000000;">getCompany</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;     address.<span style="color: #000000;">setData</span><span style="color: #000000;">&#40;</span>result.<span style="color: #000000;">getAddress</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;  <span style="color: #000000;">&#125;</span></pre> <pre class="java code java" style="font-family:inherit"><span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">void</span> setData<span style="color: #000000;">&#40;</span><span style="color: #7F0055; font-weight: bold;">final</span> Address address<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>     street.<span style="color: #000000;">setValue</span><span style="color: #000000;">&#40;</span>address.<span style="color: #000000;">getStreet</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;     zipCode.<span style="color: #000000;">setValue</span><span style="color: #000000;">&#40;</span>address.<span style="color: #000000;">getZipCode</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;     city.<span style="color: #000000;">setValue</span><span style="color: #000000;">&#40;</span>address.<span style="color: #000000;">getCity</span><span style="color: #000000;">&#40;</span><span style="color: #0
00000;">&#41;</span><span style="color: #000000;">&#41;</span>;     country.<span style="color: #000000;">setValue</span><span style="color: #000000;">&#40;</span>address.<span style="color: #000000;">getCountry</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;  <span style="color: #000000;">&#125;</span></pre> <p>Notre formulaire est ainsi rempli. Après avoir modifié les valeurs de ces champs, il faut maintenant faire le mapping inverse, créer un objet Person rempli avec les valeurs de chaque champ du formulaire et envoyer cet objet au service. De la même façon que précedemment, on appelle la méthode getData() sur la vue PersonView.</p> <pre class="java code java" style="font-family:inherit">personService.<span style="color: #000000;">setPerson</span><span style="color: #000000;">&#40;</span>personView.<span style="color: #000000;">getData</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>, <span style="color: #7F0055; font-weight: bold;">new</span> AsyncCallback<span style="color: #000000;">&lt;</span>Void<span style="color: #000000;">&gt;</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> ... <span style="color: #000000;">&#125;</span></pre> <pre class="java code java" style="font-family:inherit"><span style="color: #7F0055; font-weight: bold;">public</span> Person getData<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>     Person person = <span style="color: #7F0055; font-weight: bold;">new</span> Person<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;     person.<span style="color: #000000;">setAddress</span><span style="color: #000000;">&#40;</span>address.<span style="color: #000000;">getData</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;     person.<span style="color: #000000;">setFirstName</span><span style="color: #000000;">&#40;</span>firstName.<span style="color: #000000;">getValue</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;     person.<span style="color: #000000;">setLastName</span><span style="color: #000000;">&#40;</span>lastName.<span style="color: #000000;">getValue</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;     person.<span style="color: #000000;">setPhoneNumber</span><span style="color: #000000;">&#40;</span>phoneNumber.<span style="color: #000000;">getValue</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;     person.<span style="color: #000000;">setCompany</span><span style="color: #000000;">&#40;</span>company.<span style="color: #000000;">getValue</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;     <span style="color: #7F0055; font-weight: bold;">return</span> person;  <span style="color: #000000;">&#125;</span></pre> <pre class="java code java" style="font-family:inherit"><span style="color: #7F0055; font-weight: bold;">public</span> Address getData<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>     Address address = <span style="color: #7F0055; font-weight: bold;">new</span> Address<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;     address.<span style="color: #000000;">setCity</span><span style="color: #000000;">&#40;</span>city.<span style="color: #000000;">getValue</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;     address.<span style="color: #000000;">setCountry</span><span style="color: #000000;">&#40;</span>country.<span style="color: #000000;">getValue</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;     address.<span style="color: #000000;">setStreet</span><span style="color: #000000;">&#40;</span>street.<span style="color: #000000;">getValue</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;     address.<span style="color: #000000;">setZipCode</span><span style="color: #000000;">&#40;</span>zipCode.<span style="color: #000000;">getValue</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;     <span style="color: #7F0055; font-weight: bold;">return</span> address;  <span style="color: #000000;">&#125;</span></pre> <p>Nous nous rendons bien compte avec cet exemple très simple que le coût de développement, le risque d'erreur ainsi que le coût de maintenance sont tous trois élevés. C'est à cet instant qu'intervient le framework Editor.</p> <h3>Mise en place du framework Editor<br /></h3> <blockquote><p>(tag git&nbsp;: state1)<br /></p></blockquote> <h2>Définition des termes</h2> <p>Avant de montrer comment mettre en place ce framework sur une application GWT, une explication des différents termes utilisés s’impose.<br /></p> <ul> <li>Bean&nbsp;: l’objet métier ou le DTO qui va servir au binding<br /></li> <li>Editor&nbsp;: l’objet sur lequel vont être mappés les attributs du Bean. Les editors sont en général des widgets GWT ou une composition de widgets.<br /></li> <li>Driver&nbsp;: il s’agit du contrôleur qui va gérer le mapping entre le bean et l’editor. Il va le faire les liens entre les attributs du bean et les valeurs des widgets de l’editor<br /></li> </ul> <h2>Mise en place</h2> <p><br /></p> <blockquote><p>Contrairement à ce qui est indiqué dans la documentation officielle, il n'est pas nécessaire d'importer le module Editor dans la configuration du projet, car celui-ci est désormais inclus dans le module <em>com.google.gwt.user.User</em></p></blockquote> <p>Tout d’abord, il faut déclarer une interface qui va étendre <em>SimpleBeanEditorDriver</em> (pour les habitués de GWT, le principe ici est le même que pour les interfaces de type <em>ClientBundle</em>)</p> <pre class="java code java" style="font-family:inherit"><span style="color: #7F0055; font-weight: bold;">interface</span> EditorDriver <span style="color: #7F0055; font-weight: bold;">extends</span> SimpleBeanEditorDriver<span style="color: #000000;">&lt;</span>Person, PersonView<span style="color: #000000;">&gt;</span> <span style="color: #000000;">&#123;</span> <span style="color: #000000;">&#125;</span></pre> <p>Puis créer une implémentation via la méthode <em>GWT.create()</em></p> <pre class="java code java" style="font-family:inherit">EditorDriver editorDriver = GWT.<span style="color: #000000;">create</span><span style="color: #000000;">&#40;</span>EditorDriver.<span style="color: #7F0055; font-weight: bold;">class</span><span style="color: #000000;">&#41;</span>;</pre> <p>Nous venons donc de créer le <em>Driver</em>. Nous avions déjà le bean (récupéré depuis le serveur). Il nous manque donc l’<em>Editor</em>, l’objet graphique qui va accueillir les attributs du bean.</p> <p>Il faut s’imaginer la hiérarchie des widgets <em>Editor</em> comme une arborescence . L’<em>Editor</em> <em>PersonView</em> est un noeud qui contient différentes feuilles, les <em>ListItem</em> et <em>TextItem</em>, ainsi que d’autres noeuds, ici <em>AddressView</em>, qui lui-même contient de la même façon d’autres feuilles.</p> <p>Nous allons donc transformer nos vues <em>PersonView</em> et <em>AddressView</em> en Editor. Il va également falloir transformer nos widgets <em>TextItem</em> et <em>ListItem</em>, ce que nous verrons juste après.</p> <pre class="java code java" style="font-family:inherit"
><span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">class</span> PersonView <span style="color: #7F0055; font-weight: bold;">extends</span> <span style="color: #000000;">Composite</span> <span style="color: #7F0055; font-weight: bold;">implements</span> Editor<span style="color: #000000;">&lt;</span>Person<span style="color: #000000;">&gt;</span> <span style="color: #000000;">&#123;</span> ... <span style="color: #000000;">&#125;</span></pre> <pre class="java code java" style="font-family:inherit"><span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">class</span> AddressView <span style="color: #7F0055; font-weight: bold;">extends</span> <span style="color: #000000;">Composite</span> <span style="color: #7F0055; font-weight: bold;">implements</span> Editor<span style="color: #000000;">&lt;</span>Address<span style="color: #000000;">&gt;</span> <span style="color: #000000;">&#123;</span> ... <span style="color: #000000;">&#125;</span></pre> <p>PersonView implémente <em>Editor</em> typé avec l'objet <em>Person</em>. Cela siginifie que <em>PersonView</em> permet le mapping des attributs de l’objet <em>Person</em>. <em>AddressView</em>, de la même façon, va permettre de mapper les attributs de l’objet <em>Address</em>.</p> <blockquote><p>Attention, il y a certaines règles de nommage à respecter afin que le driver sache quels attributs mapper sur quels widgets. Ces règles sont détaillées dans <a href="https://developers.google.com/web-toolkit/doc/latest/DevGuideUiEditors#Editor_contract">la documentation de GWT</a>. Si l'on ne souhaite pas suivre ces règles, il est possible de les surcharger avec l'annotation <em>@Path</em> qui prend en paramètre le "chemin de l'attribut" (par exemple <em>@Path("address.street")</em> va permettre de mapper l'attribut <em>getAddress().getStreet()</em> de l'objet en cours d'édition)</p></blockquote> <p>Il faut également déclarer nos widgets “feuille” comme étant editables via le framework Editor. Pour cela, ils doivent implémenter <em>LeafValueEditor</em>, paramétré par le type de valeur qu’ils éditent. LeafValueEditor est une sous interface de Editor, qui permet de déclarer un widget comme “final”, c’est à dire qu’il va contenir une valeur, valeur correspondant à un attribut du bean. De plus, un <em>LeafValueEditor</em> ne contient pas de sous-Editor, comme peut l’être au contraire <em>AddressView</em>.</p> <pre class="java code java" style="font-family:inherit"><span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">class</span> ListItem <span style="color: #7F0055; font-weight: bold;">extends</span> <span style="color: #000000;">Composite</span> <span style="color: #7F0055; font-weight: bold;">implements</span> LeafValueEditor<span style="color: #000000;">&lt;</span>String<span style="color: #000000;">&gt;</span> <span style="color: #000000;">&#123;</span> ... <span style="color: #000000;">&#125;</span></pre> <p>Maintenant que nos widgets et nos vues sont prêts, il ne nous reste plus qu’à remplacer le code de binding précédent par l’Editor. Nous supprimons donc les méthodes <em>getData</em> et <em>setData</em> des vues <em>PersonView</em> et <em>AddressView</em>. Nous remplaçons l'appel à ces méthodes par l'appel au driver. La méthode <em>setData</em> contient donc le code suivant.</p> <pre class="java code java" style="font-family:inherit">editorDriver.<span style="color: #000000;">initialize</span><span style="color: #000000;">&#40;</span>personView<span style="color: #000000;">&#41;</span>; editorDriver.<span style="color: #000000;">edit</span><span style="color: #000000;">&#40;</span>result<span style="color: #000000;">&#41;</span>;</pre> <p>La méthode initialize permet de "lier" le Driver avec l'Editor (l'objet graphique qui va accueillir les donneés). Tandis que la méthode <em>edit</em> est l'équivalent de la méthode <em>setData</em> précédente.</p> <p>Notre formulaire est rempli. Désormais, lorsque l'on voudra récupérer les données de celui-ci, il suffit d'appeler la méthode flush sur le driver, les méthodes getData ne sont plus nécessaires.</p> <pre class="java code java" style="font-family:inherit">personService.<span style="color: #000000;">setPerson</span><span style="color: #000000;">&#40;</span>editorDriver.<span style="color: #000000;">flush</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>, <span style="color: #7F0055; font-weight: bold;">new</span> AsyncCallback<span style="color: #000000;">&lt;</span>Void<span style="color: #000000;">&gt;</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> ... <span style="color: #000000;">&#125;</span></pre> <h3>Allons un peu plus loin</h3> <h2>Les champs non mappés</h2> <p>Un autre avantage intrinsèque au framework Editor, est le fait qu'il n'est pas nécessaire de mapper tous les champs du bean aux champs du formulaire. En effet, la référence du bean passé à la méthode edit() du driver est conservée et est la même référence retournée par la méthode flush. Ainsi, il n'est pas utile de se préoccuper de tous les champs de notre bean en ayant peur de perdre des données comme cela peut être le cas lorsque l'on réalise un binding manuel. (voir tag git&nbsp;: state2)</p> <h2>la méthode isDirty()</h2> <p>Si vous utilisez un peu le framework Editor, vous vous rendrez vite compte que le driver possède de nombreuses petites méthodes utilitaires pour vous faciliter encore plus le développement. La méthode isDirty, qui renvoie un booléen, permet de savoir si les attributs de votre bean ont été modifiées depuis l'appel à la méthode edit. C'est à dire, savoir si votre formulaire a été modifié ou non. Cela peut permettre d'éviter d'appeler un service distant dans le cas où cela n'est pas nécessaire. (voir tag git&nbsp;: state3)</p> <pre class="java code java" style="font-family:inherit"><span style="color: #7F0055; font-weight: bold;">protected</span> <span style="color: #7F0055; font-weight: bold;">void</span> saveData<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>         <span style="color: #7F0055;font-weight: bold;">if</span> <span style="color: #000000;">&#40;</span>editorDriver.<span style="color: #000000;">isDirty</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>             <span style="color: #808080; font-style: italic;">// appel du service RPC</span>         <span style="color: #000000;">&#125;</span> <span style="color: #7F0055;font-weight: bold;">else</span> <span style="color: #000000;">&#123;</span>             <span style="color: #000000;">Window</span>.<span style="color: #000000;">alert</span><span style="color: #000000;">&#40;</span><span style="color: #888888;">&quot;Data has not changed&quot;</span><span style="color: #000000;">&#41;</span>;         <span style="color: #000000;">&#125;</span>     <span style="color: #000000;">&#125;</span></pre> <h2>La gestion des erreurs</h2> <blockquote><p>(tag git&nbsp;: state4)<br /></p></blockquote> <p>La dernière fonctionnalité que nous allons voir est la gestion des erreurs au sein même du framework. <br />
Chaque Editor peut enregistrer ses propres erreurs au niveau du Driver, quand il le souhaite. Dans notre cas, nous allons enregistrer des erreurs lorsqu'un champ du formulaire est vide. Ensuite, nous récupérerons ces erreurs au niveau de la classe principale pour les afficher à l'utilisateur.</p> <p>Afin d'enregistrer des erreurs, il est nécessaire d'avoir accès à l'objet <em>EditorDelegate</em>, qui possède la méthode recordError. Nous allons donc modifier la classe <em>TextItem</em> afin de récupérer l<em>'EditorDelegate</em>. Pour cela, la classe doit implémenter l'interface <em>HasEditorDelegate</em> et définir la méthode setDelegate.</p> <pre class="java code java" style="font-family:inherit"><span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">class</span> TextItem <span style="color: #7F0055; font-weight: bold;">extends</span> <span style="color: #000000;">Composite</span> <span style="color: #7F0055; font-weight: bold;">implements</span> LeafValueEditor<span style="color: #000000;">&lt;</span>String<span style="color: #000000;">&gt;</span>, HasEditorDelegate<span style="color: #000000;">&lt;</span>String<span style="color: #000000;">&gt;</span> <span style="color: #000000;">&#123;</span>     ...     <span style="color: #7F0055; font-weight: bold;">private</span> EditorDelegate<span style="color: #000000;">&lt;</span>String<span style="color: #000000;">&gt;</span> editorDelegate;     ...     @Override     <span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">void</span> setDelegate<span style="color: #000000;">&#40;</span>EditorDelegate<span style="color: #000000;">&lt;</span>String<span style="color: #000000;">&gt;</span> delegate<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>         <span style="color: #7F0055; font-weight: bold;">this</span>.<span style="color: #000000;">editorDelegate</span> = delegate;     <span style="color: #000000;">&#125;</span> <span style="color: #000000;">&#125;</span></pre> <p>Nous pouvons désormais enregistrer des erreurs. Ce que nous allons faire dans la méthode getValue(). Ainsi si la valeur du widget est vide, nous enregistrons une erreur</p> <pre class="java code java" style="font-family:inherit">@Override <span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #000000;">String</span> getValue<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>     checkNotNull<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;     <span style="color: #7F0055; font-weight: bold;">return</span> textBox.<span style="color: #000000;">getValue</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>; <span style="color: #000000;">&#125;</span> &nbsp; <span style="color: #7F0055; font-weight: bold;">private</span> <span style="color: #7F0055; font-weight: bold;">void</span> checkNotNull<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>     <span style="color: #7F0055;font-weight: bold;">if</span> <span style="color: #000000;">&#40;</span>textBox.<span style="color: #000000;">getValue</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>.<span style="color: #000000;">isEmpty</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>         editorDelegate.<span style="color: #000000;">recordError</span><span style="color: #000000;">&#40;</span><span style="color: #888888;">&quot;TextItem &quot;</span> + label.<span style="color: #000000;">getText</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> + <span style="color: #888888;">&quot; is empty&quot;</span>, <span style="color: #7F0055; font-weight: bold;">null</span>, <span style="color: #7F0055; font-weight: bold;">null</span><span style="color: #000000;">&#41;</span>;     <span style="color: #000000;">&#125;</span> <span style="color: #000000;">&#125;</span></pre> <p>Le fait d'enregistrer des erreurs n'a aucune incidence sur le fonctionnement si on ne les prend pas en compte manuellement</p> <p>Nous allons afficher un message d'alerte à l'utilisateur pour chaque erreur.</p> <pre class="java code java" style="font-family:inherit"><span style="color: #7F0055; font-weight: bold;">protected</span> <span style="color: #7F0055; font-weight: bold;">void</span> saveData<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>     ...     <span style="color: #000000;">Person</span> person = editorDriver.<span style="color: #000000;">flush</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;     <span style="color: #7F0055;font-weight: bold;">if</span> <span style="color: #000000;">&#40;</span>editorDriver.<span style="color: #000000;">hasErrors</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>         StringBuilder errorBuilder = <span style="color: #7F0055; font-weight: bold;">new</span> StringBuilder<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;         <span style="color: #7F0055;font-weight: bold;">for</span> <span style="color: #000000;">&#40;</span>EditorError error : editorDriver.<span style="color: #000000;">getErrors</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>             errorBuilder.<span style="color: #000000;">append</span><span style="color: #000000;">&#40;</span>error.<span style="color: #000000;">getMessage</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> + <span style="color: #888888;">&quot;<span style="color: #000099; font-weight: bold;">n</span>&quot;</span><span style="color: #000000;">&#41;</span>;         <span style="color: #000000;">&#125;</span>         <span style="color: #000000;">Window</span>.<span style="color: #000000;">alert</span><span style="color: #000000;">&#40;</span>errorBuilder.<span style="color: #000000;">toString</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;     <span style="color: #000000;">&#125;</span>     ... <span style="color: #000000;">&#125;</span></pre> <p>Les Editor fournissent également d'autres fonctionnalités, tels que les <em>Decorator</em> ou l'intégration avec <em>RequestFactory</em> via un driver spécifique, <em>RequestFactoryEditorDriver</em>, que je ne détaillerai pas dans cet article.</p> <h3>Conclusion</h3> <p>Le framework Editor fourni par GWT est donc une façon élégante de mettre en place le binding objet métier/widget graphique, en réduisant fortement la quantité de code nécessaire. Certaines fonctionnalités supplémentaires telles que la gestion des erreurs sont un vrai plus quant à son adoption. On peut cependant regretter un manque de simplicité dans la documentation officielle de GWT.</p>