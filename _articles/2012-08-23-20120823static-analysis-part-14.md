---
ID: 180
post_title: Static analysis (part 1/4)
author: shadjiat
post_date: 2012-08-23 09:30:00
post_excerpt: |
  <p>Software quality is modern software development. In fact, software defects can lead to serious issues, like data loss. Besides, they need to get fixed, which adds to the project cost. That is why code review, different set of eyes examining the source code looking for possible bugs, is becoming a routine procedure in software development.</p> <p>Along with code review, is static code analysis. Indeed, code review, while an important and necessary step, is not enough. It is tedious and fallible because it depends on humans. Thus, there is a large class of software defects that can be detected in an automated way. Enter the static code analysis, with tools like PMD, CheckStyle and FindBugs. Even if you haven't used one of those tools, you still have encountered static analysis by simply using your IDE of choice, like Eclipse or IntelliJ. Integrated Development Environments do perform some nice static analysis that can detect important bugs, which are not compiling errors, like dead code or unused variables.</p> <p>One interesting body of defects that could be detected by static analysis is security flaws. This post, the first of a series of four, is going to present the FindBugs detector I developed  that performs an advanced analysis to find input injections, called "Taint Analysis". The program can find in java bytecode most vulnerabilities related to input representation, including Cross-site scripting, SQL injection, Cookie poisoning, path traversal.</p> <p>But first, let's introduce static analysis: how it works, and how it can help developers build a strong system.</p>
layout: post
permalink: http://blog.zenika-offres.com/?p=180
published: true
---
<p>Software quality is modern software development. In fact, software defects can lead to serious issues, like data loss. Besides, they need to get fixed, which adds to the project cost. That is why code review, different set of eyes examining the source code looking for possible bugs, is becoming a routine procedure in software development.</p> <p>Along with code review, is static code analysis. Indeed, code review, while an important and necessary step, is not enough. It is tedious and fallible because it depends on humans. Thus, there is a large class of software defects that can be detected in an automated way. Enter the static code analysis, with tools like PMD, CheckStyle and FindBugs. Even if you haven't used one of those tools, you still have encountered static analysis by simply using your IDE of choice, like Eclipse or IntelliJ. Integrated Development Environments do perform some nice static analysis that can detect important bugs, which are not compiling errors, like dead code or unused variables.</p> <p>One interesting body of defects that could be detected by static analysis is security flaws. This post, the first of a series of four, is going to present the FindBugs detector I developed  that performs an advanced analysis to find input injections, called "Taint Analysis". The program can find in java bytecode most vulnerabilities related to input representation, including Cross-site scripting, SQL injection, Cookie poisoning, path traversal.</p> <p>But first, let's introduce static analysis: how it works, and how it can help developers build a strong system.</p>
<!--more-->
<h3>Static analysis in theory</h3> <p>Static analysis is the process of analyzing code, either in source of compiled representation, without executing it. Due to its automated nature, such a tool can go through a large number of scenarios and corner cases that are otherwise difficult for testers to cover.</p> <p>Static analysis mostly follow the compilation process: the code gets parsed and then represented in a model which gets analysed, and finally results are outputted.</p> <p><img src="/wp-content/uploads/2015/07/static_analysis_diagram.PNG" alt="static analysis diagram" style="display:block; margin:0 auto;" title="static analysis diagram" /></p> <p>Static analysis can be applied to varying scales: from a token or a line, to separate functions and classes, or even a single program and module. The most advanced tools can be run on an entire system involving multiple modules written in different languages. Still, regardless the different scopes, the analysis follows mostly the same structure described on the diagram above.</p> <p>The first steps of the analysis process, the lexing and parsing, are quite similar between the different tools. Lexical analysis consists of transforming the input from a stream of characters to a stream of higher-level tokens. Next, using a set of rules defined by the language's grammar, this linear stream of tokens gets transformed into a parse-tree representing the program structure. The latter is usually further transformed into a cleaner and tweaked model.</p> <p>There are multiple types of analysis, among them:</p> <ul> <li>pattern-based: searches for a given function or a sequence of instructions.</li> <li>dataflow: enables to follow data across the program. Its main applications are: constant and type propagation, reaching definitions, taint propagation.</li> <li>interprocedural: gathers information across multiple procedures (typically across the entire program), analyses interaction between functions.</li> </ul> <p>Depending on the type of analysis, the used code representation can be a parse tree, an abstract syntax tree, a control flow graph (for dataflow analysis), along with a symbol table mapping identifiers to their type and declaration site. Some more custom representations could be used to match the analysis. The most important thing is that the representation should contain all the information needed by the tool to perform the analysis.</p> <p>As an illustration, here is an example of java code:</p> <pre class="java code java" style="font-family:inherit"><span style="color: #7F0055; font-weight: bold;">int</span> i=0; <span style="color: #7F0055; font-weight: bold;">int</span> j=<span style="color: #cc66cc;">4</span>; <span style="color: #7F0055;font-weight: bold;">for</span> <span style="color: #000000;">&#40;</span>; i<span style="color: #000000;">&lt;</span><span style="color: #cc66cc;">10</span>; i++<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>    <span style="color: #7F0055;font-weight: bold;">if</span> <span style="color: #000000;">&#40;</span>i<span style="color: #000000;">&lt;</span>j<span style="color: #000000;">&#41;</span> j=i<span style="color: #000000;">*</span>j; <span style="color: #000000;">&#125;</span> <span style="color: #7F0055; font-weight: bold;">return</span> j;</pre> <p>From this set of instructions can be built an abstract syntax tree: <img src="/wp-content/uploads/2015/07/.AST_m.jpg" alt="Abstract Syntax Tree" style="display:block; margin:0 auto;" title="Abstract Syntax Tree" /></p> <p>and a control flow graph: <img src="/wp-content/uploads/2015/07/.CFG_s.jpg" alt="Control Call Graph" style="display:block; margin:0 auto;" title="Control Call Graph" /></p> <h3>Static analysis in practice</h3> <p>There are many different static analysis tools, targeting one or multiple languages and performing all kinds of analysis. I will not list all the existing tools, but I can give most categories they belong to.</p> <ul> <li>Type checking</li> </ul> <p>Type checking is an important use of static analysis. It may not get all the attention it deserves, compilers being after all the first ones checking language typing specification. Let's look at this example:</p> <pre class="java code java" style="font-family:inherit"><span style="color: #000000;">Object</span><span style="color: #000000;">&#91;</span><span style="color: #000000;">&#93;</span> objects = <span style="color: #7F0055; font-weight: bold;">new</span> <span style="color: #000000;">String</span><span style="color: #000000;">&#91;</span><span style="color: #cc66cc;">3</span><span style="color: #000000;">&#93;</span>; objects<span style="color: #000000;">&#91;</span>0<span style="color: #000000;">&#93;</span> = <span style="color: #7F0055; font-weight: bold;">new</span> <span style="color: #000000;">Object</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;</pre> <p>This code will compile without a warning, but an ArrayStoreException will be thrown at runtime. This kinds of errors can be detected with static analysis.</p> <ul> <li>Style checking</li> </ul> <p>This type of analysis can find all sorts of style errors: wrong indentation, bad naming, duplicate code, ... Here is an example of bad indentation that can be confusing:</p> <pre class="java code java" style="font-family:inherit"><span style="color: #7F0055; font-weight: bold;">int</span> x = 0, y = <span style="color: #cc66cc;">3</span>;       <span style="color: #7F0055;font-weight: bold;">if</span> <span style="color: #000000;">&#40;</span>x == y<span style="color: #000000;">&#41;</span>              <span style="color: #7F0055;font-weight: bold;">if</span> <span style="color: #000000;">&#40;</span>y == <span style="color: #cc66cc;">3</span><span style="color: #000000;">&#41;</span>                     x = <span style="color: #cc66cc;">3</span>;       <span style="color: #7F0055;font-weight: bold;">else</span>              x = <span style="color: #cc66cc;">4</span>;</pre> <p>The <code>else</code> instruction is not for the first <code>if</code> as we may think, but the second one. This simple error can lead to implementation mistakes.</p> <ul> <li>Program understanding</li> </ul> <p>This is one of IDEs famous features. For example: find all declarations or uses of a given variable or method. It doesn't find errors but gives useful information on the program.</p> <ul> <li>Program verification and property checking</li> </ul> <p>This analysis enables to check properties of a given specification, for example division by zero. More generally, program verification can also be done with formal methods, which are used to prove the correctness of algorithms and formal specifications.</p> <ul> <li>Bug finding</li> </ul> <p>Bug finding is about pointing out programming mistakes: bad practice, coding errors, unexpected behaviour.</p> <p>One interesting example of bugs that static analysis can find is null pointer dereference.</p> <pre class="java code java" style="font-family:inherit"><span style="color: #7F0055; font-weight: bold;">int</span> i=0; <span style="color: #000000;">String</span> s = <span style="color: #7F0055; font-weight: bold;">null</span>; <span style="color: #7F0055;font-weight: bold;">if</span><span style="color: #000000;">&#40;</span>i<span style="color: #000000;">&gt;</span>0<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#123;</span> 	s = <span style="color: #888888;">&quot;positive&quot;</span>; <span style="color: #000000;">&#125;</span> &nbsp; <span style="color: #7F0055;font-weight: bold;">if</span><span style="color: #000000;">&#40;</span>s.<span style="color: #000000;">contains</span><span style="color: #000000;">&#40;</span><span style="color: #888888;">&quot;pos&quot;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#123;</span> 	<span style="color: #000000;">System</span>.<span style="color: #000000;">out</span>.<span style="color: #000000;">println</span><span style="color: #000000;">&#40;</span>s<span style="color: #000000;">&#41;</span>; <span style="color: #000000;
">&#125;</span></pre> <p>This code will compile but at runtime a null pointer exception will be thrown, the String s being null and calling the method <code>contains</code>. Static analysis tools, for instance FindBugs can find this bug and report it.</p> <p><img src="/wp-content/uploads/2015/07/Capture.PNG" alt="FindBugs null pointer example" style="display:block; margin:0 auto;" title="FindBugs null pointer example" /> <br /></p> <ul> <li>Security review</li> </ul> <p>Static analysis can be applied to find security flaws in code. With dataflow analysis, it is possible to follow the propagation of input data, and thus detect possible code injection. Besides the classic cross-site scripting, here is an example of path traversal:</p> <pre class="java code java" style="font-family:inherit"><span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">static</span> <span style="color: #7F0055; font-weight: bold;">void</span> main<span style="color: #000000;">&#40;</span><span style="color: #000000;">String</span> args<span style="color: #000000;">&#91;</span><span style="color: #000000;">&#93;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#123;</span>       <span style="color: #000000;">File</span> f = <span style="color: #7F0055; font-weight: bold;">new</span> <span style="color: #000000;">File</span><span style="color: #000000;">&#40;</span>args<span style="color: #000000;">&#91;</span>0<span style="color: #000000;">&#93;</span><span style="color: #000000;">&#41;</span>;       f.<span style="color: #000000;">open</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;       <span style="color: #808080; font-style: italic;">//...</span> <span style="color: #000000;">&#125;</span></pre> <p>This program opens a file with an argument entered in command line. The fact that we use this argument to open a file is just an example, the important fact is that we use directly an input without validation, which constitutes a serious security vulnerability. Dataflow analysis can detect this kind of flaw by finding the source of data inputs, following their propagation until their use in a sensitive instruction (like creating a File object). This is called <em>Taint analysis</em>.</p> <h4>Limits</h4> <p>Static analysis has nevertheless its limits. There are some questions that algorithms can't answer. In computability theory, finding all possible runtime errors or proving a non trivial property of a program is undecidable. It means that no algorithm can always resolve this problem. This all comes to the halting problem : given a program and an input, decide whether the program will eventually halt or run indefinitely. The halting problem has been proven to be undecidable since the only way of finding for sure whether a program halts is to run it.</p> <p>The consequences of this fact is that static analysis makes approximations which generates what we call <em>false positives</em> and <em>false negatives</em>. A false positive is a result that indicates a condition is true when it is false (opposite to false negative), for instance the tool will point an error where there is none. False negatives are the most problematic since it misses errors giving a false sense of security. This involves two concepts: soundness and completeness. A tool is <em>sound</em> if it never gets false negatives. This means that it will always find an error when it exists but the counter part is there can be false positives. A tool is <em>complete</em> when it never suffer false positives. It will never issue a bug without a feasible counter example proving it. Bug finding tools tend to be <em>unsound</em> and <em>complete</em>,  minimizing false positives results, while property checking tools need to find all property violations which make them more sound. The challenge is to find the perfect compromise between soundness and completeness based on the type of analysis.</p> <h3>Conclusion</h3> <p>Static analysis tools aims to help programmers during the development phase to ensure the safety and quality of their code. If used very early, the cost is minimal in contrast to testing which is done at the very last time, after coding.</p> <p>In the next post, I will present FindBugs, an open source static analysis tool that can detect bugs in java bytecode.</p> <h5>Reference</h5> <p><a href="http://www.amazon.com/Secure-Programming-Static-Analysis-Brian/dp/0321424778">''Secure programming with static analysis'', by Brian Chess and Jacob West.</a></p>