---
ID: 188
post_title: DAO et ORM sont-ils compatibles ?
author: ocroisier
post_date: 2009-07-27 11:41:00
post_excerpt: "<p>Les architectures modernes sont typiquement découpées en couches représentant des services concentriques de plus en plus haut niveau&nbsp;:</p> <ul> <li>Accès aux données (couche de persistance ou DAO, l'objet de ce billet),</li> <li>Traitements métiers,</li> <li>Présentation à l'utilisateur ou exposition à des systèmes tiers.</li> </ul> <p>Les bonnes pratiques imposent que chacune de ces couches soit représentée par une interface exprimant le service qu'elle rend et masquant la façon dont elle est implémentée. Leur respect permet d'obtenir des architectures modulaires et faiblement couplées, facilitant le test et la maintenance des applications.</p> <p>Pourtant, les ORMs remettent en cause ce schéma.</p>"
layout: post
permalink: http://blog.zenika-offres.com/?p=188
published: true
---
<p>Les architectures modernes sont typiquement découpées en couches représentant des services concentriques de plus en plus haut niveau&nbsp;:</p> <ul> <li>Accès aux données (couche de persistance ou DAO, l'objet de ce billet),</li> <li>Traitements métiers,</li> <li>Présentation à l'utilisateur ou exposition à des systèmes tiers.</li> </ul> <p>Les bonnes pratiques imposent que chacune de ces couches soit représentée par une interface exprimant le service qu'elle rend et masquant la façon dont elle est implémentée. Leur respect permet d'obtenir des architectures modulaires et faiblement couplées, facilitant le test et la maintenance des applications.</p> <p>Pourtant, les ORMs remettent en cause ce schéma.</p>
<!--more-->
<h4>La couche de persistance</h4> <p>Le service demandé à une couche de persistance est parfaitement exprimé par l'acronyme <strong>CRUD</strong> (<strong>C</strong>reate, <strong>R</strong>etrieve, <strong>U</strong>pdate, <strong>D</strong>elete), c'est-à-dire que l'on souhaite pouvoir sauvegarder, récupérer, mettre à jour et supprimer les données que l'application manipule.</p> <p>L'interface typique d'une couche DAO ressemble donc à&nbsp;:</p> <pre class="java code java" style="font-family:inherit"><ol><li style="font-weight: normal;"><div style="font-family: monospace; font-weight: normal; font-style: normal; margin:0; padding:0; background:inherit;"><span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">interface</span> ClientDao</div></li><li style="font-weight: normal;"><div style="font-family: monospace; font-weight: normal; font-style: normal; margin:0; padding:0; background:inherit;"><span style="color: #000000;">&#123;</span></div></li><li style="font-weight: normal;"><div style="font-family: monospace; font-weight: normal; font-style: normal; margin:0; padding:0; background:inherit;">	<span style="color: #7F0055; font-weight: bold;">public</span> Client save<span style="color: #000000;">&#40;</span>Client client<span style="color: #000000;">&#41;</span>;</div></li><li style="font-weight: normal;"><div style="font-family: monospace; font-weight: normal; font-style: normal; margin:0; padding:0; background:inherit;">	<span style="color: #7F0055; font-weight: bold;">public</span> Client update<span style="color: #000000;">&#40;</span>Client client<span style="color: #000000;">&#41;</span>;</div></li><li style="font-weight: normal;"><div style="font-family: monospace; font-weight: normal; font-style: normal; margin:0; padding:0; background:inherit;">	<span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">void</span> delete<span style="color: #000000;">&#40;</span>Client client<span style="color: #000000;">&#41;</span>;</div></li><li style="font-weight: normal;"><div style="font-family: monospace; font-weight: normal; font-style: normal; margin:0; padding:0; background:inherit;">	<span style="color: #7F0055; font-weight: bold;">public</span> Client getClient<span style="color: #000000;">&#40;</span>ClientId id<span style="color: #000000;">&#41;</span>;</div></li><li style="font-weight: normal;"><div style="font-family: monospace; font-weight: normal; font-style: normal; margin:0; padding:0; background:inherit;">	<span style="color: #7F0055; font-weight: bold;">public</span> Collection<span style="color: #000000;">&lt;</span>Client<span style="color: #000000;">&gt;</span> getAllClients<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;</div></li><li style="font-weight: normal;"><div style="font-family: monospace; font-weight: normal; font-style: normal; margin:0; padding:0; background:inherit;"><span style="color: #000000;">&#125;</span></div></li></ol></pre> <p>Constatez que cette interface est suffisamment générique pour ne laisser transparaître aucun détail technique, et peut ensuite être implémentée facilement de différentes façons&nbsp;: écriture dans un fichier plat ou XML, insertion en base de données, sauvegarde sur un système distant, sauvegarde en mémoire...</p> <h4>DAO et bases de données&nbsp;: le problème Hibernate</h4> <p>Les bases de données suivent depuis longtemps le modèle CRUD&nbsp;; les instructions SQL <code>INSERT</code>, <code>SELECT</code>, <code>UPDATE</code>, <code>DELETE</code> en sont une transposition directe. Il est donc très simple d'implémenter une couche DAO via de simples appels JDBC basiques.</p> <p>Tout était bien dans le meilleur des mondes, jusqu'à l'apparition des frameworks de mapping objet-relationnel (ORM), Hibernate en tête. Sous couvert de simplifier la vie du développeur (ce qui reste à démontrer), ils apportent une sémantique tout à fait différente et largement incompatible avec le système CRUD. En cause, la notion de cycle de vie des objets manipulés (transient / attaché / détaché), qui doit être géré manuellement par le développeur.</p> <p>S'il apporte des fonctionnalités puissantes (mise à jour automatique, gestion de grappes d'objets...), ce système a une forte tendance à transpirer dans les couches supérieures - souvent même jusqu'à la couche de présentation, ce qui est une hérésie totale du point de vue architectural (cf. le pattern "<em>open session in view</em>").</p> <p>Exit donc le pattern CRUD. Exit aussi l'interface DAO générique indépendante de l'implémentation&nbsp;: les couches supérieures devant gérer finement le cycle de vie des objets, il est indispensable qu'elles puissent accéder aux APIs bas niveau du framework de persistance&nbsp;: <code>persist</code>, <code>merge</code>, <code>delete</code>, <code>saveOrUpdate</code>, <code>lock</code>...<br /></p> <h4>DAO par ORM&nbsp;: isolation plutôt que découplage</h4> <p>Si la couche DAO n'est plus découplée des couches supérieures, est-elle encore utile&nbsp;? Si son interface n'est qu'un simple miroir des APIs de l'implémentation sélectionnée, à quoi sert-elle&nbsp;? Ne serait-il pas plus simple de reconnaître cet état de fait et de supprimer la couche DAO lorsqu'on utilise un framework d'ORM&nbsp;?</p> <p>A cette question qui mérite réflexion, je préfère apporter une réponse nuancée.<br />
Certes, le découplage est cassé&nbsp;; mais la couche DAO conserve une utilisé pratique&nbsp;: elle permet d'isoler une partie du code technique spécifique (requêtes HQL / SQL, <em>Criterions</em>, <em>Transformers</em>...) dans des packages bien définis, et de garder l'apparence d'une architecture en couches standard.</p> <h4>Conclusion</h4> <p>Lors de la mise en place d'une pile technique, il faut savoir jeter un regard critique sur les différentes technologies disponibles sur le marché, et déterminer si leurs forces et faiblesses sont acceptables dans le cadre du projet. En particulier, il faut résister aux sirènes du "standard" (Spring/Hibernate/Struts par exemple) et ne pas hésiter à faire ses propres choix argumentés.</p> <p>Cet article avait notamment pour but de vous faire prendre conscience que les ORMs ne sont pas des outils magiques, et qu'ils imposent de fortes contraintes sur l'architecture (en plus d'une certaine complexité), pouvant mener à des difficultés de testabilité ou de maintenance.</p>