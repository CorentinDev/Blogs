---
ID: 468
post_title: 'Rex &#8211; AngularJS et les Fuites mémoires'
author: Martin Mouterde
post_date: 2015-01-22 20:55:00
post_excerpt: "<p>Il y a peu, j'ai eu le privilège de travailler sur un très gros projet AngularJS. Et par très gros j'entends&nbsp;: démesuré, du genre qui pousse le framework dans ses derniers retranchements. Un projet où la limite «&nbsp;officielle&nbsp;» du nombre de 2000 bindings pour obtenir des performances acceptables (pour les versions &lt;1.3 du moins) se compare avec les 70 000 bindings d'une seule page comportant 1Go de données.</p> <p>Les fuites mémoires, sont déjà des phénomènes difficiles à résoudre, mais dans un tel contexte, cela devient un véritable cauchemar&nbsp;! Voici donc un retour d'expérience sur la chasse aux fuites mémoires sur un projet AngularJS.</p>"
layout: post
permalink: http://blog.zenika-offres.com/?p=468
published: true
slide_template:
  - ""
---
<p>Il y a peu, j'ai eu le privilège de travailler sur un très gros projet AngularJS. Et par très gros j'entends&nbsp;: démesuré, du genre qui pousse le framework dans ses derniers retranchements. Un projet où la limite «&nbsp;officielle&nbsp;» du nombre de 2000 bindings pour obtenir des performances acceptables (pour les versions &lt;1.3 du moins) se compare avec les 70 000 bindings d'une seule page comportant 1Go de données.</p> <p>Les fuites mémoires, sont déjà des phénomènes difficiles à résoudre, mais dans un tel contexte, cela devient un véritable cauchemar&nbsp;! Voici donc un retour d'expérience sur la chasse aux fuites mémoires sur un projet AngularJS.</p>
<!--more-->
<p>La littérature évoque généralement deux approches&nbsp;:</p> <h5>La méthode "Généticienne"&nbsp;: A base de relecture de code</h5> <p>Effectivement, l'ADN de votre appli contient probablement des anomalies répertoriées (fuites mémoires ou non). L'idée n'est pas nécessairement de repasser sur tout le code mais de se focaliser sur certaines instructions ou patterns clés (<code>$timeout</code>, <code>.on()</code>, <code>$scope.$watch</code>, <code>console.log</code>...)</p> <p>Pour être vraiment efficace, mieux vaut maîtriser le framework et connaître les erreurs fréquentes que vous pouvez rencontrer <a href="http://nathanleclaire.com/blog/2014/04/19/5-angularjs-antipatterns-and-pitfalls/">ici</a> ou <a href="http://thenittygritty.co/angularjs-pitfalls-using-scopes">là</a>.</p> <p>Mais quand on est malade, le problème peut aussi être environnemental&nbsp;: vos dépendances peuvent elles aussi être problématiques. C'est là que la seconde solution s'impose bien souvent&nbsp;: plutôt que d'inspecter tous les tuyaux à la recherche d'un trou, partons de la flaque.</p> <h5>La méthode "Voyons ce qui coule"&nbsp;: avec les outils de profiling de Chrome</h5> <p>L'outil de profiling de Chrome est une vrai richesse. Il fait tout ce qu'on pourrait attendre d'un profiler&nbsp;! Suivi de la consommation mémoire, dumps mémoire, comparaison de dumps... Tout y est.</p> <p>Malgré l’excellent outil, je me suis heurté à plusieurs problèmes&nbsp;:</p> <ul> <li>Le Profiler a besoin de beaucoup de ressources (CPU et mémoire) et dans mon cas de saturation, l'obtention d'un dump n'était pas toujours assurée.</li> </ul> <ul> <li>Les dumps sont difficiles à lire. Les scopes sont souvent les objets les plus chargés en  données, ils sont très fréquemment créés puis détruits puis recréés au fil de la navigation. Dans ces conditions, ce sont eux, en particulier, qui risquent de poser problème. Mais ils sont aussi tous très liés entre eux et leurs liens (parents, enfants, frères) sont bidirectionnels&nbsp;! Dans un gros dump, on peut identifier des scopes qui ne devraient plus être en mémoire, mais difficilement le lien qui les retient.</li> </ul> <ul> <li>Certaines fuites mémoires sont "faites exprès"&nbsp;! Il s'agit de cache applicatif, de cache angularJS (http, template...), de cache JQuery/jqLite (DOM, nodes, http...), de rétention pour les outils (Batarang, console.log...), du cache navigateur (DOM). Tout cela vient rapidement polluer l'analyse.</li> </ul> <ul> <li>Le Garbage Collector de Chrome est assez paresseux et peu prédictible. Il n'est pas impossible qu'il tarde à supprimer tel ou tel type d'objet ou qu'il ne fasse pas tout le boulot à chaque fois... J'ai dû abandonner toutes mes analyses avec plein de beaux screenshots colorés basées sur la timeline. Le bouton lançant le GC n'est pas non plus une garantie.</li> </ul> <p>Rétrospectivement, je ne fais plus confiance qu'aux dumps (en vue comparé ou non)&nbsp;: en recherchant les éléments de type <code>$get.Scope.$new.$$childScopeClass</code>, vous pourrez probablement trouver une accumulation de certaines familles de scope.</p> <p><img src="/wp-content/uploads/2015/07/dump.jpg" alt="Dump" style="display:block; margin:0 auto;" title="Dump" /></p> <p>Aussi, à force de naviguer au hasard des dumps, je suis tombé sur un 'retainer' récurrent répondant au doux nom de <code>jQuery1830550544549478218</code>.</p> <p>J'ai alors découvert une troisième approche&nbsp;:</p> <h5>La méthode "des Expandos"&nbsp;:</h5> <p>Avant de décrire la méthode, arrêtons nous un instant, sur un détail d'implémentation de JQuery (reproduit dans jqLite). JQuery comme jqLite ajoutent des données aux nœuds du DOM en guise de cache. Il s'agit grosso modo de profiter que chaque nœud soit un objet JavaScript qui peut, par nature, être étendu par de nouvelles propriétés arbitraires (appelées "expando properties").</p> <p>Lorsqu'on ajoute un gestionnaire d’événement comme ceci&nbsp;:</p> <pre> angular.element($window.document.body).on(&quot;mousedown&quot;,maFunction); </pre> <p>ou</p> <pre> $(&quot;body&quot;).on(&quot;mousedown&quot;,maFonction); </pre> <p>La lib JS va persister l'association nœud/événement/fonction sous forme d'expando sur le nœud. Ici, elle ajoutera sur l'élément <code>body</code> une propriété, respectivement, <code>ng135</code> et <code>jQuery1830550544549478218</code>. Ainsi, la fonction est liée à un élément du DOM. Comme dans cet exemple (avec le nœud <code>body</code>), certains nœuds du DOM n'ont pas pour vocation à être supprimés. Si au fil de la navigation, on ajoute toujours les mêmes fonctions au même nœud liant des scopes toujours recréés, il y a donc une fuite mémoire.</p> <p>Fort de ce constat, j'ai développé un <a href="http://mmouterde.github.io/ngLeak">script</a> permettant de parcourir tous les nœuds du DOM et de vérifier chaque propriété du type jQuery* ou ng* pour comptabiliser ces liens nœud/fonction.</p> <p>Voici comment l'utiliser&nbsp;:</p> <ul> <li>Lancer l'appli</li> <li>Dérouler un scénario de navigation en passant au moins deux fois par des pages/vues à tester (pour initier la redondance provoquée par la fuite mémoire)</li> <li>Ouvrir les outils de débug Chrome</li> <li>Lancer le script (depuis la console, les <a href="https://developer.chrome.com/devtools/docs/authoring-development-workflow#snippets">snipnets</a> ou un <a href="https://support.mozilla.org/en-US/kb/bookmarklets-perform-common-web-page-tasks">bookmarklet</a></li> <li>Le script va lister les fonctions liées plus d'une fois à un même nœud</li> <li>Il vous en affichera le code&nbsp;:</li> </ul> <p><img src="/wp-content/uploads/2015/07/report.jpg" alt="report" style="display:block; margin:0 auto;" title="report" /></p> <ul> <li>Il ne reste plus qu'à trouver, dans la base de code, cette fonction et corriger son usage</li> </ul> <p>Vous trouverez&nbsp;:</p> <ul> <li>une page de démonstration&nbsp;: <a href="http://mmouterde.github.io/ngLeak" title="http://mmouterde.github.io/ngLeak">http://mmouterde.github.io/ngLeak</a></li> <li>le code du script&nbsp;: <a href="https://github.com/mmouterde/ngLeak" title="https://github.com/mmouterde/ngLeak">https://github.com/mmouterde/ngLeak</a></li> <li>le plunker associé&nbsp;: <a href="http://plnkr.co/edit/fsxEym?p=preview" title="http://plnkr.co/edit/fsxEym?p=preview">http://plnkr.co/edit/fsxEym?p=previ...</a></li> </ul> <p>Si ce type de fuite mémoire n'est bien sur pas le seul type possible, c'est celui que j'ai rencontré le plus souvent que ce soit sur le projet ou sur ses dépendances.</p> <p>Pour conclure, notez que chaque méthode présentée ici comporte un intérêt, ne vous arrêtez pas à un seul outil. Pensez à tester votre appli régulièrement sur ces aspects de fuites mémoires, surtout lors de l’intégration de lib extérieure.</p>