---
ID: 184
post_title: >
  Setting up a development environment
  using Docker and Vagrant
author: mloriedo
post_date: 2014-10-07 10:00:00
post_excerpt: '<p>Often considered two alternative tools, Docker and Vagrant can be used together to build isolated and repeatable development environments. We will prove it setting up a Docker container for development of a Java application and taking advantage of Vagrant powerful features to solve some real life practical issues.</p>'
layout: post
permalink: http://blog.zenika-offres.com/?p=184
published: true
slide_template:
  - default
---
Often considered two alternative tools, Docker and Vagrant can be used together to build isolated and repeatable development environments. We will prove it setting up a Docker container for development of a Java application and taking advantage of Vagrant powerful features to solve some real life practical issues.

<!--more-->

<img style="display: block; margin: 0 auto;" src="/wp-content/uploads/2015/07/docker_vagrant_small.png" alt="docker+vagrant" />
<h3>TL;DR</h3>
The first part of this blog post deals with the common flaws of development environments, the setup of a simple Docker environment and the benefits of a Vagrant+Docker configuration. But if you want to just start using Docker with Vagrant jump to the <a href="#jump">corresponding section</a>.
<h3>What's wrong with development environments?</h3>
<ul>
	<li><strong>It can take too long to set it up</strong></li>
</ul>
How long does it takes for a new developer to setup your current project's development environment? The answer may depends on many factors (the project age, the number of developers that have worked on it, etc...) but half a day or more is not an uncommon one.
Hey! It should be much faster than that: checkout a script and execute it. That's all. Two steps should be sufficient to setup your environment and get ready for development.
<ul>
	<li><strong>It can differ too much from testing and production environments</strong></li>
</ul>
Have you ever skipped your build's automated tests because they failed on your machine? Or even worst, have you ever been the cause of a build break even if your changes compiled smoothly on your machine but failed consistently on CI server?
Any slight difference can result in an unexpected behaviour. Diverging can be as simple as giving a try to the last version of a framework or switching to a different project for half a day.
Finding out what makes your system behave differently is an annoying task every developer should avoid.
<h3>Virtual environments and Docker</h3>
As a consequence development environment should have two characteristics:

<strong>Isolated</strong>: you don't want to mess it up when testing some new tool or a different project.
<strong>Repeatable</strong>: the same environment should be consistently reproducible on every team member machine and on CI and production servers.

Virtual environments ensure these features. But classic VMs are resource consuming. Developers need to code/build/test every few minutes and won't accept the virtualization overhead.

Here is where <a href="https://www.docker.com/">Docker</a> becomes helpful. Its lightweight containers are extremely fast compared to classic VMs and have become extremely popular among developers. Here is an excerpt from the Docker blog that explains the reasons for this success:
<blockquote>In its first 12 months Docker usage rapidly spread among startups and early adopters who valued the platform’s ability to separate the concerns of application development management from those of infrastructure provisioning, configuration, and operations. Docker gave these early users a new, faster way to build distributed apps as well as a “write once, run anywhere” choice of deployment from laptops to bare metal to VMs to private and public clouds.</blockquote>
<h3>Using Docker to configure an isolated and repeatable development environment</h3>
As an example we are going to setup a Docker container that can build and test a <a href="http://vertx.io/">Vert.x</a> HTTP server.

Vert.x is a lightweight application framework that encourages architectures of small, independent micro-services. A micro-service is "just a little stand-alone executable that communicates with other stand-alone executables" <a href="http://blog.cleancoder.com/uncle-bob/2014/09/19/MicroServicesAndJars.html">(Uncle Bob)</a>. We think it fits perfectly in a Docker container and that is why we choose it as an example here.

If you haven't already installed Docker do it first. You can refer to the <a href="https://docs.docker.com/installation/">official doc</a> or use <a href="https://get.docker.io/">get docker script</a> to install it. We assume in this section that we are running on Linux. Even if Docker can be installed on Windows and Mac too (with boot2docker), we are going to see in the next session how to do that using Vagrant and why it can be a better choice.
<h5>Dockerfile</h5>
To describe a container we need a Dockerfile:
<pre class="bash code bash" style="font-family: inherit;">FROM ubuntu:<span style="color: #000000;">14.04</span>   <span style="color: #666666; font-style: italic;"># Install dev tools: jdk, git etc...</span> RUN <span style="color: #c20cb9; font-weight: bold;">apt-get</span> update RUN <span style="color: #c20cb9; font-weight: bold;">apt-get</span> <span style="color: #c20cb9; font-weight: bold;">install</span> <span style="color: #660033;">-y</span> openjdk-<span style="color: #000000;">7</span>-jdk <span style="color: #c20cb9; font-weight: bold;">git</span> <span style="color: #c20cb9; font-weight: bold;">wget</span>   <span style="color: #666666; font-style: italic;"># jdk7 is the default jdk</span> RUN <span style="color: #c20cb9; font-weight: bold;">ln</span> <span style="color: #660033;">-fs</span> <span style="color: #000000; font-weight: bold;">/</span>usr<span style="color: #000000; font-weight: bold;">/</span>lib<span style="color: #000000; font-weight: bold;">/</span>jvm<span style="color: #000000; font-weight: bold;">/</span>java-<span style="color: #000000;">7</span>-openjdk-amd64<span style="color: #000000; font-weight: bold;">/</span>jre<span style="color: #000000; font-weight: bold;">/</span>bin<span style="color: #000000; font-weight: bold;">/</span>java <span style="color: #000000; font-weight: bold;">/</span>etc<span style="color: #000000; font-weight: bold;">/</span>alternatives<span style="color: #000000; font-weight: bold;">/</span>java   <span style="color: #666666; font-style: italic;"># Install vertx</span> RUN    <span style="color: #c20cb9; font-weight: bold;">mkdir</span> <span style="color: #660033;">-p</span> <span style="color: #000000; font-weight: bold;">/</span>usr<span style="color: #000000; font-weight: bold;">/</span>local<span style="color: #000000; font-weight: bold;">/</span>vertx <span style="color: #000000; font-weight: bold;">&amp;&amp;</span> <span style="color: #7a0874; font-weight: bold;">cd</span> <span style="color: #000000; font-weight: bold;">/</span>usr<span style="color: #000000; font-weight: bold;">/</span>local<span style="color: #000000; font-weight: bold;">/</span>vertx <span style="color: #000000; font-weight: bold;">&amp;&amp;</span>    <span style="color: #c20cb9; font-weight: bold;">wget</span> http:<span style="color: #000000; font-weight: bold;">//</span>dl.bintray.com<span style="color: #000000; font-weight: bold;">/</span>vertx<span style="color: #000000; font-weight: bold;">/</span>downloads<span style="color: #000000; font-weight: bold;">/</span>vert.x-2.1.2.tar.gz <span style="color: #660033;">-qO</span> - <span style="color: #000000; font-weight: bold;">|</span> <span style="color: #c20cb9; font-weight: bold;">tar</span> <span style="color: #660033;">-xz</span>   <span style="color: #666666; font-style: italic;"># Add vertx to the path</span> ENV PATH <span style="color: #000000; font-weight: bold;">/</span>usr<span style="color: #000000; font-weight: bold;">/</span>local<span style="color: #000000; font-weight: bold;">/</span>vertx<span style="color: #000000; font-weight: bold;">/</span>vert.x-2.1.2<span style="color: #000000; font-weight: bold;">/</span>bin:<span style="color: #007800;">$PATH</span>   RUN <span style="color: #c20cb9; font-weight: bold;">mkdir</span> <span style="color: #660033;">-p</span> <span style="color: #000000; font-weight: bold;">/</span>usr<span style="color: #000000; font-weight: bold;">/</span>local<span style="color: #000000; font-weight: bold;">/</span>src WORKDIR <span style="color: #000000; font-weight: bold;">/</span>usr<span style="color: #000000; font-weight: bold;">/</span>local<span style="color: #000000; font-weight: bold;">/</span>src   CMD <span style="color: #7a0874; font-weight: bold;">[</span><span style="color: #ff0000;">"bash"</span><span style="color: #7a0874; font-weight: bold;">]</span></pre>
Dockerfiles are really straightforward and when you need to digg deeper there is an excellent <a href="https://docs.docker.com/reference/builder/">online reference manual</a>.

<code>FROM ubuntu:14.04</code> defines the base image which we rely on. You can find a comprehensive list of Docker base images at the <a href="https://registry.hub.docker.com/">docker hub</a>. For this example we use the one used by the <a href="https://github.com/docker/docker/blob/master/Dockerfile/">docker team</a> to build Docker.

Subsequent lines describe modifications that will be applied on top of the base image:
<ul>
	<li>Install of development tools using apt-get: openjdk, git, wget</li>
	<li>Download and install vertx</li>
	<li>Add vertx bin folder to the path</li>
	<li>Create folder /usr/local/src and make it the default working directory</li>
</ul>
Once we have copied the Dockerfile we can build the Docker image:
<pre class="bash code bash" style="font-family: inherit;">$ <span style="color: #c20cb9; font-weight: bold;">sudo</span> docker build <span style="color: #660033;">-t</span>=vertxdev .</pre>
<h5>Get the source code</h5>
The image we just built has git installed. We can use it to fetch the source code from Github:
<pre class="bash code bash" style="font-family: inherit;">$ <span style="color: #c20cb9; font-weight: bold;">sudo</span> docker run <span style="color: #660033;">-t</span> <span style="color: #660033;">--rm</span> <span style="color: #660033;">-v</span> <span style="color: #000000; font-weight: bold;">/</span>src<span style="color: #000000; font-weight: bold;">/</span>vertx<span style="color: #000000; font-weight: bold;">/</span>:<span style="color: #000000; font-weight: bold;">/</span>usr<span style="color: #000000; font-weight: bold;">/</span>local<span style="color: #000000; font-weight: bold;">/</span>src vertxdev <span style="color: #c20cb9; font-weight: bold;">git</span> clon
e https:<span style="color: #000000; font-weight: bold;">//</span>github.com<span style="color: #000000; font-weight: bold;">/</span>vert-x<span style="color: #000000; font-weight: bold;">/</span>vertx-examples.git</pre>
Note that git is run inside the container and the source code is therefore transferred there (in folder /usr/local/src precisely). To make the code persist, even after the container has been stopped and removed, we bind mount container's folder /usr/local/src to host folder /src/vertx using flag <code>-v /src/vertx/:/usr/local/src</code>. Whereas '--rm' destroy the container as soon as the <code>git clone</code> command has completed its execution.
<h5>Build and run the application</h5>
Now that the source code has been fetched we will spin up a new container that builds and runs a vertx sample: HelloWorldServer. Beware that <code>vertx run</code> both builds and executes the vertx application.
<pre class="bash code bash" style="font-family: inherit;">$ <span style="color: #c20cb9; font-weight: bold;">sudo</span> docker run <span style="color: #660033;">-d</span> <span style="color: #660033;">-v</span> <span style="color: #000000; font-weight: bold;">/</span>src<span style="color: #000000; font-weight: bold;">/</span>vertx<span style="color: #000000; font-weight: bold;">/</span>:<span style="color: #000000; font-weight: bold;">/</span>usr<span style="color: #000000; font-weight: bold;">/</span>local<span style="color: #000000; font-weight: bold;">/</span>src <span style="color: #660033;">-p</span> <span style="color: #000000;">8080</span>:<span style="color: #000000;">8080</span> vertxdev vertx run vertx-examples<span style="color: #000000; font-weight: bold;">/</span>src<span style="color: #000000; font-weight: bold;">/</span>raw<span style="color: #000000; font-weight: bold;">/</span>java<span style="color: #000000; font-weight: bold;">/</span>httphelloworld<span style="color: #000000; font-weight: bold;">/</span>HelloWorldServer.java</pre>
In opposition the previous container this one won't be destroyed when it stops, expose port 8080 <code>-p 8080:8080</code> and is run in background <code>-d</code>. To have a look at <code>vertx run</code> output:
<pre class="bash code bash" style="font-family: inherit;">$ <span style="color: #c20cb9; font-weight: bold;">sudo</span> docker logs Succeeded <span style="color: #000000; font-weight: bold;">in</span> deploying verticle</pre>
Let's test the application from the host using curl:
<pre class="bash code bash" style="font-family: inherit;">$ curl localhost:<span style="color: #000000;">8080</span> Hello World</pre>
This simple example should be sufficient to point out how fast it is to run a Docker container. The overhead of running <code>git clone</code> and <code>vertx run</code> inside a Docker container is unperceivable.

But this was a elementary environment to setup. In real life environments a Docker-only configuration has some shortcomings Vagrant can help to address.
<h3>Docker + Vagrant</h3>
Docker (actually <a href="https://github.com/docker/libcontainer/">libcontainer</a> which is a Docker module) still requires Linux kernel 3.8 or higher and x86_64 architecture. This bounds considerably the environments Docker can natively run on.

Vagrant is an open-source software that provides a method for creating repeatable development environments across a range of operating systems. Vagrant uses providers to spin up isolated virtual environments. The default provider is Virtualbox and since v1.6 <a href="http://www.vagrantup.com/blog/vagrant-1-6.html#features/">docker-based development environment</a> are supported too. Compared to other tools that can help running Docker on non Linux platforms (e.g. boot2docker), Vagrant has some important advantages:
<ul>
	<li>Configure it once and run it everywhere : Vagrant is just a Docker wrapper on systems that support Docker natively while it spins up a "host VM" to run containers on systems that don't support it. User don't have to bother wether Docker is supported natively or not : the same configuration will work on every OS.</li>
	<li>Docker hosts are not limited to boot2docker (a Virtualbox image of <a href="http://distro.ibiblio.org/tinycorelinux/">Tiny Core Linux</a>) but Debian, Ubuntu, CoreOS and other Linux distros are supported too. And can run can run on more stable VM managers than Virtualbox (e.g. VMWare).</li>
	<li>Vagrant can orchestrate Docker containers: run multiple containers concurrently and link them together</li>
</ul>
<img src="/wp-content/uploads/2015/07/diagr1.png" alt="Running Docker using Vagrant on Linux and other OSes" />

In the next three sections we will cover each of these points.

<a name="jump"></a>
<h3>Using vagrant to make Docker containers portable</h3>
Vagrant supports Docker both as <a href="https://docs.vagrantup.com/v2/providers/index.html">provider</a> that as <a href="https://docs.vagrantup.com/v2/provisioning/">provisioner</a>. But to let it automatically spin up a Docker host VM on Windows and Mac it should be used as a provider.

We are going to reuse the same Dockerfile we saw above. And, as above, we will run two Docker containers to execute <code>git clone</code> and <code>vertx run</code>. But Vagrant commands will used instead of Docker's.

Install <a href="https://www.vagrantup.com/downloads">Vagrant</a> and <a href="https://www.virtualbox.org/wiki/Downloads">Virtualbox</a> to be able to run the samples.
<h5>Vagrantfile</h5>
Vagrantfiles describe Vagrant boxes. We will use the following one along this section:
<pre class="ruby code ruby" style="font-family: inherit;">ENV<span style="color: #006600; font-weight: bold;">[</span><span style="color: #996600;">'VAGRANT_DEFAULT_PROVIDER'</span><span style="color: #006600; font-weight: bold;">]</span> = <span style="color: #996600;">'docker'</span>   Vagrant.<span style="color: #9900cc;">configure</span><span style="color: #006600; font-weight: bold;">(</span><span style="color: #996600;">"2"</span><span style="color: #006600; font-weight: bold;">)</span> <span style="color: #9966cc; font-weight: bold;">do</span> <span style="color: #006600; font-weight: bold;">|</span>config<span style="color: #006600; font-weight: bold;">|</span>   config.<span style="color: #9900cc;">vm</span>.<span style="color: #9900cc;">define</span> <span style="color: #996600;">"vertxdev"</span> <span style="color: #9966cc; font-weight: bold;">do</span> <span style="color: #006600; font-weight: bold;">|</span>a<span style="color: #006600; font-weight: bold;">|</span>     a.<span style="color: #9900cc;">vm</span>.<span style="color: #9900cc;">provider</span> <span style="color: #996600;">"docker"</span> <span style="color: #9966cc; font-weight: bold;">do</span> <span style="color: #006600; font-weight: bold;">|</span>d<span style="color: #006600; font-weight: bold;">|</span>       d.<span style="color: #9900cc;">build_dir</span> = <span style="color: #996600;">"."</span>       d.<span style="color: #9900cc;">build_args</span> = <span style="color: #006600; font-weight: bold;">[</span><span style="color: #996600;">"-t=vertxdev"</span><span style="color: #006600; font-weight: bold;">]</span>       d.<span style="color: #9900cc;">ports</span> = <span style="color: #006600; font-weight: bold;">[</span><span style="color: #996600;">"8080:8080"</span><span style="color: #006600; font-weight: bold;">]</span>       d.<span style="color: #9900cc;">name</span> = <span style="color: #996600;">"vertxdev"</span>       d.<span style="color: #9900cc;">remains_running</span> = <span style="color: #0000ff; font-weight: bold;">true</span>       d.<span style="color: #9900cc;">cmd</span> = <span style="color: #006600; font-weight: bold;">[</span><span style="color: #996600;">"vertx"</span>, <span style="color: #996600;">"run"</span>, <span style="color: #996600;">"vertx-examples/src/raw/java/httphelloworld/HelloWorldServer.java"</span><span style="color: #006600; font-weight: bold;">]</span>       d.volumes = <span style="color: #006600; font-weight: bold;">[</span><span style="color: #996600;">"/src/vertx/:/usr/local/src"</span><span style="color: #006600; font-weight: bold;">]</span>     <span style="color: #9966cc; font-weight: bold;">end</span>   <span style="color: #9966cc; font-weight: bold;">end</span> <span style="color: #9966cc; font-weight: bold;">end</span></pre>
<code>ENV<a title="'VAGRANT_DEFAULT_PROVIDER'" href="'VAGRANT_DEFAULT_PROVIDER'">'VAGRANT_DEFAULT_PROVIDER'</a> = 'docker'</code> saves us to specify, at every Vagrant command, that the provider is Docker (default provider is Virtualbox). The rest of the file has options that Vagrant will use to build the Docker image and run a container. For more information refer to <a title="Vagrantfile" href="Vagrantfile">Vagrantfile</a><a title="https://docs.vagrantup.com/v2/vagrantfile/index.html" href="https://docs.vagrantup.com/v2/vagrantfile/index.html">https://docs.vagrantup.com/v2/vagra...</a> and <a href="https://docs.vagrantup.com/v2/docker/configuration.html">Docker provider</a> documentation.
<h5>Get the source code</h5>
Once we have copied the Vagrantfile in Dockerfile folder we can run <code>git clone</code> to fetch the source code:
<pre class="bash code bash" style="font-family: inherit;">$ vagrant docker-run vertxdev <span style="color: #660033;">--</span> <span style="color: #c20cb9; font-weight: bold;">git</span> clone https:<span style="color: #000000; font-weight: bold;">//</span>github.com<span style="color: #000000; font-weight: bold;">/</span>vert-x<span style="color: #000000; font-weight: bold;">/</span>vertx-examples.git</pre>
Like before, the container will be destroyed when <code>git clone</code> ends its execution. Note that we haven't built the image, Vagrant did it automatically. On manual step less.
<h5>Build and run the application</h5>
We are able to build and run the HTTP Hello World server:
<pre class="bash code bash" style="font-family: inherit;">$ vagrant up</pre>
Under the hoods Vagrant will execute <code>docker run</code> and the command to start the container is specified by the <code>d.cmd</code> option.

To get the output of the <code>vertx run</code> command:
<pre class="bash code bash" style="font-family: inherit;">$ vagrant docker-logs ==<span style="color: #000000; font-weight: bold;">&gt;</span> vertxdev: Succeeded <span style="color: #000000; font-weight: bold;">in</span> deploying verticle</pre>
<h5>Testing</h5>
On a linux platform just run:
<pre class="bash code bash" style="font-family: inherit;">$ curl localhost:<span style="color: #000000;">8080</span> Hello World</pre>
On Windows and Mac port 8080 is not forwarded from Docker host VM to the main vagrant host (although Docker container port is forwarded to Docker host). As a consequence we need to ssh into Docker host VM to connect to the HTTP server. Let's retrieve the id of Vagrant default Docker host:
<pre class="bash code bash" style="font-family: inherit;">$ vagrant global-status <span style="color: #c20cb9; font-weight: bold;">id</span>       name     provider   state   directory <span style="color: #660033;">-------------------------------------------------------------------------------------------------------</span> c62a174  default  virtualbox running <span style="color: #000000; font-weight: bold;">/</span>Users<span style="color: #000000; font-weight: bold;">/</span>mariolet<span style="color: #000000; font-weight: bold;">/</span>.vagrant.d<span style="color: #000000; font-weight: bold;">/</span>data<span style="color: #000000; font-weight: bold;">/</span>docker-host</pre>
Once the box id retrieved we can test the HTTP server:
<pre class="bash code bash" style="font-family: inherit;">$ vagrant <span style="color: #c20cb9; font-weight: bold;">ssh</span> c62a174 <span style="color: #660033;">-c</span> <span style="color: #ff0000;">"curl localhost:8080"</span> Hello World</pre>
<h3>Haven't you said identical? How to customise the Docker host</h3>
On platforms that don't support containers, by default Vagrant spins up a Tiny Core Linux (boot2docker) Docker host. If our CI, staging or production environment don't run boot2docker (hopefully) we have a gap between the configurations of these environments. That can virtually be the cause of a production bug, impossible to identify in development environment. Let's try to fix it.

<img src="/wp-content/uploads/2015/07/diagr2.png" alt="Different Docker hosts on different environments: virtually a breach" />

As seen above, one of Vagrant main conveniences is that it let us specify a custom Docker host. In other words, we are not stucked with boot2docker and TCL.
<h5>Docker host VM Vagrantfile</h5>
We will use a new Vagrantfile to define the Docker host VM. The following one is based on Ubuntu Server 14.04 LTS:
<pre class="ruby code ruby" style="font-family: inherit;">Vagrant.<span style="color: #9900cc;">configure</span><span style="color: #006600; font-weight: bold;">(</span><span style="color: #996600;">"2"</span><span style="color: #006600; font-weight: bold;">)</span> <span style="color: #9966cc; font-weight: bold;">do</span> <span style="color: #006600; font-weight: bold;">|</span>config<span style="color: #006600; font-weight: bold;">|</span>     config.<span style="color: #9900cc;">vm</span>.<span style="color: #9900cc;">provision</span> <span style="color: #996600;">"docker"</span>     <span style="color: #008000; font-style: italic;"># The following line terminates all ssh connections. Therefore</span>   <span style="color: #008000; font-style: italic;"># Vagrant will be forced to reconnect.</span>   <span style="color: #008000; font-style: italic;"># That's a workaround to have the docker command in the PATH</span>   config.<span style="color: #9900cc;">vm</span>.<span style="color: #9900cc;">provision</span> <span style="color: #996600;">"shell"</span>, inline:     <span style="color: #996600;">"ps aux | grep 'sshd:' | awk '{print $2}' | xargs kill"</span>     config.<span style="color: #9900cc;">vm</span>.<span style="color: #9900cc;">define</span> <span style="color: #996600;">"dockerhost"</span>   config.<span style="color: #9900cc;">vm</span>.<span style="color: #9900cc;">box</span> = <span style="color: #996600;">"ubuntu/trusty64"</span>   config.<span style="color: #9900cc;">vm</span>.<span style="color: #9900cc;">network</span> <span style="color: #996600;">"forwarded_port"</span>,     guest: <span style="color: #006666;">8080</span>, host: <span style="color: #006666;">8080</span>     config.<span style="color: #9900cc;">vm</span>.<span style="color: #9900cc;">provider</span> <span style="color: #ff3333; font-weight: bold;">:virtualbox</span> <span style="color: #9966cc; font-weight: bold;">do</span> <span style="color: #006600; font-weight: bold;">|</span>vb<span style="color: #006600; font-weight: bold;">|</span>       vb.<span style="color: #9900cc;">name</span> = <span style="color: #996600;">"dockerhost"</span>   <span style="color: #9966cc; font-weight: bold;">end</span>   <span style="color: #9966cc; font-weight: bold;">end</span></pre>
Save it in the original Vagrantfile folder with name DockerHostVagrantfile.
<h5>Run Docker containers in a custom Docker host</h5>
Next specify to use this new VM as Docker host instead of the default one adding two new lines to the <code>a.vm.provider</code> block:
<pre class="ruby code ruby" style="font-family: inherit;">config.<span style="color: #9900cc;">vm</span>.<span style="color: #9900cc;">define</span> <span style="color: #996600;">"vertxdev"</span> <span style="color: #9966cc; font-weight: bold;">do</span> <span style="color: #006600; font-weight: bold;">|</span>a<span style="color: #006600; font-weight: bold;">|</span>   a.<span style="color: #9900cc;">vm</span>.<span style="color: #9900cc;">provider</span> <span style="color: #996600;">"docker"</span> <span style="color: #9966cc; font-weight: bold;">do</span> <span style="color: #006600; font-weight: bold;">|</span>d<span style="color: #006600; font-weight: bold;">|</span>     <span style="color: #006600; font-weight: bold;">[</span>...<span style="color: #006600; font-weight: bold;">]</span>     d.<span style="color: #9900cc;">vagrant_machine</span> = <span style="color: #996600;">"dockerhost"</span>     d.<span style="color: #9900cc;">vagrant_vagrantfile</span> = <span style="color: #996600;">"./DockerHostVagrantfile"</span>   <span style="color: #9966cc; font-weight: bold;">end</span> <span style="color: #9966cc; font-weight: bold;">end</span></pre>
Note that that configuring a custom docker host has another benefit: we can now specify custom forwarded ports:
<pre class="ruby code ruby" style="font-family: inherit;">config.<span style="color: #9900cc;">vm</span>.<span style="color: #9900cc;">network</span> <span style="color: #996600;">"forwarded_port"</span>,         guest: <span style="color: #006666;">8080</span>, host: <span style="color: #006666;">8080</span></pre>
As a result we are able to access the vertx HTTP server from within the main host OS:

<img src="/wp-content/uploads/2015/07/diagr3.png" alt="Identical Docker hosts on different environments and port forwarding" />

Of course host VMs are not limited to Ubuntu. More vagrant boxes can be found on <a href="https://vagrantcloud.com">Vagrant Cloud</a>. Interesting Docker-enabled boxes are hosts are boot2docker (<a href="https://vagrantcloud.com/mitchellh/boxes/boot2docker">original</a> and <a href="https://vagrantcloud.com/yungsang/boxes/boot2docker">improved</a>) and <a href="https://vagrantcloud.com/yungsang/boxes/coreos">CoresOS</a>.
<h3>Orchestrating Docker containers using Vagrant</h3>
Until now we have run one Docker container at a time. In real life however we often need to run multiple containers at the same time : database, http, web container etc...will all run in separate containers.

In this section we deal with the simultaneous execution of multiple docker containers using Vagrant <a href="https://docs.vagrantup.com/v2/multi-machine/">"multi-machine" environment</a>. However we won't consider the scenario of Docker containers distributed in distinct Docker hosts: all containers run in the same host.
<h5>Running multiple containers</h5>
<img src="/wp-content/uploads/2015/07/diagr4.png" alt="Multiple containers" />

As a first example we will use Vert.x <a href="https://github.com/vert-x/vertx-examples/tree/master/src/raw/java/eventbus_pointtopoint">Event Bus Point to Point example</a>. We exploit the same Dockerfile we defined at the beginning and configure two Docker containers within a new Vagrantfile: "vertxreceiver" and "vertxsender":
<pre class="ruby code ruby" style="font-family: inherit;">ENV<span style="color: #006600; font-weight: bold;">[</span><span style="color: #996600;">'VAGRANT_DEFAULT_PROVIDER'</span><span style="color: #006600; font-weight: bold;">]</span> = <span style="color: #996600;">'docker'</span> DOCKER_HOST_NAME = <span style="color: #996600;">"dockerhost"</span> DOCKER_HOST_VAGRANTFILE = <span style="color: #996600;">"./DockerHostVagrantfile"</span>   Vagrant.<span style="color: #9900cc;">configure</span><span style="color: #006600; font-weight: bold;">(</span><span style="color: #996600;">"2"</span><span style="color: #006600; font-weight: bold;">)</span> <span style="color: #9966cc; font-weight: bold;">do</span> <span style="color: #006600; font-weight: bold;">|</span>config<span style="color: #006600; font-weight: bold;">|</span>     config.<span style="color: #9900cc;">vm</span>.<span style="color: #9900cc;">define</span> <span style="color: #996600;">"vertxreceiver"</span> <span style="color: #9966cc; font-weight: bold;">do</span> <span style="color: #006600; font-weight: bold;">|</span>a<span style="color: #006600; font-weight: bold;">|</span>     a.<span style="color: #9900cc;">vm</span>.<span style="color: #9900cc;">provider</span> <span style="color: #996600;">"docker"</span> <span style="color: #9966cc; font-weight: bold;">do</span> <span style="color: #006600; font-weight: bold;">|</span>d<span style="color: #006600; font-weight: bold;">|</span>       d.<span style="color: #9900cc;">build_dir</span> = <span style="color: #996600;">"."</span>       d.<span style="color: #9900cc;">build_args</span> = <span style="color: #006600; font-weight: bold;">[</span><span style="color: #996600;">"-t=vertxreceiver"</span><span style="color: #006600; font-weight: bold;">]</span>       d.<span style="color: #9900cc;">name</span> = <span style="color: #996600;">"vertxreceiver"</span>       d.<span style="color: #9900cc;">remains_running</span> = <span style="color: #0000ff; font-weight: bold;">true</span>       d.<span style="color: #9900cc;">cmd</span> = <span style="color: #006600; font-weight: bold;">[</span><span style="color: #996600;">"vertx"</span>, <span style="color: #996600;">"run"</span>, <span style="color: #996600;">"vertx-examples/src/raw/java/eventbus_pointtopoint/Receiver.java"</span>,<span style="color: #996600;">"-cluster"</span><span style="color: #006600; font-weight: bold;">]</span>       d.<span style="color: #9900cc;">volumes</span> = <span style="color: #006600; font-weight: bold;">[</span><span style="color: #996600;">"/src/vertx/:/usr/local/src"</span><span style="color: #006600; font-weight: bold;">]</span>       d.<span style="color: #9900cc;">vagrant_machine</span> = <span style="color: #996600;">"#{DOCKER_HOST_NAME}"</span>       d.<span style="color: #9900cc;">vagrant_vagrantfile</span> = <span style="color: #996600;">"#{DOCKER_HOST_VAGRANTFILE}"</span>     <span style="color: #9966cc; font-weight: bold;">end</span>   <span style="color: #9966cc; font-weight: bold;">end</span>     config.<span style="color: #9900cc;">vm</span>.<span style="color: #9900cc;">define</span> <span style="color: #996600;">"vertxsender"</span> <span style="color: #9966cc; font-weight: bold;">do</span> <span style="color: #006600; font-weight: bold;">|</span>a<span style="color: #006600; font-weight: bold;">|</span>     a.<span style="color: #9900cc;">vm</span>.<span style="color: #9900cc;">provider</span> <span style="color: #996600;">"docker"</span> <span style="color: #9966cc; font-weight: bold;">do</span> <span style="color: #006600; font-weight: bold;">|</span>d<span style="color: #006600; font-weight: bold;">|</span>       d.<span style="color: #9900cc;">build_dir</span> = <span style="color: #996600;">"."</span>       d.<span style="color: #9900cc;">build_args</span> = <span style="color: #006600; font-weight: bold;">[</span><span style="color: #996600;">"-t=vertxsender"</span><span style="color: #006600; font-weight: bold;">]</span>       d.<span style="color: #9900cc;">name</span> = <span style="color: #996600;">"vertxsender"</span>       d.<span style="color: #9900cc;">remains_running</span> = <span style="color: #0000ff; font-weight: bold;">true</span>       d.<span style="color: #9900cc;">cmd</span> = <span style="color: #006600; font-weight: bold;">[</span><span style="color: #996600;">"vertx"</span>, <span style="color: #996600;">"run"</span>, <span style="color: #996600;">"vertx-examples/src/raw/java/eventbus_pointtopoint/Sender.java"</span>,<span style="color: #996600;">"-cluster"</span><span style="color: #006600; font-weight: bold;">]</span>       d.<span style="color: #9900cc;">volumes</span> = <span style="color: #006600; font-weight: bold;">[</span><span style="color: #996600;">"/src/vertx/:/usr/local/src"</span><span style="color: #006600; font-weight: bold;">]</span>       d.<span style="color: #9900cc;">vagrant_machine</span> = <span style="color: #996600;">"#{DOCKER_HOST_NAME}"</span>       d.<span style="color: #9900cc;">vagrant_vagrantfile</span> = <span style="color: #996600;">"#{DOCKER_HOST_VAGRANTFILE}"</span>     <span style="color: #9966cc; font-weight: bold;">end</span>   <span style="color: #9966cc; font-weight: bold;">end</span>   <span style="color: #9966cc; font-weight: bold;">end</span></pre>
For both docker containers, <code>vagrant_mahchine</code>, the id of the Docker host VM, is <code>dockerhost</code>. Vagrant will be smart enough to reuse the same instance of <code>dockerhost</code> to run both containers.

To start vertxsender and vertxreceiver replace the Vagrantfile with this one and run <code>vagrant up</code>:
<pre class="bash code bash" style="font-family: inherit;">$ vagrant up ... $ vagrant docker-logs ==<span style="color: #000000; font-weight: bold;">&gt;</span> vertxsender: Starting clustering... ==<span style="color: #000000; font-weight: bold;">&gt;</span> vertxsender: No cluster-host specified so using address 172.17.0.18 ==<span style="color: #000000; font-weight: bold;">&gt;</span> vertxsender: Succeeded <span style="color: #000000; font-weight: bold;">in</span> deploying verticle ==<span style="color: #000000; font-weight: bold;">&gt;</span> vertxreceiver: Starting clustering... ==<span style="color: #000000; font-weight: bold;">&gt;</span> vertxreceiver: No cluster-host specified so using address 172.17.0.19 ==<span style="color: #000000; font-weight: bold;">&gt;</span> vertxreceiver: Succeeded <span style="color: #000000; font-weight: bold;">in</span> deploying verticle ==<span style="color: #000000; font-weight: bold;">&gt;</span> vertxreceiver: Received message: <span style="color: #c20cb9; font-weight: bold;">ping</span><span style="color: #000000; font-weight: bold;">!</span> ==<span style="color: #000000; font-weight: bold;">&gt;</span> vertxsender: Received reply: pong ==<span style="color: #000000; font-weight: bold;">&gt;</span> vertxreceiver: Received message: <span style="color: #c20cb9; font-weight: bold;">ping</span><span style="color: #000000; font-weight: bold;">!</span> ==<span style="color: #000000; font-weight: bold;">&gt;</span> vertxreceiver: Received message: <span style="color: #c20cb9; font-weight: bold;">ping</span><span style="color: #000000; font-weight: bold;">!</span> ==<span style="color: #000000; font-weight: bold;">&gt;</span> vertxsender: Received reply: pong ==<span style="color: #000000; font-weight: bold;">&gt;</span> vertxsender: Received reply: pong ...</pre>
Even if vertxsender and vertxreceiver had no knowledge of each other hostname and IP address, the vertx eventbus protocol has a discovering capability that let connect senders and receivers. For applications that don't have a similar feature, Docker provide a <a href="https://docs.docker.com/userguide/dockerlinks/">container linking option</a>.
<h5>Linking containers</h5>
In this example we first run a Docker container (vertxdev) that starts up the HelloWorld web server we saw previously. Then a second container (vertxdev-client) will do an HTTP request using <code>wget</code>:
<pre class="ruby code ruby" style="font-family: inherit;">ENV<span style="color: #006600; font-weight: bold;">[</span><span style="color: #996600;">'VAGRANT_DEFAULT_PROVIDER'</span><span style="color: #006600; font-weight: bold;">]</span> = <span style="color: #996600;">'docker'</span>   Vagrant.<span style="color: #9900cc;">configure</span><span style="color: #006600; font-weight: bold;">(</span><span style="color: #996600;">"2"</span><span style="color: #006600; font-weight: bold;">)</span> <span style="color: #9966cc; font-weight: bold;">do</span> <span style="color: #006600; font-weight: bold;">|</span>config<span style="color: #006600; font-weight: bold;">|</span>     config.<span style="color: #9900cc;">vm</span>.<span style="color: #9900cc;">define</span> <span style="color: #996600;">"vertxdev"</span> <span style="color: #9966cc; font-weight: bold;">do</span> <span style="color: #006600; font-weight: bold;">|</span>a<span style="color: #006600; font-weight: bold;">|</span>     a.<span style="color: #9900cc;">vm</span>.<span style="color: #9900cc;">provider</span> <span style="color: #996600;">"docker"</span> <span style="color: #9966cc; font-weight: bold;">do</span> <span style="color: #006600; font-weight: bold;">|</span>d<span style="color: #006600; font-weight: bold;">|</span>       d.<span style="color: #9900cc;">image</span> = <span style="color: #996600;">"vertxdev:latest"</span>       d.<span style="color: #9900cc;">ports</span> = <span style="color: #006600; font-weight: bold;">[</span><span style="color: #996600;">"8080:8080"</span><span style="color: #006600; font-weight: bold;">]</span>       d.<span style="color: #9900cc;">name</span> = <span style="color: #996600;">"vertxdev"</span>       d.<span style="color: #9900cc;">remains_running</span> = <span style="color: #0000ff; font-weight: bold;">true</span>       d.<span style="color: #9900cc;">cmd</span> = <span style="color: #006600; font-weight: bold;">[</span><span style="color: #996600;">"vertx"</span>, <span style="color: #996600;">"run"</span>, <span style="color: #996600;">"vertx-examples/src/raw/java/httphelloworld/HelloWorldServer.java"</span><span style="color: #006600; font-weight: bold;">]</span>       d.<span style="color: #9900cc;">volumes</span> = <span style="color: #006600; font-weight: bold;">[</span><span style="color: #996600;">"/src/vertx/:/usr/local/src"</span><span style="color: #006600; font-weight: bold;">]</span>       d.<span style="color: #9900cc;">vagrant_machine</span> = <span style="color: #996600;">"dockerhost"</span>       d.<span style="color: #9900cc;">vagrant_vagrantfile</span> = <span style="color: #996600;">"./DockerHostVagrantfile"</span>     <span style="color: #9966cc; font-weight: bold;">end</span>   <span style="color: #9966cc; font-weight: bold;">end</span>     config.<span style="color: #9900cc;">vm</span>.<span style="color: #9900cc;">define</span> <span style="color: #996600;">"vertxdev-client"</span> <span style="color: #9966cc; font-weight: bold;">do</span> <span style="color: #006600; font-weight: bold;">|</span>a<span style="color: #006600; font-weight: bold;">|</span>     a.<span style="color: #9900cc;">vm</span>.<span style="color: #9900cc;">provider</span> <span style="color: #996600;">"docker"</span> <span style="color: #9966cc; font-weight: bold;">do</span> <span style="color: #006600; font-weight: bold;">|</span>d<span style="color: #006600; font-weight: bold;">|</span>       d.<span style="color: #9900cc;">image</span> = <span style="color: #996600;">"vertxdev:latest"</span>       d.<span style="color: #9900cc;">name</span> = <span style="color: #996600;">"vertxdev-client"</span>       d.<span style="color: #9900cc;">link</span><span style="color: #006600; font-weight: bold;">(</span><span style="color: #996600;">"vertxdev:vertxdev"</span><span style="color: #006600; font-weight: bold;">)</span>       d.<span style="color: #9900cc;">remains_running</span> = <span style="color: #0000ff; font-weight: bold;">false</span>       d.<span style="color: #9900cc;">cmd</span> = <span style="color: #006600; font-weight: bold;">[</span><span style="color: #996600;">"wget"</span>,<span style="color: #996600;">"-qO"</span>, <span style="color: #996600;">"-"</span>,<span style="color: #996600;">"--save-headers"</span>,<span style="color: #996600;">"http://vertxdev:8080"</span><span style="color: #006600; font-weight: bold;">]</span>       d.<span style="color: #9900cc;">vagrant_machine</span> = <span style="color: #996600;">"dockerhost"</span>       d.<span style="color: #9900cc;">vagrant_vagrantfile</span> = <span style="color: #996600;">"./DockerHostVagrantfile"</span>     <span style="color: #9966cc; font-weight: bold;">end</span>   <span style="color: #9966cc; font-weight: bold;">end</span>   <span style="color: #9966cc; font-weight: bold;">end</span></pre>
The important part of this new Vagrantfile is the line <code>d.link("vertxdev:vertxdev")</code>. Thanks to it, vertxdev-client will be able to resolve the hostname <code>vertxdev</code> and therefore fulfil the HTTP request using the command <code>wget
-qO - --save-headers http://vertxdev:8080</code>.

To run the containers replace the Vagrantfile with this new one and run <code>vagrant up</code>. The <code>--no-parallel</code> option ensure that vertxdev container is started before vertxdev-client.
<pre class="bash code bash" style="font-family: inherit;">$ vagrant up <span style="color: #660033;">--no-parallel</span></pre>
Have a look at logs to verify what happened:
<pre class="bash code bash" style="font-family: inherit;">$ vagrant docker-logs ==<span style="color: #000000; font-weight: bold;">&gt;</span> vertxdev: Succeeded <span style="color: #000000; font-weight: bold;">in</span> deploying verticle ==<span style="color: #000000; font-weight: bold;">&gt;</span> vertxdev-client: HTTP<span style="color: #000000; font-weight: bold;">/</span><span style="color: #000000;">1.1</span> <span style="color: #000000;">200</span> OK ==<span style="color: #000000; font-weight: bold;">&gt;</span> vertxdev-client: Content-Type: text<span style="color: #000000; font-weight: bold;">/</span>plain ==<span style="color: #000000; font-weight: bold;">&gt;</span> vertxdev-client: Content-Length: <span style="color: #000000;">11</span> ==<span style="color: #000000; font-weight: bold;">&gt;</span> vertxdev-client: ==<span style="color: #000000; font-weight: bold;">&gt;</span> vertxdev-client: Hello World</pre>
<h3>Dude where is my IDE?</h3>
Although IDEs are an important part of a development environments we haven't talked about it yet. That's because graphical application aren't usually run in Docker containers. IDE as Eclipse or IntelliJ find their natural habitat in the main host with source code shared between the host and the containers using Docker volumes. That's what this section is about.

Vagrant comes with a <code>synced_folder</code> option to share folders between the docker container and the main host:
<pre class="ruby code ruby" style="font-family: inherit;">ENV<span style="color: #006600; font-weight: bold;">[</span><span style="color: #996600;">'VAGRANT_DEFAULT_PROVIDER'</span><span style="color: #006600; font-weight: bold;">]</span> = <span style="color: #996600;">'docker'</span>   Vagrant.<span style="color: #9900cc;">configure</span><span style="color: #006600; font-weight: bold;">(</span><span style="color: #996600;">"2"</span><span style="color: #006600; font-weight: bold;">)</span> <span style="color: #9966cc; font-weight: bold;">do</span> <span style="color: #006600; font-weight: bold;">|</span>config<span style="color: #006600; font-weight: bold;">|</span>     config.<span style="color: #9900cc;">vm</span>.<span style="color: #9900cc;">synced_folder</span> <span style="color: #996600;">"."</span>, <span style="color: #996600;">"/usr/local/src"</span>     config.<span style="color: #9900cc;">vm</span>.<span style="color: #9900cc;">define</span> <span style="color: #996600;">"vertxdev-src"</span> <span style="color: #9966cc; font-weight: bold;">do</span> <span style="color: #006600; font-weight: bold;">|</span>a<span style="color: #006600; font-weight: bold;">|</span>     a.<span style="color: #9900cc;">vm</span>.<span style="color: #9900cc;">provider</span> <span style="color: #996600;">"docker"</span> <span style="color: #9966cc; font-weight: bold;">do</span> <span style="color: #006600; font-weight: bold;">|</span>d<span style="color: #006600; font-weight: bold;">|</span>       d.<span style="color: #9900cc;">build_dir</span> = <span style="color: #996600;">"."</span>       d.<span style="color: #9900cc;">build_args</span> = <span style="color: #006600; font-weight: bold;">[</span><span style="color: #996600;">"-t=vertxdev"</span><span style="color: #006600; font-weight: bold;">]</span>       d.<span style="color: #9900cc;">ports</span> = <span style="color: #006600; font-weight: bold;">[</span><span style="color: #996600;">"8080:8080"</span><span style="color: #006600; font-weight: bold;">]</span>       d.<span style="color: #9900cc;">name</span> = <span style="color: #996600;">"vertxdev-src"</span>       d.<span style="color: #9900cc;">remains_running</span> = <span style="color: #0000ff; font-weight: bold;">true</span>       d.<span style="color: #9900cc;">cmd</span> = <span style="color: #006600; font-weight: bold;">[</span><span style="color: #996600;">"vertx"</span>, <span style="color: #996600;">"run"</span>, <span style="color: #996600;">"vertx-examples/src/raw/java/httphelloworld/HelloWorldServer.java"</span><span style="color: #006600; font-weight: bold;">]</span>       d.<span style="color: #9900cc;">vagrant_machine</span> = <span style="color: #996600;">"dockerhost"</span>       d.<span style="color: #9900cc;">vagrant_vagrantfile</span> = <span style="color: #996600;">"./DockerHostVagrantfile"</span>     <span style="color: #9966cc; font-weight: bold;">end</span>   <span style="color: #9966cc; font-weight: bold;">end</span>   <span style="color: #9966cc; font-weight: bold;">end</span></pre>
In this example vertxdev-src folder <code>/usr/local/src</code> will be synced with main host Vagrantfile folder (<code>.</code>). Note that Vagrant take care of creating a Docker volume for us.

Once we have replaced the Vagrantfile with this one we can <code>git clone</code> again using vertxdev-src container:
<pre class="bash code bash" style="font-family: inherit;">$ vagrant docker-run vertxdev-src <span style="color: #660033;">--</span> <span style="color: #c20cb9; font-weight: bold;">git</span> clone https:<span style="color: #000000; font-weight: bold;">//</span>github.com<span style="color: #000000; font-weight: bold;">/</span>vert-x<span style="color: #000000; font-weight: bold;">/</span>vertx-examples.git</pre>
Once cloned, the source code will be available in both the container and the main host. Therefore we have direct access and can edit files:
<pre class="bash code bash" style="font-family: inherit;">$ <span style="color: #7a0874; font-weight: bold;">cd</span> vertx-examples<span style="color: #000000; font-weight: bold;">/</span>src<span style="color: #000000; font-weight: bold;">/</span>raw<span style="color: #000000; font-weight: bold;">/</span>java<span style="color: #000000; font-weight: bold;">/</span>httphelloworld<span style="color: #000000; font-weight: bold;">/</span> $ <span style="color: #c20cb9; font-weight: bold;">sed</span> <span style="color: #660033;">-i</span> <span style="color: #ff0000;">''</span> <span style="color: #ff0000;">'s/Hello World/I m in a docker container and I feel good/'</span> HelloWorldServer.java</pre>
To test the application run <code>vagrant up</code>:
<pre class="bash code bash" style="font-family: inherit;">$ <span style="color: #7a0874; font-weight: bold;">cd</span> - $ vagrant up $ curl localhost:<span style="color: #000000;">8080</span> I m <span style="color: #000000; font-weight: bold;">in</span> a docker container and I feel good</pre>
<h3>Conclusion</h3>
Using Vagrant to control Docker containers can be useful if dealing with a mix of different platforms: some Docker-enabled and others not. In this scenario using Vagrant makes the process of setting up an environment consistent across different platforms.

As an alternative to Vagrant, <a href="http://www.fig.sh/">Fig</a> is certainly worth checking out. Docker has has hired its main developer and <a href="https://blog.docker.com/tag/fig/">is strongly supporting it</a> as to tool to setup Docker based development environments.