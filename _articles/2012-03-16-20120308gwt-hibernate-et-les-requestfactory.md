---
ID: 113
post_title: 'GWT &#8211; Hibernate et les RequestFactory'
author: ggiamarchi
post_date: 2012-03-16 09:24:00
post_excerpt: '<p>Dans les architectures mettant en œuvre des clients <acronym title="Rich Internet Application">RIA</acronym> écrits en <a href="/index.php?tag/gwt"><acronym title="Google Web Toolkit">GWT</acronym></a>, la communication client-serveur est une problématique récurrente. Dans une telle application où le développement du client et du serveur se font tout deux en Java, le domaine métier est implémenté une seule fois et partagé entre le client et le serveur. Les objets sont échangés au moyen de l’API GWT <acronym title="Remote procedure call">RPC</acronym>, solution historique pour invoquer des services distants. Cette API met en place un mécanisme de sérialisation des données.</p> <p>L’utilisation du framework <a href="/index.php?tag/hibernate">Hibernate</a> pour gérer la persistance des objets métier rend impossible le transfert de ces objets via le mécanisme de sérialisation de GWT. Nous allons voir dans quelle mesure cette limite est contraignante ainsi que les différentes manières de traiter cette problématique.</p>'
layout: post
permalink: http://blog.zenika-offres.com/?p=113
published: true
---
<p>Dans les architectures mettant en œuvre des clients <acronym title="Rich Internet Application">RIA</acronym> écrits en <a href="/index.php?tag/gwt"><acronym title="Google Web Toolkit">GWT</acronym></a>, la communication client-serveur est une problématique récurrente. Dans une telle application où le développement du client et du serveur se font tout deux en Java, le domaine métier est implémenté une seule fois et partagé entre le client et le serveur. Les objets sont échangés au moyen de l’API GWT <acronym title="Remote procedure call">RPC</acronym>, solution historique pour invoquer des services distants. Cette API met en place un mécanisme de sérialisation des données.</p> <p>L’utilisation du framework <a href="/index.php?tag/hibernate">Hibernate</a> pour gérer la persistance des objets métier rend impossible le transfert de ces objets via le mécanisme de sérialisation de GWT. Nous allons voir dans quelle mesure cette limite est contraignante ainsi que les différentes manières de traiter cette problématique.</p>
<!--more-->
<h3>Problématique</h3> <p>GWT RPC permet d’effectuer des appels asynchrones du client vers le serveur. Tout objet transporté sur le réseau doit être sérialisable (les <a href="http://code.google.com/intl/fr-FR/webtoolkit/doc/latest/DevGuideServerCommunication.html#DevGuideSerializableTypes">règles de sérialisation</a> diffèrent un petit peu de l’API standard Java). On peut instinctivement penser qu’il nous suffit de respecter cette contrainte en rendant sérialisables tous les types impliqués dans les contrats d’interfaces pour se mettre à l'abri de toute erreur de sérialisation. C’est vrai tant que l’on conserve la maîtrise des types des objets que l’on souhaite sérialiser. Que se passe t-il si les objets à envoyer côté client sont des entités chargées depuis une base de données à l’aide de l’<acronym title="Object-relational mapping">ORM</acronym> Hibernate&nbsp;?</p> <p>Hibernate, pour rendre les classes persistantes, les instrumente en modifiant le bytecode durant l’exécution de l’application au moyen de la librairie Javassist. De cette manière, la définition des classes durant l’exécution est différente de la définition des classes issue du processus de compilation. Ce mécanisme bien qu’invisible du point de vue du développement rend impossible l’échange d’objets entre le client et le serveur au moyen du mécanisme de sérialisation.</p> <p>Plusieurs solutions existent pour contourner ce problème. Dans la suite, je vous propose de comparer plusieurs méthodes, leurs mises en œuvre, leurs avantages et inconvénients.</p> <h3>Les différentes approches</h3> <p>J’ai choisi de traiter la problématique d’intégration de GWT avec le framework Hibernate. Cependant, cette problématique existe de manière identique avec d’autres ORM et d’une manière encore plus générale la problématique existe à partir du moment où les objets à envoyer coté serveur ne sont pas sérialisables.</p> <p>Nous allons ici comparer trois approches permettant de traiter cette problématique&nbsp;:</p> <ul> <li>Le pattern <acronym title="Data Transfert Object">DTO</acronym> (Data Transfert Object)</li> <li>Le framework Gilead</li> <li>Les RequestFactory</li> </ul> <p>Je vais vous présenter chacune des approches en mettant particulièrement l’accent sur les RequestFactory car il s’agit de la solution la plus jeune, la moins connue, et certainement la moins triviale en terme de mise en œuvre.</p> <h4>Le pattern DTO</h4> <p>Il s’agit probablement de la solution la plus souvent implémentée à ce jour dans les applications GWT / Hibernate. C’est également la plus facile à définir et à mettre en place. Ce pattern d’architecture consiste à définir de nouveaux objets (appelés objets de transfert) qui sont de simples POJO. Ils ne sont pas instrumentés, ne contiennent pas d’intelligence mais seulement les données qui doivent êtres échangées entre le client et le serveur. Il est donc très facile de les rendre sérialisables afin qu’ils deviennent éligibles au transfert via des appels de services RPC.</p> <p>Souvent, les données présentent dans un <acronym title="Data Transfert Object">DTO</acronym> correspondent exactement aux données affichées à l’écran ou sur une partie de l’écran. Les <acronym title="Data Transfert Object">DTO</acronym> peuvent avoir la même structure que les objets persistés mais ce n’est pas nécessairement le cas. La représentation des objets en base de données n’est pas toujours adaptée à une utilisation coté client.</p> <p>La création et l’alimentation des <acronym title="Data Transfert Object">DTO</acronym> est en général faite de manière manuelle et reste à la charge du développeur. Cependant, il est possible d’utiliser des frameworks de mapping Objet/Objet qui permettent de définir au moyen d’un fichier de configuration XML des couples d’attributs qui doivent être mappés l’un sur l’autre. Le framework de ce type le plus connu est <a href="http://dozer.sourceforge.net/">Dozer</a>. Attention toutefois, dans certains cas l’usage de tels framework peut s'avérer être une mauvaise idée. Si par exemple, les <acronym title="Data Transfert Object">DTO</acronym> contiennent beaucoup de valeurs calculées ou si les types des attributs sont souvent différents entre les <acronym title="Data Transfert Object">DTO</acronym> et les objets persistés, la définition d’un tel mapping bien que toujours possible, peut être lourde à mettre en place et difficile à maintenir.</p> <h4>Le framework Gilead</h4> <p>La solution Gilead est présentée ici pour alimenter la discussion technique mais ce framework n’est pas une option d’avenir car il n’est plus maintenu. La dernière version (1.3.1), vieille d’un peu plus de deux ans, supporte les annotations JPA2, Hibernate 3.5 et GWT 2.0.</p> <p>La solution consiste, contrairement au pattern <acronym title="Data Transfert Object">DTO</acronym>, à rendre sérialisables les entités persistantes sans définir de nouveaux objets. Pour cela, Gilead parcours les graphes d’objets et remplace les proxys Hibernate non sérialisables par des références <code>null</code> et les implémentations spécifiques Hibernate (e.g. <code>PersistentSet</code>) par des implémentations issues de JavaSE.</p> <p>La plus-value apportée par le framework est sa capacité à stocker (soit côté serveur, soit dans les objets eux mêmes) les méta-données nécessaires à la reconstruction des graphes d’objets Hibernate. De cette manière, un objet persisté envoyé puis modifié côté client pourra sans problème être rattaché à une session Hibernate à son retour côté serveur.</p> <p>Sa mise en œuvre est plutôt simple. Elle se résume en trois points&nbsp;:</p> <ul> <li>Les entités persistantes doivent hériter de la classe <code>LightEntity</code></li> <li>Les classes d’implémentation RPC doivent hériter de <code>PersistentRemoteService</code></li> <li>Le <code>PersistentBeanManager</code> de Gilead doit être initialisé</li> </ul> <p>Il n’y a que quelques lignes de code ou de configuration à écrire pour mettre en place le mécanisme qui s’exécute ensuite de manière transparente.</p> <p>Comme annoncé en introduction, ce projet est au point mort. L'arrêt de la maintenance est intervenu à peu près au moment de l’arrivée d’une nouveauté dans GWT&nbsp;: Les RequestFactory.</p> <h4>Les RequestFactory</h4> <p>Les RequestFactory sont apparues dans la version 2.1 de GWT. Elles ont été introduites pour répondre à la problématique dont il est ici question.</p> <p>Les RequestFactory vont nous permettre de faire transiter sur le réseau les données contenues dans des objets non sérialisables. Comme son nom l’indique, le but d’une RequestFactory est de créer des requêtes. Pour cela, une API plutôt minimaliste fournie une sorte de <em>builder</em> permettant de construire une requête HTTP qui sera plus tard envoyée en POST au serveur.</p> <p>Le corps de cette requête est une chaîne de caractères au format json dans laquelle on trouve principalement les informations suivantes&nbsp;:</p> <ul> <li>Les données d'identification du service à invoquer coté serveur</li> <li>Les paramètres d'appel du service</li> <li>Les noms des propriétés correspondantes aux relations qui devront être transmises côté client</li> </ul> <p>Coté serveur, le traitement de cette requête va être délégué à une <code><a href="http://google-web-toolkit.googlecode.com/svn/javadoc/latest/com/google/web/bindery/requestfactory/server/RequestFactoryServlet.html">RequestFactoryServlet</a></code>. Celle-ci se charge de parser la requête, d’effectuer l’appel de service, puis de sérialiser le résultat dans la réponse envoyée au client.</p> <p>Par opposition au mécanisme RPC qui offre une vision service, les RequestFactory offre une vision requête. Nous verrons d’ailleurs plus tard dans un exemple que l’envoie des requêtes devra être codé explicitement par le développeur, ce qui est totalement transparent dans le cas d’un appel RPC.</p> <p>Il y
a tout de même un point commun entre les deux approches, dans les deux cas les appels serveur sont fait de manière asynchrone. Là où en RPC on utilise un <code><a href="http://google-web-toolkit.googlecode.com/svn/javadoc/latest/com/google/gwt/user/client/rpc/AsyncCallback.html">AsyncCallback</a></code> pour traiter le retour de l’appel, on utilisera un <code><a href="http://google-web-toolkit.googlecode.com/svn/javadoc/latest/com/google/web/bindery/requestfactory/shared/Receiver.html">Receiver</a></code> avec les RequestFactory.</p> <p>On lit souvent que les RequestFactory sont orientées ressources par opposition au mécanisme RPC qui est orienté services. Je ne serais pas si catégorique. Effectivement, initialement les RequestFactory étaient destinées à faciliter les opérations <acronym title="Create Read Update Delete">CRUD</acronym> sur des entités persistantes dans le cadre d’une architecture orientée ressources. Cependant, il n’y aucun inconvénient à les utiliser pour effectuer tout type d’appel de service.</p> <p>Passons maintenant à un exemple de mise en œuvre au travers d’un cas concret. L’exemple qui va suivre n’a pas vocation à être exhaustif mais simplement à mettre en avant les principales caractéristiques des RequestFactory.</p> <p>Soit le domaine métier ci-dessous. Il s’agit d’un simple annuaire dans lequel une personne peut avoir plusieurs adresses.</p> <p><img src="/wp-content/uploads/2015/07/addressbook.png" alt="AddressBook Class Diagram" style="display:block; margin:0 auto;" title="AddressBook Class Diagram" /></p> <p>Nous avons deux entités reliées par une relation qui sera déclarée <em>Lazy</em>. Il s’agit du cas le plus simple nous permettant de mettre en œuvre les RequestFactory de manière non triviale.</p> <p>Ci-dessous le code des entités coté serveur (allégé des getters et setters ainsi que des méthodes <code>equals</code> et <code>hashcode</code>).</p> <p><strong>Entité Person</strong></p> <pre class="java code java" style="font-family:inherit">@<span style="color: #000000;">Entity</span> @Table<span style="color: #000000;">&#40;</span>     name=<span style="color: #888888;">&quot;person&quot;</span>,     uniqueConstraints=@UniqueConstraint<span style="color: #000000;">&#40;</span>         name=<span style="color: #888888;">&quot;unique_firstname_lastname&quot;</span>, columnNames=<span style="color: #000000;">&#123;</span><span style="color: #888888;">&quot;firstname&quot;</span>, <span style="color: #888888;">&quot;lastname&quot;</span><span style="color: #000000;">&#125;</span>     <span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#41;</span> <span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">class</span> Person <span style="color: #000000;">&#123;</span> &nbsp; 	@Id 	@GeneratedValue 	<span style="color: #7F0055; font-weight: bold;">private</span> <span style="color: #7F0055; font-weight: bold;">int</span> id; &nbsp; 	@Version 	<span style="color: #7F0055; font-weight: bold;">private</span> <span style="color: #7F0055; font-weight: bold;">int</span> Version; &nbsp; 	<span style="color: #7F0055; font-weight: bold;">private</span> <span style="color: #000000;">String</span> firstname; 	<span style="color: #7F0055; font-weight: bold;">private</span> <span style="color: #000000;">String</span> lastname; 	<span style="color: #7F0055; font-weight: bold;">private</span> <span style="color: #000000;">String</span> phone; 	<span style="color: #7F0055; font-weight: bold;">private</span> <span style="color: #000000;">String</span> email; &nbsp; 	@OneToMany<span style="color: #000000;">&#40;</span>cascade = CascadeType.<span style="color: #000000;">ALL</span>, fetch = FetchType.<span style="color: #000000;">LAZY</span><span style="color: #000000;">&#41;</span> 	@JoinColumn<span style="color: #000000;">&#40;</span>name = <span style="color: #888888;">&quot;person_id&quot;</span><span style="color: #000000;">&#41;</span> 	<span style="color: #7F0055; font-weight: bold;">private</span> Set<span style="color: #000000;">&lt;</span>Address<span style="color: #000000;">&gt;</span> addresses; &nbsp; 	... &nbsp; <span style="color: #000000;">&#125;</span></pre> <p><strong>Entité Address</strong></p> <pre class="java code java" style="font-family:inherit">@<span style="color: #000000;">Entity</span> @Table<span style="color: #000000;">&#40;</span>name=<span style="color: #888888;">&quot;address&quot;</span><span style="color: #000000;">&#41;</span> <span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">class</span> Address <span style="color: #000000;">&#123;</span> &nbsp; 	@Id 	@GeneratedValue 	<span style="color: #7F0055; font-weight: bold;">private</span> <span style="color: #7F0055; font-weight: bold;">int</span> id; &nbsp; 	@Version 	<span style="color: #7F0055; font-weight: bold;">private</span> <span style="color: #7F0055; font-weight: bold;">int</span> Version; &nbsp; 	<span style="color: #7F0055; font-weight: bold;">private</span> <span style="color: #000000;">String</span> line1; 	<span style="color: #7F0055; font-weight: bold;">private</span> <span style="color: #000000;">String</span> line2; 	<span style="color: #7F0055; font-weight: bold;">private</span> <span style="color: #000000;">String</span> zipcode; 	<span style="color: #7F0055; font-weight: bold;">private</span> <span style="color: #000000;">String</span> city; 	<span style="color: #7F0055; font-weight: bold;">private</span> <span style="color: #000000;">String</span> state; 	<span style="color: #7F0055; font-weight: bold;">private</span> <span style="color: #000000;">String</span> country; &nbsp;      ... &nbsp; <span style="color: #000000;">&#125;</span></pre> <p>Durant l’exécution de l’application, ces entités ne seront jamais visibles coté client. En effet, une contrainte imposée par la RequestFactory est de définir des proxys qui mappent les entités existantes coté serveur. Ainsi, coté client on manipulera toujours ces proxys. L’implémentation des proxys est générée durant l’exécution par la RequestFactory.</p> <p>La création d’un proxy est simple et systématique. Il s’agit d’une interface qui étend <code><a href="http://google-web-toolkit.googlecode.com/svn/javadoc/latest/com/google/web/bindery/requestfactory/shared/EntityProxy.html">EntityProxy</a></code> et qui déclare les méthodes d'accès et de mise à jour des propriétés avec un nommage identique aux propriétés des entités en accord avec la spécification JavaBeans. L’interface est annotée par <code>@ProxyFor</code> pour indiquer le nom de la classe correspondante coté serveur.</p> <p><strong>Interface PersonProxy</strong></p> <pre class="java code java" style="font-family:inherit">@ProxyFor<span style="color: #000000;">&#40;</span>Person.<span style="color: #7F0055; font-weight: bold;">class</span><span style="color: #000000;">&#41;</span> <span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">interface</span> PersonProxy <span style="color: #7F0055; font-weight: bold;">extends</span> EntityProxy <span style="color: #000000;">&#123;</span> 	<span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">int</span> getId<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>; 	<span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">void</span> setId<span style="color: #000000;">&#40;</span><span style="color: #7F0055; font-weight: bold;">int</span> id<span style="color: #000000;">&#41;</span>; 	<span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #000000;">String</span> getFirstname<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>; 	<span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">void</span> setFirstname<span style="color: #000000;">&#40;</span><spa
n style="color: #000000;">String</span> firstname<span style="color: #000000;">&#41;</span>; 	<span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #000000;">String</span> getLastname<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>; 	<span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">void</span> setLastname<span style="color: #000000;">&#40;</span><span style="color: #000000;">String</span> lastname<span style="color: #000000;">&#41;</span>; 	<span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #000000;">String</span> getPhone<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>; 	<span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">void</span> setPhone<span style="color: #000000;">&#40;</span><span style="color: #000000;">String</span> phone<span style="color: #000000;">&#41;</span>; 	<span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #000000;">String</span> getEmail<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>; 	<span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">void</span> setEmail<span style="color: #000000;">&#40;</span><span style="color: #000000;">String</span> email<span style="color: #000000;">&#41;</span>; 	<span style="color: #7F0055; font-weight: bold;">public</span> Set<span style="color: #000000;">&lt;</span>AddressProxy<span style="color: #000000;">&gt;</span> getAddresses<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>; 	<span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">void</span> setAddresses<span style="color: #000000;">&#40;</span>Set<span style="color: #000000;">&lt;</span>AddressProxy<span style="color: #000000;">&gt;</span> addresses<span style="color: #000000;">&#41;</span>; <span style="color: #000000;">&#125;</span></pre> <p><strong>Interface AddressProxy</strong></p> <pre class="java code java" style="font-family:inherit">@ProxyFor<span style="color: #000000;">&#40;</span>Address.<span style="color: #7F0055; font-weight: bold;">class</span><span style="color: #000000;">&#41;</span> <span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">interface</span> AddressProxy <span style="color: #7F0055; font-weight: bold;">extends</span> EntityProxy <span style="color: #000000;">&#123;</span> 	<span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">int</span> getId<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>; 	<span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">void</span> setId<span style="color: #000000;">&#40;</span><span style="color: #7F0055; font-weight: bold;">int</span> id<span style="color: #000000;">&#41;</span>; 	<span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #000000;">String</span> getLine1<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>; 	<span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">void</span> setLine1<span style="color: #000000;">&#40;</span><span style="color: #000000;">String</span> line1<span style="color: #000000;">&#41;</span>; 	<span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #000000;">String</span> getLine2<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>; 	<span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">void</span> setLine2<span style="color: #000000;">&#40;</span><span style="color: #000000;">String</span> line2<span style="color: #000000;">&#41;</span>; 	<span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #000000;">String</span> getZipcode<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>; 	<span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">void</span> setZipcode<span style="color: #000000;">&#40;</span><span style="color: #000000;">String</span> zipcode<span style="color: #000000;">&#41;</span>; 	<span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #000000;">String</span> getCity<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>; 	<span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">void</span> setCity<span style="color: #000000;">&#40;</span><span style="color: #000000;">String</span> city<span style="color: #000000;">&#41;</span>; 	<span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #000000;">String</span> getState<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>; 	<span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">void</span> setState<span style="color: #000000;">&#40;</span><span style="color: #000000;">String</span> state<span style="color: #000000;">&#41;</span>; 	<span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #000000;">String</span> getCountry<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>; 	<span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">void</span> setCountry<span style="color: #000000;">&#40;</span><span style="color: #000000;">String</span> country<span style="color: #000000;">&#41;</span>; <span style="color: #000000;">&#125;</span></pre> <p>Nous allons ensuite définir la fameuse RequestFactory. Elle est unique pour toute l’application. Il s’agit d’une interface qui étend <code><a href="http://google-web-toolkit.googlecode.com/svn/javadoc/latest/com/google/web/bindery/requestfactory/shared/RequestFactory.html">RequestFactory</a></code> et qui contient des méthodes renvoyant des stubs des interfaces de services. Dans notre cas, nous aurons une seule interface de service.</p> <p><strong>La RequestFactory de l’application</strong></p> <pre class="java code java" style="font-family:inherit"><span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">interface</span> AddressBookResquestFactory <span style="color: #7F0055; font-weight: bold;">extends</span> RequestFactory <span style="color: #000000;">&#123;</span> &nbsp; 	PersonRequest personResquest<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>; &nbsp; <span style="color: #000000;">&#125;</span></pre> <p>L’interface de service étend <code><a href="http://google-web-toolkit.googlecode.com/svn/javadoc/latest/com/google/web/bindery/requestfactory/shared/RequestContext.html">RequestContext</a></code>. Elle est annotée de manière à définir la classe d’implémentation des services. Cette classe peut être l’entité elle même. C’est la solution la plus simple, c’est celle que nous allons mettre en place ici. La classe d’implémentation peut aussi être une classe DAO dédiée en définissant un <a href="http://google-web-toolkit.googlecode.com/svn/javadoc/latest/com/google/web/bindery/requestfactory/shared/ServiceLocator.html">ServiceLocator</a>. Ce point ne sera pas abordé ici.</p> <p>L’interface va comporter deux services&nbsp;:</p> <ul> <li>Pour lire un objet <code>Person</code> par son nom et prénom</li> <li>Pour sauvegarder ou mettre à jour un en base de données un objet <code>Person</code></li> </ul> <p><strong>Interface de services PersonRequest</strong></p> <pre class="java code java" style="font-family:inherit">@Service<span style="color: #000000;">&#40;</span>Perso
n.<span style="color: #7F0055; font-weight: bold;">class</span><span style="color: #000000;">&#41;</span> <span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">interface</span> PersonRequest <span style="color: #7F0055; font-weight: bold;">extends</span> RequestContext <span style="color: #000000;">&#123;</span> &nbsp; 	Request<span style="color: #000000;">&lt;</span>PersonProxy<span style="color: #000000;">&gt;</span> read<span style="color: #000000;">&#40;</span><span style="color: #000000;">String</span> firstname, <span style="color: #000000;">String</span> lastname<span style="color: #000000;">&#41;</span>; &nbsp; 	Request<span style="color: #000000;">&lt;</span>Void<span style="color: #000000;">&gt;</span> saveOrUpdate<span style="color: #000000;">&#40;</span>PersonProxy person<span style="color: #000000;">&#41;</span>; &nbsp; <span style="color: #000000;">&#125;</span></pre> <p>Comme vu précédemment, ces services sont implémentés directement dans l’entité <code>Person</code></p> <pre class="java code java" style="font-family:inherit"><span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">static</span> Person read<span style="color: #000000;">&#40;</span><span style="color: #000000;">String</span> firstname, <span style="color: #000000;">String</span> lastname<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>      <span style="color: #808080; font-style: italic;">// lecture de la personne sans ses adresses</span> <span style="color: #000000;">&#125;</span> &nbsp; <span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">static</span> <span style="color: #7F0055; font-weight: bold;">void</span> saveOrUpdate<span style="color: #000000;">&#40;</span>Person person<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>      <span style="color: #808080; font-style: italic;">// Mise à jour de la personne</span> <span style="color: #000000;">&#125;</span></pre> <p>En réalité, l’entité n’implémente pas l’interface au sens stricte, mais la classe d’implémentation doit être en phase avec l’interface. On constate que les méthodes de l’interface <code>PersonRequest</code> renvoient des objets de type Request paramétrés par le type de retour effectif des méthodes implémentées coté serveur.</p> <p><strong>NB.</strong> Le plugin Eclipse de développement GWT détecte les incohérences entre les interfaces <code>RequestContext</code> et leurs implémentations.</p> <p>Par ailleurs, les méthodes d’implémentation sont déclarées statiques car elles ne s’appliquent pas à une instance en particulier. Il est en revanche possible de définir des méthodes d’instances lorsque cela a du sens. Le cas typique est la définition d’opérations <acronym title="Create Read Update Delete">CRUD</acronym>.</p> <p>Côté serveur, il reste à déclarer dans le descripteur de déploiement de l’application Web, la servlet qui va traiter les requêtes.</p> <pre class="xml code xml" style="font-family:inherit"><span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;servlet<span style="color: #000000; font-weight: bold;">&gt;</span></span></span> 	<span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;servlet-name<span style="color: #000000; font-weight: bold;">&gt;</span></span></span>requestFactoryServlet<span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;/servlet-name<span style="color: #000000; font-weight: bold;">&gt;</span></span></span> 	<span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;servlet-class<span style="color: #000000; font-weight: bold;">&gt;</span></span></span>com.google.web.bindery.requestfactory.server.RequestFactoryServlet<span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;/servlet-class<span style="color: #000000; font-weight: bold;">&gt;</span></span></span> <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;/servlet<span style="color: #000000; font-weight: bold;">&gt;</span></span></span> &nbsp; <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;servlet-mapping<span style="color: #000000; font-weight: bold;">&gt;</span></span></span> 	<span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;servlet-name<span style="color: #000000; font-weight: bold;">&gt;</span></span></span>requestFactoryServlet<span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;/servlet-name<span style="color: #000000; font-weight: bold;">&gt;</span></span></span> 	<span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;url-pattern<span style="color: #000000; font-weight: bold;">&gt;</span></span></span>/gwtRequest<span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;/url-pattern<span style="color: #000000; font-weight: bold;">&gt;</span></span></span> <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;/servlet-mapping<span style="color: #000000; font-weight: bold;">&gt;</span></span></span></pre> <p>Afin que le client GWT puisse utiliser la RequestFactory, nous devons ajouter une ligne de déclaration dans son descripteur de module.</p> <pre class="xml code xml" style="font-family:inherit"><span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;inherits</span> <span style="color: #000066;">name</span>=<span style="color: #ff0000;">'com.google.web.bindery.requestfactory.RequestFactory'</span> <span style="color: #000000; font-weight: bold;">/&gt;</span></span></pre> <p>Le client peut maintenant instancier la RequestFactory et l’initialiser en lui passant en paramètre l’EventBus de l’application.</p> <pre class="java code java" style="font-family:inherit">AddressBookResquestFactory requestFactory = GWT.<span style="color: #000000;">create</span><span style="color: #000000;">&#40;</span>AddressBookResquestFactory.<span style="color: #7F0055; font-weight: bold;">class</span><span style="color: #000000;">&#41;</span>; requestFactory.<span style="color: #000000;">initialize</span><span style="color: #000000;">&#40;</span><span style="color: #7F0055; font-weight: bold;">new</span> SimpleEventBus<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;</pre> <h5>Envoyer une requête de lecture</h5> <p>Créons maintenant une requête pour rechercher une personne par ses nom et prénom.</p> <pre class="java code java" style="font-family:inherit">Request<span style="color: #000000;">&lt;</span>PersonProxy<span style="color: #000000;">&gt;</span> req =     requestFactory         .<span style="color: #000000;">personResquest</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>         .<span style="color: #000000;">read</span><span style="color: #000000;">&#40;</span><span style="color: #888888;">&quot;Barack&quot;</span>, <span style="color: #888888;">&quot;Obama&quot;</span><span style="color: #000000;">&#41;</span>;</pre> <p>La requête est exécutée de manière asynchrone en appelant la méthode <code>fire(Receiver)</code>. Le traitement du retour de l’appel est à implémenter dans la méthode <code>onSuccess</code>.</p> <pre class="java code java" style="font-family:inherit">req.<span style="color: #000000;">fire</span><span style="color: #000000;">&#40;</span><span style="color: #7F0055; font-weight: bold;">new</span> Receiver<span style="color: #000000;">&lt;</span>PersonProxy<span style="color: #000000;">&gt;</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> 	@Override 	<span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">void</span> onSuccess<span style="color: #0000
00;">&#40;</span>PersonProxy person<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> 		... 	<span style="color: #000000;">&#125;</span> <span style="color: #000000;">&#125;</span><span style="color: #000000;">&#41;</span>;</pre> <p>En cas d’échec, la méthode <code>onFailure(ServerFailure)</code> est appelée. Dans la classe abstraite <code>Receiver</code>, l’implémentation de cette méthode consiste à lever une <code>RuntimeException</code>.</p> <p>Si on effectue un appel à <code>person.getAddresses()</code> dans la méthode <code>onSuccess</code> on s'aperçoit que l’on obtient <code>null</code>. C’est normal me direz-vous, étant donné que l’implémentation de la méthode <code>read</code> coté serveur ne charge pas les adresses. Mais en réalité, la raison est ailleurs.</p> <p>Par défaut, la <code>RequestFactoryServlet</code> ne sérialise pas les propriétés correspondantes aux relations si ce n’est pas explicitement spécifié dans la requête. Ce qui veut dire qu’ici, même si la relation entre les entités <code>Person</code> et <code>Address</code> était déclarée <em>Eager</em> cela ne changerait absolument rien aux données reçues côté client.</p> <p>Pour cela, Il faut utiliser la méthode <code>with(String...)</code> de la classe <code>Request</code> pour indiquer les propriétés qui doivent être récupérées par le client.</p> <pre class="java code java" style="font-family:inherit">Request<span style="color: #000000;">&lt;</span>PersonProxy<span style="color: #000000;">&gt;</span> req =     requestFactory         .<span style="color: #000000;">personResquest</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>         .<span style="color: #000000;">read</span><span style="color: #000000;">&#40;</span><span style="color: #888888;">&quot;Barack&quot;</span>, <span style="color: #888888;">&quot;Obama&quot;</span><span style="color: #000000;">&#41;</span>         .<span style="color: #000000;">with</span><span style="color: #000000;">&#40;</span><span style="color: #888888;">&quot;addresses&quot;</span><span style="color: #000000;">&#41;</span>;</pre> <p>Ce qui précède soulève au moins deux questions intéressantes&nbsp;:</p> <ul> <li>Comment la <code>RequestFactoryServlet</code> va t-elle exploiter cette nouvelle information&nbsp;?</li> <li>A qui incombe la responsabilité de charger la collection d’adresses&nbsp;?</li> </ul> <p>En fait, ces deux questions sont intimement liées.</p> <p>La réponse à la première question vient assez intuitivement. La <code>RequestFactoryServlet</code> va simplement invoquer, sur l’objet de type <code>Person</code> récupéré de l’appel de service, les getters correspondants aux propriétés qui doivent être sérialisées.</p> <p>Nous savons déjà que la méthode read ne charge pas les adresses. Que se passe t-il à ce stade lors du traitement de la requête par la servlet&nbsp;? Si la session Hibernate est toujours active, la collection d’adresses sera chargée lors de l’appel du getter. Dans le cas contraire, nous serons inévitablement sanctionné par une <code>LazyInitializationException</code>.</p> <p>Évidement, changer le mode de chargement de la collection d’adresses de <em>Lazy</em> à <em>Eager</em> rendrait notre scénario passant mais ce n’est pas ce que nous souhaitons ici. En gardant la relation en mode <em>Lazy</em>, ce problème peut être traité de deux manières&nbsp;:</p> <ul> <li>En modifiant l’implémentation du service pour qu’il charge les adresses</li> <li>En faisant en sorte que la session Hibernate reste active durant toute l’exécution de la requête</li> </ul> <p>La première solution présente l’avantage de garder la maîtrise du chargement des graphes d’objets. Si par exemple, on souhaite charger les adresses par jointure en une seule requête. En mode <em>lazy</em>, le chargement des adresses sera inévitablement fait par l’envoi d’une requête supplémentaire. En revanche, en construisant la requête coté client, on peut être tenté d’omettre la clause with si on ne désire pas rapatrier les adresses. Le résultat sera conforme à l’attendu coté client mais coté serveur les adresses auront été remontées inutilement de la base de données.</p> <p>Les avantages de la deuxième solution sont les inconvénients de la première, et vice et versa. A mon sens, cette deuxième approche est celle qui permet de tirer le meilleur profit des RequestFactory. Et cela car quelle que soit la requête construite côté client&nbsp;:</p> <ul> <li>Tout risque de provoquer une <code>LazyInitializationException</code> est écarté</li> <li>Aucune donnée non désirée n’est chargée inutilement (tant que les relations sont en mode <em>lazy</em>)</li> </ul> <h5>Modifier des entités coté client</h5> <p>Si vous tentez d’invoquer un setter sur un <code>EntityProxy</code> issu d’un appel serveur, vous obtiendrez une exception du type <code>IllegalStateException</code> avec comme message <code>The AutoBean has been frozen</code>. Ce message n’est pas vraiment explicite. Ici, il faut comprendre que le proxy n’est pas éditable. Il doit préalablement être marqué comme tel.</p> <pre class="java code java" style="font-family:inherit">PersonProxy person = ... <span style="color: #000000;">PersonRequest</span> editRequest = requestFactory.<span style="color: #000000;">personResquest</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>; person = editRequest.<span style="color: #000000;">edit</span><span style="color: #000000;">&#40;</span>person<span style="color: #000000;">&#41;</span>;</pre> <p>Lorsqu’un proxy est rendu éditable, les proxy correspondants aux relations deviennent eux aussi éditables. Ensuite pour renvoyer coté serveur les données modifiées il faudra utiliser le même <code>RequestContext</code> que celui utilisé pour rendre le proxy éditable. Ici, nous envoyons une requête pour mettre à jour l’objet en base de donnée en appelant le service <code>saveOrUpdate(Person)</code>.</p> <pre class="java code java" style="font-family:inherit">editRequest.<span style="color: #000000;">saveOrUpdate</span><span style="color: #000000;">&#40;</span>person<span style="color: #000000;">&#41;</span>.<span style="color: #000000;">fire</span><span style="color: #000000;">&#40;</span><span style="color: #7F0055; font-weight: bold;">new</span> Receiver<span style="color: #000000;">&lt;</span>Void<span style="color: #000000;">&gt;</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> 	@Override 	<span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">void</span> onSuccess<span style="color: #000000;">&#40;</span><span style="color: #000000;">Void</span> response<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> 		... 	<span style="color: #000000;">&#125;</span> <span style="color: #000000;">&#125;</span><span style="color: #000000;">&#41;</span>;</pre> <p>Un des avantages de la RequestFactory réside dans le fait que seules les données modifiées depuis le chargement de l’objet seront sérialisées dans la requête envoyée au serveur et non l’objet <code>person</code> dans sa totalité. Dans beaucoup de cas, cela permet de réduire la quantité de données qui transite sur le réseau.</p> <h3>Critique des différentes approches</h3> <p>Nous avons vu trois manières de traiter la problématique d’intégration GWT/Hibernate. Laquelle choisir dans le cadre de la réalisation de votre projet&nbsp;? Cela dépend évidement du besoin.</p> <p>De tout ce qui précède, il est évident que la solution la plus flexible consiste à utiliser le pattern <acronym title="Data Transfert Object">DTO</acronym>. Mais bien que facile à mettre en place, le coût de réalisation est élevé. Beaucoup de codes répétitifs à écrire, à tester et à maintenir. Cette approche reste cependant la seule valable si la définition d
es entités persistantes n’est pas adaptée à une utilisation coté client.</p> <p>La solution Gilead est attrayante. C’est celle dont coût de mise en  œuvre est le plus faible. Il n’est pas nécessaire de définir d’autres objets que les entités, et le framework se charge de tout pour les rendre sérialisable. Évidement, il faut avoir la volonté d’utiliser les entités coté client. Malheureusement, Gilead n’étant plus maintenu, il n’est plus une solution à envisager.</p> <p>Les RequestFactory sont aujourd’hui la seule approche standard GWT pour traiter cette problématique. Leur utilisation n’est pas triviale. En comparaison avec GWT RPC, il faut un peu plus de temps pour les appréhender, mais une fois maîtrisées leur utilisation n’est pas vraiment compliquée. Cette solution impose d’écrire des proxys coté client pour chacune des entités mais comme vu précédemment, le code de ces proxys peut être déduit du code des entités. Dans le cadre d’une démarche <acronym title="Model driven architecture">MDA</acronym> par exemple, ces proxys pourraient sans aucun problème faire l’objet d’une génération de code. Comme pour Gilead, il faut souhaiter utiliser coté client des objets similaires aux entités définies coté serveur. L’utilisation du <em>lazy loading</em> par la <code>RequestFactoryServlet</code> permet de définir des services plus génériques. Un autre avantage mentionné précédemment est la réduction de la taille des données qui circulent sur le réseau.</p> <h3>Conclusion</h3> <p>Comme vu tout au long de cet article, la solution à choisir dépend clairement des besoins tant fonctionnels que techniques. Les <acronym title="Data Transfert Object">DTO</acronym>vont permettre de mettre en place des solutions plus spécialisées, tandis que les RequestFactory permettent de définir assez facilement des solutions plus génériques.</p> <p>Ces deux approches ne sont pas nécessairement exclusives. Dans un système complexe, les besoins sont souvent variés. L’approche la plus productive est certainement de tirer le meilleur de l’une et l’autre des solutions selon les cas d’utilisation. Par exemple, pour une simple saisie de formulaire qui va solliciter des services <acronym title="Create Read Update Delete">CRUD</acronym>, l’approche RequestFactory est clairement la plus adaptée alors que dans d’autres cas plus complexes l’approche <acronym title="Data Transfert Object">DTO</acronym> sera à privilégier.</p> <p>Depuis l’apparition des RequestFactory en version 2.1, il y a eu d’importantes évolutions ainsi que de nombreuses corrections. De nouvelles corrections sont également planifiées dans la version 2.5 à venir. Il s’agit donc d’une technologie vivante qui continue de s’améliorer de version en version. Elle semble promise à un bel avenir et continuera certainement de faire parler d’elle.</p> <p>L’application exemple commentée dans cet article est disponible sur <a href="https://github.com/ggiamarchi/GWTRequestFactory">github</a>.</p>