---
ID: 97
post_title: 'Introduction à RabbitMQ &#8211; RabbitMQ, le vif du sujet'
author: chebert
post_date: 2011-04-26 15:00:00
post_excerpt: |
  <p>Après avoir vu le fonctionnement d'AMQP concernant la gestion des échanges entre les différents acteurs, nous allons pouvoir entrer dans le sujet même avec une implémentation de ce protocole. SpringSource propose la sienne, <a href="www.rabbitmq.com">RabbitMQ</a>.</p>
layout: post
permalink: http://blog.zenika-offres.com/?p=97
published: true
---
<p>Après avoir vu le fonctionnement d'AMQP concernant la gestion des échanges entre les différents acteurs, nous allons pouvoir entrer dans le sujet même avec une implémentation de ce protocole. SpringSource propose la sienne, <a href="www.rabbitmq.com">RabbitMQ</a>.</p>
<!--more-->
<h2>RabbitMQ</h2> <p><br />
<img src="/wp-content/uploads/2015/07/rabbitmq_logo_strap.png" alt="rabbitmq_logo_strap.png" style="display:block; margin:0 auto;" /></p> <p>En tant qu'implémentation d'AMQP, RabbitMQ répond aux règles citées dans les billets précédents, mais il apporte aussi quelques particularités non précisées dans les spécifications.<br />
Entre autres, il sera facile de mettre en place une solution de cluster pour une meilleure tolérance de panne et une meilleure tenue de charge. Il sera aussi aisé de gérer de la sécurité au sein des utilisateurs autorisés à se connecter pour permettre la configuration ou les accès à certains éléments.<br />
RabbitMQ a aussi une capacité d'extensibilité via une panoplie de <strong>plugins</strong> ajoutant de nouvelles fonctionnalités au broker de base.</p> <p>Par défaut une instance de RabbitMQ fournit un VHost appelé <em>'/</em>', ce qui permet sans configuration supplémentaire de lancer le broker et de l'utiliser tel quel.<br />
De même, un utilisateur nommé <em>'guest</em>' dont le mot de passe est <em>'guest</em>' sera accessible. Attention cependant, celui-ci possède les droits d'administration par défaut.</p> <h2>Erlang</h2> <p><img src="/wp-content/uploads/2015/07/erlang-logo.png" alt="erlang-logo.png" style="float:left; margin: 0 1em 1em 0;" /> RabbitMQ est écrit en <a href="www.erlang.org">Erlang</a>, langage développé par Ericsson (la société connue pour tout ce qui est mobile et télécommunication) avec pour but principal le support d'applications distribuées, et la tolérance de panne.<br />
Le petit plus qui a poussé l'équipe de développement de RabbitMQ à choisir Erlang, est l'aisance avec laquelle on peut gérer un protocole réseau programmatiquement.<br />
Tout est donc fait pour avoir un système à la fois fiable et robuste.</p> <p>Afin de lancer des applications codées en Erlang, il est nécéssaire d'installer un environnement spécifique. Heureusement, Erlang est prévu pour être multi-plateformes, il est donc disponible sur la plupart des OS courants.<br />
Les utilisateurs de Windows pourront trouver un installeur sur le <a href="http://www.erlang.org/download.html">site officiel d'Erlang</a>, quant aux linuxiens, il leur suffira de l'installer via le gestionnaire de paquets de leur distribution.<br />
Les utilisateurs de Mac OS devront par contre passer par une procédure plus complexe. Le plus simple est d'utiliser <a href="http://www.macports.org/">MacPort</a>, un gestionnaire de paquets similaire à ceux disponible sous linux (APT en particulier). Il est aussi possible de compiler soi-même l'environnement, celui-ci étant <a href="http://www.erlang.org/download.html">open-source</a>.</p> <p>L'aspect multiplateformes d'Erlang, et donc de RabbitMQ, permet donc de lancer un cluster sur un environnement hétérogène. Voyons comment.</p> <h2>Lancer RabbitMQ</h2> <h3>Installation</h3> <p>Maintenant qu'Erlang est installé, il ne reste plus qu'à télécharger la dernière version de RabbitMQ, soit grâce à votre gestionnaire de paquets, soit <a href="http://www.rabbitmq.com/download.html">via le site officiel</a>.<br />
Pour commencer avec RabbitMQ, il suffira d'extraire l'archive dans un répertoire quelconque, puis de lancer l'exécutable <em>'sbin/rabbitmq-server</em>' (ou <em>'sbin/rabbitmq-server.bat</em>' sous Windows) depuis un terminal.</p> <p>Avant de détailler plus avant les options de RabbitMQ, voici un petit listing des différents exécutables disponibles dans le dossier <em>/sbin</em>&nbsp;:</p> <ul> <li><em>rabbitmq-server</em>; Exécutable qui permet de démarrer une simple instance de RabbitMQ (appellée aussi un <strong>noeud</strong>). L'option <em>'-detached</em>' va permettre de lancer l'application en arrière-plan en tant que démon.</li> <li><em>rabbitmq-multi</em>; Tout comme <em>rabbitmq-server</em>, cet exécutable permet de démarrer un noeud RabbitMQ. Cet exécutable lance plusieurs noeuds sur une seule et même machine, ce qui peut s'avérer utile pour tester sa mise en cluster.</li> <li><em>rabbitmqctl</em>; L'outil d'administration d'un noeud RabbitMQ. Grace à l'option '-n <em>node_name</em>' il sera possible de choisir sur quel noeud précisément l'on souhaite travailler (en particulier lorsque l'on travaille avec plusieurs noeuds sur une même machine). C'est cet outil qui entre autres va permettre de mettre en place un cluster.</li> </ul> <p>En résumé, pour lancer une instance de RabbitMQ il suffit d'éxécuter&nbsp;:</p> <pre> ./rabbitmq-server start -detached </pre> <h3>Gestion d'un nouvel utilisateur (et de ses droits)</h3> <p>A partir d'ici il est possible de se connecter depuis l'extérieur sur le broker et d'échanger les premiers messages. Encore une fois attention, par défaut le seul utilisateur disponible <em>'guest</em>' est administrateur. Pour des raisons de sécurité évidentes, si l'on travaille sur un système en production, il sera nécéssaire de créer un nouvel utilisateur et de supprimer les droits d'administration de guest.</p> <pre> ./rabbitmqctl add_user colin P@sSw0rd ./rabbitmqctl set_admin colin ./rabbitmqctl clear_admin guest </pre> <p>Ceci étant fait, le nouvel utilisateur n'a pour l'instant aucun droit sur les composants existants sur le broker. En effet, même s'il possède les droits d'administration généraux, il faut lui accorder précisément les droits sur un VHost en particulier.<br />
Le VHost présent par défaut est pour rappel <em>'/</em>'.</p> <p>Le système de droits fonctionne de la manière suivante&nbsp;: trois expressions régulières, correspond au nom des élément (queue, exchange) à administrer, sont définies sur un VHost. Elles permettent de définir les droits de <strong>configuration</strong>, <strong>écriture</strong> et <strong>lecture</strong>.<br />
L'écriture est la possibilité d'écrire sur les <strong>exchanges</strong> spécifiés et la lecture est la possibilité de lire sur les <strong>queues</strong> données.</p> <p>Pour donner les droits complets au nouvel utilisateur la commande à utiliser sera&nbsp;:</p> <pre> ./rabbitmqctl set_permissions colin .* .* .* </pre> <h2>Mise en place d'un cluster</h2> <p><br />
<img src="/wp-content/uploads/2015/07/RabbitMQ_Cluster.png" alt="RabbitMQ_Cluster.png" style="display:block; margin:0 auto;" /></p> <p>Maintenant un broker AMQP est lancé et est disponible. Un coup d'oeil sur le statut actuel du noeud nous permet de récupérer quelques informations qui seront importantes par la suite&nbsp;:</p> <pre> Mac-Colin:sbin Colin$ ./rabbitmqctl status Status of node 'rabbit@Mac-Colin' ... [{running_applications,[{rabbit,&quot;RabbitMQ&quot;,&quot;2.2.0&quot;},                         {os_mon,&quot;CPO  CXC 138 46&quot;,&quot;2.2.5&quot;},                         {sasl,&quot;SASL  CXC 138 11&quot;,&quot;2.1.9.2&quot;},                         {mnesia,&quot;MNESIA  CXC 138 12&quot;,&quot;4.4.15&quot;},                         {stdlib,&quot;ERTS  CXC 138 10&quot;,&quot;1.17.1&quot;},                         {kernel,&quot;ERTS  CXC 138 10&quot;,&quot;2.14.1&quot;}]},  {nodes,[{disc,['rabbit@Mac-Colin']}]},  {running_nodes,['rabbit@Mac-Colin']}] ...done. </pre> <p>Première chose, le noeud ici se nomme <em>'rabbit@Mac-Colin</em>', par défaut un noeud aura pour nom <em>'rabbit@hostname</em>'.<br />
La première partie donne les informations sur les applications (et plugins) actuellement rattachés au noeud, entre autres il est possible de voir la version actuelle de RabbitMQ (ici 2.2.0).<br />
La seconde partie plus importante dans le contexte de cluster va donner les informations sur les différents noeuds déclarés dans le système et ceux actuellement disponibles.</p> <h3>Modes d'un noeud</h3> <p>Pour l'instant dans le listing des nodes, il n'y a que <em>'rabbit@Mac-Colin</em>' qui est actuellement en mode <strong>disk</strong>. Les noeuds pourront être créés sous deux modes différents, <strong>RAM</strong> et <strong>disk</strong>.<br />
Un noeud en mode <strong>RAM</strong> ne stockera les informations que de façon volatile dans la RAM, hormis évidemment les éléments classés comme persistants (durable).<br />
Un noeud en mode <strong>disk</strong> travaillera aussi avec la RAM, mais pourra se baser sur le disque pour conserver les données.</p> <p>L'avantage du mode <strong>RAM</strong> est qu'il est plus rapide puisque tout est conservé en mémoire, seulement il est possible de perdre des données en cas de problème, le mode <strong>disk</strong> lui protège ses données en les enregistrant régulièrement.<br />
Il est conseillé d'avoir au moins un noeud en mode disk sur tout le cluster, cependant il est tout à fait possible de travailler sans aucun node en mode disk.</p> <h3>Lancement de nouvelles instances</h3> <p>Pour avoir un cluster fonctionnel, il va falloir démarrer de nouveaux noeuds.<br />
Le choix le plus classique est de démarrer RabbitMQ sur une nouvelle machine, mais il est aussi possible de lancer plusieurs instances sur une seule et unique machine.</p> <h4>Multiple machines</h4> <p>Afin de communiquer en toute sécurité, les différents noeuds vont utiliser un <strong>cookie</strong> fourni par erlang. Tous les noeuds ayant le même cookie pourront échanger sans problème. Pour ça il suffit de récupérer un de ces cookies sur une des machines ayant lancé RabbitMQ. La documentation spécifie que ce cookie est disponible dans <em>'/var/lib/rabbitmq/.erlang.cookie</em>' sous Unix ou <em>'C:Documents and SettingsCurrent UserApplication DataRabbitMQ.erlang.cookie</em>' sous Windows, seulement durant mes tests je n'ai trouvé ce fichier cookie que dans mon dossier personnel.</p> <pre> Mac-Colin:sbin Colin$ cat ~/.erlang.cookie ILJHQPNLJPLBZFCJNBIZ </pre> <p>Avec ce cookie, il est possible de démarrer les autres instances de manière à ce qu'elles puissent communiquer avec le noeud d'origine. La méthode la plus simple pour démarrer les autres noeuds est de passer le cookie par l'option '-setcookie <em>cookie</em>'.</p> <pre> Linux-Colin:sbin Colin$ ./rabbitmq-server start -detached -setcookie ILJHQPNLJPLBZFCJNBIZ </pre> <pre> BSD-Colin:sbin Colin$ ./rabbitmq-server start -detached -setcookie ILJHQPNLJPLBZFCJNBIZ </pre> <p>Une autre manière de faire serait simplement de créer/remplacer le fichier <em>'.erlang.cookie</em>' sur les autres machines avec comme contenu la chaîne de caractères.</p> <p>Les noms des noeuds ici seront respectivement <em>'rabbit@Linux-Colin</em>' et <em>'rabbit@BSD-Colin</em>'.</p> <h4>Mode multi</h4> <p>S'il n'est pas possible de lancer lancer un autre noeud sur une nouvelle machine, l'exécutable <em>'rabbitmq-multi</em>' va permettre de lancer plusieurs instances sur une seule et unique machine physique. Tout d'abord il faudra arrêter l'instance actuelle, puis démarrer autant de noeuds que nécéssaire.<br />
Les noeuds étant tous sur la même machine, et partageant le même fichier de cookie, il ne sera pas nécéssaire d'effectuer l'étape vue au dessus.</p> <pre> Mac-Colin:sbin Colin$ ./rabbitmq-server stop Mac-Colin:sbin Colin$ ./rabbitmq-multi start_all 3 #Ici trois noeuds sont créés en local </pre> <p>Dans les messages affichés à l'écran il devrait y avoir les noms des trois nodes créés, dans mon cas <em>'rabbit@Mac-Colin</em>', <em>'rabbit_1@Mac-Colin</em>' et <em>'rabbit_2@Mac-Colin</em>'. Pour administrer les noeuds via <em>rabbitmqctl</em> il faudra spécifier l'option '-n <em>node_name</em>' pour que les modifications soient appliqués sur un noeud en particulier, sinon c'est le noeud <em>'rabbit@Mac-Colin</em>' qui subira les changements.</p> <h3>Ajout des différents noeud au même cluster</h3> <p>Pour ajouter les noeuds, il n'est pas nécéssaire de couper le système, seul les nouveaux arrivants devront être purgés avant de joindre le cluster.<br />
L'instance principale ici sera <em>'rabbit@Mac-Colin</em>'.</p> <h4>Noeud en mode RAM</h4> <p>La première étape sera d'ajouter le noeud Linux au cluster en mode RAM</p> <pre> Linux-Colin:sbin Colin$ ./rabbitmqctl stop_app #Arrête l'instance de RabbitMQ sans quitter l'application Stopping node 'rabbit@Linux-Colin' ... ...done. Linux-Colin:sbin Colin$ ./rabbitmqctl reset #Vide les données qui pourraient-être présente en base/mémoire Resetting node 'rabbit@Linux-Colin' ... ...done. Linux-Colin:sbin Colin$ ./rabbitmqctl cluster rabbit@Mac-Colin #Rejoint le cluster en mode RAM Clustering node 'rabbit@Linux-Colin' with ['rabbit@Mac-Colin'] ... ...done. Linux-Colin:sbin Colin$ ./rabbitmqctl start_app #Relance l'instance de RabbitMQ qui cette fois-ci est liée au cluster .... </pre> <p>Et le résultat est visible depuis le premier noeud&nbsp;:</p> <pre> Mac-Colin:sbin Colin$ ./rabbitmqctl status Status of node 'rabbit@Mac-Colin' ... [{running_applications,[...]},  {nodes,[{disc,['rabbit@Mac-Colin']},{ram,['rabbit@Linux-Colin']}]},  {running_nodes,['rabbit@Linux-Colin','rabbit@Mac-Colin']}] ...done. </pre> <h4>Noeud en mode disk</h4> <p>Maintenant pour ajouter le noeud BSD en mode disk, la seule variante sera sur la commande cluster, qui nécessite de spécifier le nom du nouveau noeud dans la commande.</p> <pre> BSD-Colin:sbin Colin$ ./rabbitmqctl stop_app Stopping node 'rabbit@BSD-Colin' ... ...done. BSD-Colin:sbin Colin$ ./rabbitmqctl reset Resetting node 'rabbit@BSD-Colin' ... ...done. BSD-Colin:sbin Colin$ ./rabbitmqctl cluster rabbit@Mac-Colin rabbit@BSD-Colin #Rejoint le cluster en mode disk Clustering node 'rabbit@BSD-Colin' with ['rabbit@Mac-Colin', 'rabbit@BSD-Colin'] ... ...done. BSD-Colin:sbin Colin$ ./rabbitmqctl start_app ... </pre> <p>Encore une fois le résultat sera visible depuis n'importe quel noeud&nbsp;:</p> <pre> Mac-Colin:sbin Colin$ ./rabbitmqctl status Status of node 'rabbit@Mac-Colin' ... [{running_applications,[...]},  {nodes,[{disc,['rabbit@BSD-Colin','rabbit@Mac-Colin']}, {ram,['rabbit@Linux-Colin']}]},  {running_nodes,['rabbit@BSD-Colin','rabbit@Linux-Colin', 'rabbit@Mac-Colin']}] ...done. </pre> <p>Il faudra bien évidemment penser à l'option '-n <em>nodename</em>' si l'on est en mode rabbitmq-multi, et si l'on travaille via du réseau, les différentes machines devront pouvoir intéragir entre elles uniquement via leur hostname.</p> <h2>Bonus</h2> <p>Petit bonus offert par RabbitMQ concernant le fonctionnement de base de AMQP, jusqu'à présent il a été dit qu'un binding ne se faisait que entre un exchange et une queue. RabbitMQ permet d'établir un binding entre deux exchanges différents. Ainsi il est très simple d'ajouter de nouvelles fonctionnalités en parallèle, pour faire du log par exemple, sans avoir à modifier le mapping déjà existant. <img src="/wp-content/uploads/2015/07/ExchangeToExchange.png" alt="ExchangeToExchange.png" style="display:block; margin:0 auto;" /></p> <p>Le fonctionnement est très simple et se base sur les bindings que l'on pourrait avoir entre un exchange et une queue, donc rien de bien neuf et pourtant une fonctionnalité très pratique si l'on veut faire des ajouts sur une structure existante sans l'abîmer.</p> <h2>Conclusion</h2> <p>Voilà tout pour ce qui est de l'installation et l'administration de base d'un noeud RabbitMQ. Il reste encore beaucoup de choses à voir, comme Spring-AMQP qui permettra de développer des applications Java qui interagiront avec un broker AMQP, ou encore les différents plugins et possibilités offertes par RabbitMQ.</p> <p>Rob Harrop qu'on ne présente plus, sera d'ailleurs à la <a href="http://www.whatsnextparis.com/agenda.html#Harrop">What's Next Paris</a> et présentera RabbitMQ dans un contexte d'interopérabilité. Je vous invite à lire l'abstract qui est disponible dans l'agenda. En espérant vous y voir!</p>