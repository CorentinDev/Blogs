---
ID: 121
post_title: Java 8 et les Lambda
author: ocroisier
post_date: 2012-05-30 09:15:00
post_excerpt: |
  <p>La prochaine version de Java, prévue pour 2013, apportera le lot de nouveautés le plus important depuis Java 5&nbsp;: expressions lambda, "<em>public defender methods</em>", références de fonctions...</p> <p>Aujourd'hui, je vous propose de découvrir la nature, la syntaxe et les cas d'utilisation des expressions lambda (une forme de "closure"), ainsi que leur impact sur notre façon de coder.</p>
layout: post
permalink: http://blog.zenika-offres.com/?p=121
published: true
---
<p>La prochaine version de Java, prévue pour 2013, apportera le lot de nouveautés le plus important depuis Java 5&nbsp;: expressions lambda, "<em>public defender methods</em>", références de fonctions...</p> <p>Aujourd'hui, je vous propose de découvrir la nature, la syntaxe et les cas d'utilisation des expressions lambda (une forme de "closure"), ainsi que leur impact sur notre façon de coder.</p>
<!--more-->
<h3>Lambda&nbsp;?</h3> <h4>Le problème</h4> <p>En Java, il n'existe que deux types de références&nbsp;: des références vers des valeurs primitives, et des références vers des instances d'objets.</p> <pre class="java code java" style="font-family:inherit"><span style="color: #7F0055; font-weight: bold;">int</span> i = <span style="color: #cc66cc;">42</span>;       <span style="color: #808080; font-style: italic;">// Référence vers une valeur primitive</span> <span style="color: #000000;">String</span> s = <span style="color: #888888;">&quot;42&quot;</span>;  <span style="color: #808080; font-style: italic;">// Référence vers une instance</span></pre> <p>Dans d'autres langages (Groovy, Scala, Haskell...), il est également possible d'établir des références vers des <em>closures</em>, c'est-à-dire des blocs de code anonymes. <br />
Une référence de ce type peut alors, comme toutes les autres, être utilisée en tant que champ d'une classe ou en paramètre d'une méthode.</p> <p>Ce dernier usage est très répandu dans les langages fonctionnels (ou "orientés fonctionnel"). En particulier,la possibilité de passer une fonction en argument d'une autre permet leur composition, favorise leur découpage atomique, simplifie leur test, et améliore leur réutilisabilité.</p> <p>En Java, qui ne dispose pas de cette facilité, la technique qui s'en rapproche le plus consiste à définir une interface décrivant la fonctionnalité souhaitée, puis à instancier une classe (souvent anonyme) implémentant la fonctionnalité. L'instance obtenue peut alors être affectée à une référence et/ou être passée en paramètre d'une méthode.</p> <p>Mais cette façon de faire est très verbeuse, comme nous allons nous en rendre compte à l'aide de l'exemple suivant.</p> <h4>Comparaison Groovy / Java</h4> <p>Nous souhaitons afficher tous les éléments d'une liste qui satisfont un certain critère arbitraire. La méthode d'affichage étant générique, il est nécessaire de lui passer en paramètre l'algorithme de filtrage.</p> <p>Comparons les implémentations en Groovy, qui dispose des closures, et en Java, qui n'en dispose pas (encore).</p> <p>Groovy&nbsp;:</p> <pre class="groovy code groovy" style="font-family:inherit"><span style="color: #000000; font-weight: bold;">def</span> names <span style="color: #66cc66;">=</span> <span style="color: #66cc66;">&#91;</span><span style="color: #ff0000;">&quot;un&quot;</span>, <span style="color: #ff0000;">&quot;deux&quot;</span>, <span style="color: #ff0000;">&quot;trois&quot;</span>, <span style="color: #ff0000;">&quot;quatre&quot;</span><span style="color: #66cc66;">&#93;</span> &nbsp; <span style="color: #808080; font-style: italic;">// names : la collection</span> <span style="color: #808080; font-style: italic;">// filter : l'algorithme de filtrage</span> <span style="color: #000000; font-weight: bold;">def</span> printNames<span style="color: #66cc66;">&#40;</span>names, filter<span style="color: #66cc66;">&#41;</span> <span style="color: #66cc66;">&#123;</span>     <span style="color: #993399;">println</span> names.<span style="color: #663399;">findAll</span><span style="color: #66cc66;">&#40;</span>filter<span style="color: #66cc66;">&#41;</span> <span style="color: #66cc66;">&#125;</span> &nbsp; <span style="color: #808080; font-style: italic;">// Critère de filtrage, sous forme de closure</span> <span style="color: #808080; font-style: italic;">// On ne conserve que les noms courts (5 caractères max)</span> <span style="color: #000000; font-weight: bold;">def</span> isShortName <span style="color: #66cc66;">=</span> <span style="color: #66cc66;">&#123;</span>name <span style="color: #66cc66;">-&gt;</span> name.<span style="color: #663399;">size</span><span style="color: #66cc66;">&#40;</span><span style="color: #66cc66;">&#41;</span> <span style="color: #66cc66;">&lt;=</span> <span style="color: #cc66cc;">5</span><span style="color: #66cc66;">&#125;</span> &nbsp; printNames <span style="color: #66cc66;">&#40;</span>names, isShortName<span style="color: #66cc66;">&#41;</span></pre> <p>La syntaxe est claire et lisible. Notez la façon dont un bloc de code anonyme (<em>closure</em>) est directement affecté à la référence <code>isShortName</code>, puis passé en paramètre de la méthode <code>printNames()</code>.</p> <p>Maintenant, en Java&nbsp;:</p> <pre class="java code java" style="font-family:inherit"><span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">class</span> PrintNames <span style="color: #000000;">&#123;</span> &nbsp;     <span style="color: #808080; font-style: italic;">// Encapsule la définition de la méthode implémentant le critère de sélection</span>     <span style="color: #7F0055; font-weight: bold;">private</span> <span style="color: #7F0055; font-weight: bold;">interface</span> Predicate<span style="color: #000000;">&lt;</span>T<span style="color: #000000;">&gt;</span> <span style="color: #000000;">&#123;</span>         <span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">boolean</span> keep<span style="color: #000000;">&#40;</span>T element<span style="color: #000000;">&#41;</span>;     <span style="color: #000000;">&#125;</span> &nbsp;     <span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">static</span> <span style="color: #000000;">&lt;</span>T<span style="color: #000000;">&gt;</span> <span style="color: #7F0055; font-weight: bold;">void</span> printNames<span style="color: #000000;">&#40;</span>List<span style="color: #000000;">&lt;</span>T<span style="color: #000000;">&gt;</span> elements, Predicate<span style="color: #000000;">&lt;</span>T<span style="color: #000000;">&gt;</span> filter<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>         <span style="color: #7F0055;font-weight: bold;">for</span> <span style="color: #000000;">&#40;</span>T elt : elements<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>             <span style="color: #7F0055;font-weight: bold;">if</span> <span style="color: #000000;">&#40;</span>filter.<span style="color: #000000;">keep</span><span style="color: #000000;">&#40;</span>elt<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>                 <span style="color: #000000;">System</span>.<span style="color: #000000;">out</span>.<span style="color: #000000;">println</span><span style="color: #000000;">&#40;</span>elt<span style="color: #000000;">&#41;</span>;             <span style="color: #000000;">&#125;</span>         <span style="color: #000000;">&#125;</span>     <span style="color: #000000;">&#125;</span> &nbsp;     <span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">static</span> <span style="color: #7F0055; font-weight: bold;">void</span> main<span style="color: #000000;">&#40;</span><span style="color: #000000;">String</span><span style="color: #000000;">&#91;</span><span style="color: #000000;">&#93;</span> args<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> &nbsp;         List<span style="color: #000000;">&lt;</span>String<span style="color: #000000;">&gt;</span> names = <span style="color: #000000;">Arrays</span>.<span style="color: #000000;">asList</span><span style="color: #000000;">&#40;</span><span style="color: #888888;">&quot;un&quot;</span>, <span style="color: #888888;">&quot;deux&quot;</span>, <span style="color: #888888;">&quot;trois&quot;</span>, <span style="color: #888888;">&quot;quatre&quot;</span><span style="color: #000000;">&#41;</span>; &nbsp;         <span style="color: #808080; font-style: italic;">// Critère de sélection, sous forme de classe anonyme</span>         Predicate<span style="color: #000000;">&lt;</span>String<span style="color: #000000;">&gt;</span> isShortName = <span style="color: #7F0055; font-weight: bold;">new</span> Predicate<span style="color: #000000;">&lt;</span>String<span style="color: #000000;">&gt;</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>             @Override             <span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">boolean</span> keep<span style="color: #000000;">&#40;</span><span style="color: #000000;">String</span> element<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>                 <span style="color: #808080; font-style: italic;">// La seule ligne réellement utile !</span>                 <span style="color: #7F0055; font-weight: bold;">return</span> element.<span style="color: #000000;">length</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;
</span> <span style="color: #000000;">&lt;</span>= <span style="color: #cc66cc;">5</span>;             <span style="color: #000000;">&#125;</span>         <span style="color: #000000;">&#125;</span>; &nbsp;         printNames<span style="color: #000000;">&#40;</span>names, isShortName<span style="color: #000000;">&#41;</span>;     <span style="color: #000000;">&#125;</span> &nbsp; <span style="color: #000000;">&#125;</span></pre> <p>Je pense que la différence saute aux yeux. Le code Java est nettement plus verbeux, et noie la fonctionnalité métier au sein d'une masse importante de code purement technique.<br />
Voyons quelle solution Java 8 propose.</p> <h3>Les Lambda en Java 8</h3> <h4>Domaine d'application</h4> <p>Sous la pression des langages "alternatifs" et de la communauté Java, Oracle s'est enfin décidé à intégrer les <em>closures</em> dans le langage.</p> <p>Enfin... pas tout à fait.<br />
Pour des raisons de rétrocompatibilité avec le <em>type-system</em> existant, Java 8 limitera sévèrement leur domaine d'application. Les closures ne serviront en réalité qu'à simplifier l'implémentation et l'utilisation des "Interfaces SAM" ("Single Abstract Method") ou "Interfaces fonctionnelles", c'est-à-dire les interfaces ne définissant qu'une seule méthode<sup>[<a href="#pnote-343-1" id="rev-pnote-343-1">1</a>]</sup>.</p> <p>Certes, ces interfaces sont nombreuses en Java&nbsp;: <code>Runnable</code>, <code>Callable</code>, <code>Comparator</code>, <code>ActionListener</code>... Et de nombreux frameworks orientés événements (en particulier les frameworks graphiques comme Swing ou GWT) les utilisent pour déclarer des <em>callbacks</em>.<br />
Mais tout de même, on est loin de la souplesse et de la puissance des closures présentes dans les autres langages.</p> <h4>Sous le capot</h4> <p>A la compilation, les <em>closures</em> sont tout simplement compilées sous la forme de simples classes anonymes.<br />
Par exemple, le code suivant...</p> <pre class="java code java" style="font-family:inherit"><span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">class</span> CompilationTest <span style="color: #000000;">&#123;</span> &nbsp;     <span style="color: #7F0055; font-weight: bold;">interface</span> Doubler <span style="color: #000000;">&#123;</span>         <span style="color: #7F0055; font-weight: bold;">int</span> timesTwo<span style="color: #000000;">&#40;</span><span style="color: #7F0055; font-weight: bold;">int</span> x<span style="color: #000000;">&#41;</span>;     <span style="color: #000000;">&#125;</span> &nbsp;     <span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">static</span> <span style="color: #7F0055; font-weight: bold;">void</span> main<span style="color: #000000;">&#40;</span><span style="color: #000000;">String</span><span style="color: #000000;">&#91;</span><span style="color: #000000;">&#93;</span> args<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>         Doubler d = <span style="color: #000000;">&#40;</span>n<span style="color: #000000;">&#41;</span> -<span style="color: #000000;">&gt;</span> <span style="color: #000000;">&#123;</span> <span style="color: #7F0055; font-weight: bold;">return</span> n <span style="color: #000000;">*</span> <span style="color: #cc66cc;">2</span>;<span style="color: #000000;">&#125;</span>;     <span style="color: #000000;">&#125;</span> &nbsp; <span style="color: #000000;">&#125;</span></pre> <p>... est compilé sous la forme de 3 classes&nbsp;:</p> <pre> CompilationTest           # La classe de test CompilationTest$Doubler   # L'interface Doubler CompilationTest$1         # La closure implémentant Doubler </pre> <p>Si nous décompilons la classe <code>CompilationTest$1</code>, nous obtenons&nbsp;:</p> <pre> Compiled from &quot;CompilationTest.java&quot; class CompilationTest$1 implements CompilationTest$Doubler {   CompilationTest$1();   public int timesTwo(int); } </pre> <p>En descendant au niveau du bytecode, nous retrouvons bien l'opération de multiplication par deux&nbsp;:</p> <pre> public int timesTwo(int);     flags: ACC_PUBLIC     Code:       stack=2, locals=2, args_size=2          0: iload_1          1: iconst_2          2: imul          3: ireturn </pre> <p>Etudions maintenant la syntaxe.</p> <h4>Syntaxe</h4> <p>Une closure peut se concevoir comme une méthode anonyme. A ce titre, elle peut accepter des paramètres et retourner un résultat.</p> <p>Après moult tergiversations et guerres des tranchées sur la mailing-list dédiée, la syntaxe retenue est inspirée de celle de C#<sup>[<a href="#pnote-343-2" id="rev-pnote-343-2">2</a>]</sup>. Elle peut prendre deux formes&nbsp;:</p> <ul> <li><code>(paramètres) -&gt; expression_simple</code></li> <li><code>(paramètres) -&gt; { bloc_d'instructions }</code></li> </ul> <p>Exemples&nbsp;:</p> <pre class="java code java" style="font-family:inherit"><span style="color: #000000;">&#40;</span><span style="color: #7F0055; font-weight: bold;">int</span> x<span style="color: #000000;">&#41;</span> -<span style="color: #000000;">&gt;</span> x <span style="color: #000000;">*</span> <span style="color: #cc66cc;">2</span>                           #<span style="color: #cc66cc;">1</span> <span style="color: #000000;">&#40;</span><span style="color: #7F0055; font-weight: bold;">int</span> x<span style="color: #000000;">&#41;</span> -<span style="color: #000000;">&gt;</span> <span style="color: #000000;">&#123;</span> <span style="color: #7F0055; font-weight: bold;">return</span> x <span style="color: #000000;">*</span> <span style="color: #cc66cc;">2</span>; <span style="color: #000000;">&#125;</span>               #<span style="color: #cc66cc;">2</span> <span style="color: #000000;">&#40;</span><span style="color: #000000;">String</span> s<span style="color: #000000;">&#41;</span> -<span style="color: #000000;">&gt;</span> <span style="color: #000000;">&#123;</span> <span style="color: #000000;">System</span>.<span style="color: #000000;">out</span>.<span style="color: #000000;">println</span><span style="color: #000000;">&#40;</span>s<span style="color: #000000;">&#41;</span>; <span style="color: #000000;">&#125;</span>   #<span style="color: #cc66cc;">3</span> <span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> -<span style="color: #000000;">&gt;</span> <span style="color: #cc66cc;">42</span>                                   #<span style="color: #cc66cc;">4</span></pre> <p>Explications&nbsp;:</p> <ol> <li>La première expression prend un paramètre <code>x</code> de type <code>int</code>, et renvoie le double de sa valeur. Notez l'absence du mot-clé <code>return</code>&nbsp;: la valeur de l'expression est automatiquement renvoyée.</li> <li>La seconde est une variante de la première, qui utilise un bloc d'instructions. Cette fois, le mot-clé <code>return</code> est nécessaire.</li> <li>La troisième expression accepte un paramètre de type <code>String</code> mais ne renvoie rien.</li> <li>Enfin, la quatrième expression ne prend aucun paramètre, et renvoie la constante <code>42</code>.</li> </ol> <h5>Syntaxe simplifiée</h5> <p>Cette syntaxe peut être encore simplifiée dans certains cas&nbsp;:</p> <ul> <li>Si les types des paramètres peuvent être inférés, il n'est pas nécessaire de les préciser.</li> <li>Les parenthèses sont optionnelles si la <em>closure</em> n'attend qu'un seul paramètre (elles sont par contre obligatoires pour zéro paramètres).</li> </ul> <p>Les trois expressions suivantes sont donc équivalentes&nbsp;:</p> <pre class="java code java" style="font-family:inherit"><span style="color: #000000;">&#40;</span><span style="color: #000000;">String</span> s<span style="color: #000000;">&#41;</span> -<span style="color: #000000;">&gt;</span> s.<span style="color: #000000;">length</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#40;</span>s<span style="color: #000000;">&#41;</span> -<span style="color: #000000;">&gt;</span> s.<span style="color: #000000;">length</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> s -<span style="color: #000000;">&gt;</span> s.<span style="color: #000000;">length</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span></pre> <h5>Capture de variables</h5> <p>Actuellement, les classes anonymes ne peuvent accéder aux variables de leur environnement d'exécution que si celles-ci sont déclarées <code>final</code>.</p> <p>Il est toutefois prévu de relâcher quelque peu cette contrainte en Java 8, et d'autoriser également la capture des variables "effectivement finales", c'est-à-dire qui ne sont pas explicitement déclarées <code>final</code>, mais dont la valeur n'est jamais modifiée après leur première initialisation. Les <em>closures</em> bénéficieront également de cette facilité.</p> <p>Exemple&nbsp;: récupération des nombres inférieurs à 3</p> <pre class="java code java" style="font-family:inherit"><span style="color: #7F0055; font-weight: bold;">int</span> max = <span style="color: #cc66cc;">3</span>;  <span style="color: #808080; font-style: italic;">// Non final, mais &quot;effectivement final&quot;</span> List<span style="color: #000000;">&lt;</span>Integer<span style="color: #000000;">&gt;</span> nums = <span style="color: #000000;">Arrays</span>.<span style="color: #000000;">asList</span><span style="color: #000000;">&#40;</span><span style="color: #cc66cc;">1</span>, <span style="color: #cc66cc;">2</span>, <span style="color: #cc66cc;">3</span>, <span style="color: #cc66cc;">4</span>, <span style="color: #cc66cc;">5</span><span style="color: #000000;">&#41;</span>; Iterable<span style="color: #000000;">&lt;</span>Integer<span style="color: #000000;">&gt;</span> smallNums = nums.<span style="color: #000000;">filter</span><span style="color: #000000;">&#40;</span>n -<span style="color: #000000;">&gt;</span> n <span style="col
or: #000000;">&lt;</span> max<span style="color: #000000;">&#41;</span>;</pre> <h4>Les closures en action</h4> <p>Les closures servant avant tout à faciliter l'implémentation des "interfaces SAM", on peut les affecter à des références de type interface.</p> <h5>Runnable</h5> <p>Prenons l'exemple d'un <code>Runnable</code>, qui définit une unique méthode <code>run()</code>, n'acceptant aucun argument et ne renvoyant aucun résultat.</p> <p>Traditionnellement, nous l'implémentons comme ceci&nbsp;:</p> <pre class="java code java" style="font-family:inherit"><span style="color: #000000;">Runnable</span> job = <span style="color: #7F0055; font-weight: bold;">new</span> <span style="color: #000000;">Runnable</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>     @Override     <span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">void</span> run<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>         <span style="color: #000000;">System</span>.<span style="color: #000000;">out</span>.<span style="color: #000000;">println</span><span style="color: #000000;">&#40;</span><span style="color: #888888;">&quot;Hello world&quot;</span><span style="color: #000000;">&#41;</span>;     <span style="color: #000000;">&#125;</span> <span style="color: #000000;">&#125;</span>;</pre> <p>Avec les closures, nous pourrons le définir comme cela&nbsp;:</p> <pre class="java code java" style="font-family:inherit"><span style="color: #000000;">Runnable</span> job = <span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> -<span style="color: #000000;">&gt;</span> <span style="color: #000000;">&#123;</span>     <span style="color: #000000;">System</span>.<span style="color: #000000;">out</span>.<span style="color: #000000;">println</span><span style="color: #000000;">&#40;</span><span style="color: #888888;">&quot;Hello world&quot;</span><span style="color: #000000;">&#41;</span>; <span style="color: #000000;">&#125;</span>;</pre> <p>Notez que le code est considérablement simplifié, et recentré sur l'algorithme métier. La lisibilité est également meilleure.</p> <h5>ActionListener</h5> <p>Prenons un second exemple, un peu plus complexe&nbsp;: l'interface <code>ActionListener</code>, qui permet de réagir au clic sur un bouton Swing. Elle définit une méthode <code>actionPerformed(ActionEvent event)</code> - notez la présence du paramètre de type <code>ActionEvent</code>.</p> <p>Au lieu de l'affecter à une référence, nous allons cette fois la passer directement en paramètre de la méthode <code>JButton.addActionListener()</code>.</p> <p>Sans les closures&nbsp;:</p> <pre class="java code java" style="font-family:inherit"><span style="color: #000000;">JButton</span> greeterButton = <span style="color: #7F0055; font-weight: bold;">new</span> <span style="color: #000000;">JButton</span><span style="color: #000000;">&#40;</span><span style="color: #888888;">&quot;Click me !&quot;</span><span style="color: #000000;">&#41;</span>; greeterButton.<span style="color: #000000;">addActionListener</span><span style="color: #000000;">&#40;</span><span style="color: #7F0055; font-weight: bold;">new</span> <span style="color: #000000;">ActionListener</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>     @Override     <span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">void</span> actionPerformed<span style="color: #000000;">&#40;</span><span style="color: #000000;">ActionEvent</span> event<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>         <span style="color: #000000;">JOptionPane</span>.<span style="color: #000000;">showMessageDialog</span><span style="color: #000000;">&#40;</span><span style="color: #7F0055; font-weight: bold;">null</span>, <span style="color: #888888;">&quot;Hello !&quot;</span><span style="color: #000000;">&#41;</span>;     <span style="color: #000000;">&#125;</span> <span style="color: #000000;">&#125;</span><span style="color: #000000;">&#41;</span>;</pre> <p>Avec les closures&nbsp;:</p> <pre class="java code java" style="font-family:inherit"><span style="color: #000000;">JButton</span> greeterButton = <span style="color: #7F0055; font-weight: bold;">new</span> <span style="color: #000000;">JButton</span><span style="color: #000000;">&#40;</span><span style="color: #888888;">&quot;Click me !&quot;</span><span style="color: #000000;">&#41;</span>; greeterButton.<span style="color: #000000;">addActionListener</span><span style="color: #000000;">&#40;</span> event -<span style="color: #000000;">&gt;</span> <span style="color: #000000;">&#123;</span>     <span style="color: #000000;">JOptionPane</span>.<span style="color: #000000;">showMessageDialog</span><span style="color: #000000;">&#40;</span><span style="color: #7F0055; font-weight: bold;">null</span>, <span style="color: #888888;">&quot;Hello !&quot;</span><span style="color: #000000;">&#41;</span>; <span style="color: #000000;">&#125;</span><span style="color: #000000;">&#41;</span>;</pre> <h5>Comparator</h5> <p>Un dernier exemple pour la route, avec l'interface <code>Comparator&lt;T&gt;</code>, qui expose la méthode <code>int compare(T x, T y)</code>, qui accepte deux paramètres&nbsp;:</p> <pre class="java code java" style="font-family:inherit">List<span style="color: #000000;">&lt;</span>String<span style="color: #000000;">&gt;</span> strings = <span style="color: #000000;">Arrays</span>.<span style="color: #000000;">asList</span><span style="color: #000000;">&#40;</span><span style="color: #888888;">&quot;hello&quot;</span>, <span style="color: #888888;">&quot;world&quot;</span>, <span style="color: #888888;">&quot;!&quot;</span><span style="color: #000000;">&#41;</span>; <span style="color: #000000;">Collections</span>.<span style="color: #000000;">sort</span><span style="color: #000000;">&#40;</span>strings, <span style="color: #000000;">&#40;</span>s1, s2<span style="color: #000000;">&#41;</span>-<span style="color: #000000;">&gt;</span> s1.<span style="color: #000000;">compareTo</span><span style="color: #000000;">&#40;</span>s2<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>; <span style="color: #000000;">System</span>.<span style="color: #000000;">out</span>.<span style="color: #000000;">println</span><span style="color: #000000;">&#40;</span>strings<span style="color: #000000;">&#41;</span>;</pre> <h3>Principaux impacts</h3> <p>On l'a vu, le domaine d'application des expressions lambda en Java sera relativement limité.<br />
Essayons d'en faire le tour...</p> <h4>Le JDK</h4> <p>Evidemment, le premier bénéficiaire sera le JDK lui-même. Les classes pré-existantes ne seront sans doute pas adaptées, mais l'on peut d'ores et déjà voir les lambda en action dans certaines nouvelles classes ou méthodes.</p> <p>Dans la dernière "developer preview", j'ai dénombré les usages suivants&nbsp;:</p> <ul> <li><code>java.lang.MapStream</code> (nouvelle classe)</li> <li><code>java.util.Arrays</code> (nouvelle méthode <code>iterable()</code>, et nouvelle classe interne <code>ArraySplittable</code>)</li> <li><code>java.util.ParallelIterables</code> (nouvelle classe, fonctionne avec Fork/Join pour réaliser des opérations en parallèle sur les éléments d'une collection)</li> </ul> <p>Ainsi que dans le tout nouveau package <code>java.util.functions</code>, dédié à la programmation fonctionnelle&nbsp;:</p> <ul> <li><code>java.util.functions.Blocks</code> (nouvelle classe utilitaire pour manipuler des <code>Block</code>s)</li> <li><code>java.util.functions.Mappers</code> (nouvelle classe utilitaire pour manipuler des <code>Mapper</code>s)</li> <li><code>java.util.functions.Predicates</code> (nouvelle classe utilitaire pour manipuler des <code>Predicate</code>s)</li> </ul> <h4>Les frameworks orientés événements</h4> <p>Les interfaces à méthode unique sont très utilisées, dans les frameworks orientés événements (en particulier des frameworks graphiques), pour implémenter des <em>callbacks</em>. On pourrait donc s'attendre à ce que les lambda y trouvent un terrain d'application naturel.</p> <h5>AWT /Swing</h5> <p>Le package <code>java.awt.event</code> regroupe toutes les interfaces permettant de répondre aux événements graphiques.</p> <p>Sur les 18 interfaces, 8 seulement ne définissent qu'une seule méthode, et sont donc éligibles au titre d'"Interface SAM" (dont <code>ActionListener</code> déjà vu plus haut). Les autres interfaces définissent plusieurs méthodes, et ne seront donc pas implémentables sous forme d'expression lambda.</p> <p>Côté Swing, l'étude du package <code>javax.swing.event</code> aboutit au même constat&nbsp;: seulement 9 interfaces sur 23 sont éligibles.</p> <p>Un intérêt mitigé côté AWT/Swing, donc.<br /></p> <p>Un exemple d'utilisation&nbsp;:</p> <pre class="java code java" style="font-family:inherit"><span style="color: #000000;">JButton</span> greeterButton = <span style="color: #7F0055; font-weight: bold;">new</span> <span style="color: #000000;">JButton</span><span style="color: #000000;">&#40;</span><span style="color: #888888;">&quot;Click me !&quot;</span><span style="color: #000000;">&#41;</span>; greeterButton.<span style="color: #000000;">addActionListener</span><span style="color: #000000;">&#40;</span> <span style="color: #000000;">&#40;</span>event<span style="color: #000000;">&#41;</span> -<span style="color: #000000;">&gt;</span> <span style="color: #000000;">&#123;</span>     <span style="color: #000000;">JOptionPane</span>.<span style="color: #000000;">showMessageDialog</span><span style="color: #000000;">&#40;</span><span style="color: #7F0055; font-weight: bold;">null</span>, <span style="color: #888888;">&quot;Hello !&quot;</span><span style="color: #000000;">&#41;</span>; <span style="color: #000000;">&#125;</span><span style="color: #000000;">&#41;</span>;</pre> <h5>Wicket</h5> <p>Wicket est un framework web orienté composants, ressemblant à Swing par bien des aspects.</p> <p>Malheureusement, son modèle de <em>callback</em> est complètement différent&nbsp;: ceux-ci sont définis comme des méthodes internes aux composants graphiques, que le développeur doit surcharger.</p> <p>Par exemple, pour réagir au clic sur un lien&nbsp;:</p> <pre class="java code java" style="font-family:inherit">Link link = <span style="color: #7F0055; font-weight: bold;">new</span> Link<span style="color: #000000;">&#40;</span><span style="color: #888888;">&quot;linkId&quot;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>     <span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">void</span> onClick<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>         <span style="color: #808080; font-style: italic;">// ...</span>     <span style="color: #000000;">&#125;</span> <span style="color: #000000;">&#41;</span>;</pre> <p>A moins d'un changement majeur dans l'architecture du framework, il sera impossible d'utiliser les expressions lambda pour simplifier le déveoppement d'applications avec Wicket.</p> <h5>GWT</h5> <p>Le cas GWT est intéressant.</p> <p>Contrairement à Wicket, ce framework de RIA utilise bien des interfaces pour gérer les callbacks&nbsp;:</p> <pre class="java code java" style="font-family:inherit"><span style="color: #000000;">Button</span> button = <span style="color: #7F0055; font-weight: bold;">new</span> <span style="color: #000000;">Button</span><span style="color: #000000;">&#40;</span><span style="color: #888888;">&quot;Click me !&quot;</span><span style="color: #000000;">&#41;</span>; button.<span style="color: #000000;">addClickListener</span><span style="color: #000000;">&#40;</span><span style="color: #7F0055; font-weight: bold;">new</span> ClickListener<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>     <span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">void</span> onClick<span style="color: #000000;">&#40;</span>Widget sender<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>        <span style="color: #000000;">Window</span>.<span style="color: #000000;">alert</span><span style="color: #000000;">&#40;</span><span style="color: #888888;">&quot;Hello, world&quot;</span><span style="color: #000000;">&#41;</span>;     <span style="color: #000000;">&#125;</span> <span style="color: #000000;">&#125;</span><span style="color: #000000;">&#41;</span>;</pre> <p>GWT pourrait donc être un excellent candidat pour les expressions lambda&nbsp;:</p> <pre class="java code java" style="font-family:inherit"><span style="color: #000000;">Button</span> button = <span style="color: #7F0055; font-weight: bold;">new</span> <span style="color: #000000;">Button</span><span style="color: #000000;">&#40;</span><span style="color: #888888;">&quot;Click me !&quot;</span><span style="color: #000000;">&#41;</span>; button.<span style="color: #000000;">addClickListener</span><span style="color: #000000;">&#40;</span> sender -<span style="color: #000000;">&gt;</span> <span style="color: #000000;">&#123;</span>    <span style="color: #000000;">Window</span>.<span style="color: #000000;">alert</span><span style="color: #000000;">&#40;</span><span style="color: #888888;">&quot;Hello, again&quot;</span><span style="color: #000000;">&#41;</span>; <span style="color: #000000;">&#125;</span><span style="color: #000000;">&#41;</span>;</pre> <p>Mais le code GWT n'est pas exécuté tel quel&nbsp;: il est d'abord traduit en Javascript. La capacité d'utiliser des expressions lambda dépendra donc directement de leur prise en compte dans le traducteur Java vers Javascript...</p> <p>Vu le travail que cela représente et le gain somme toute modéré qu'on peut en attendre, je doute que cette fonctionnalité soit jamais implémentée. <em>Wait &amp; see</em>...</p> <h4>Dans nos projets</h4> <p>Pour finir, il sera naturellement possible d'intégrer le support des expressions lambda dans nos projets, partout où nous aurons défini des interfaces compatibles SAM.</p> <p>Certains use-cases s'y prêteront plus naturellement, comme les <em>callbacks</em> ou <em>handlers</em>. Certains usages plus créatifs émergeront certainement avec le temps<sup>[<a href="#pnote-343-3" id="rev-pnote-343-3">3</a>]</sup>.</p> <h3>Conclusion</h3> <p>Le support des <em>closures</em> en Java était attendu impatiemment. Prévues pour Java 7 à l'origine, elles seront finalement disponibles en Java 8, d
ont la sortie est prévue pour l'année prochaine.</p> <p>Leur implémentation, sous forme d'expressions lambda, me paraît toutefois très décevante. <br />
Leur domaine d'application, strictement limité à l'implémentation d'interfaces à méthode unique, est en définitive très restreint.</p> <p>Les changements les plus significatifs sont à attendre du côté des collections, qui gagneront des méthodes empruntées à la programmation fonctionnelle. Pour le reste du code, les gains semblent moins évidents.</p> <p>Encore une fois, je ne doute pas que la communauté s'emparera de ce nouvel outil, et saura en tirer la quintessence. Vivement Java 8&nbsp;!</p> <h3>Références</h3> <p>Quelques références utiles&nbsp;:</p> <ul> <li><a href="http://jdk8.java.net/lambda/">Java 8 developer preview</a></li> <li><a href="http://cr.openjdk.java.net/~briangoetz/lambda/lambda-state-4.html">State of the lambda</a>, par Brian Goetz.</li> </ul> <div class="footnotes"><h4>Notes</h4> <p>[<a href="#rev-pnote-343-1" id="pnote-343-1">1</a>] Une seule méthode propre, c'est-à-dire hors méthodes héritées d'Object, et hors "defender methods". Par exemple, <code>java.util.Comparable</code> définit deux "defender methods" en plus de la méthode <code>compare()</code>, mais est bien considéré comme une "Interface SAM".</p> <p>[<a href="#rev-pnote-343-2" id="pnote-343-2">2</a>] A titre personnel, j'aurais préféré la syntaxe de Groovy. Mais <em>de gustibus non est disputandum</em>...</p> <p>[<a href="#rev-pnote-343-3" id="pnote-343-3">3</a>] Voir par exemple l'article de François Sarradin : <a href="http://kerflyn.wordpress.com/2012/05/09/towards-pattern-matching-in-java">Towards pattern matching in Java</a></p></div> 