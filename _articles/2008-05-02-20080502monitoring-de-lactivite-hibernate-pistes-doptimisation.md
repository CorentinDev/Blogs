---
ID: 475
post_title: >
  Monitoring de l’activité Hibernate,
  pistes d’optimisation
author: Carl Azoury
post_date: 2008-05-02 15:55:00
post_excerpt: |
  <p>Cet article présente comment rendre plus transparente l’activité d’Hibernate afin de détecter un éventuel défaut de comportement de son application.</p> <p>La persistance transparente est une fonctionnalité puissante mais qui mérite d’être surveillée. Combien d’objets, et de quel type, ont été chargés par l’application&nbsp;? Quel objet a été modifié&nbsp;? Quelle est la propriété qui a changé&nbsp;? Quelle était la valeur avant la mise à jour et quelle est la nouvelle valeur&nbsp;? Combien de requêtes SQL et quel temps d’exécution&nbsp;? <br />
  Autant de questions auxquelles tente de répondre ZenTracker un outil de monitoring.</p>
layout: post
permalink: http://blog.zenika-offres.com/?p=475
published: true
---
<p>Cet article présente comment rendre plus transparente l’activité d’Hibernate afin de détecter un éventuel défaut de comportement de son application.</p> <p>La persistance transparente est une fonctionnalité puissante mais qui mérite d’être surveillée. Combien d’objets, et de quel type, ont été chargés par l’application&nbsp;? Quel objet a été modifié&nbsp;? Quelle est la propriété qui a changé&nbsp;? Quelle était la valeur avant la mise à jour et quelle est la nouvelle valeur&nbsp;? Combien de requêtes SQL et quel temps d’exécution&nbsp;? <br />
Autant de questions auxquelles tente de répondre ZenTracker un outil de monitoring.</p>
<!--more-->
<h3>ZenTracker</h3> <p>Cet outil s’insère dans la mécanique d’Hibernate via les API <code>Interceptor</code> et <code>Listener</code>. Il est disponible sur <a href="http://code.google.com/p/zentracker/">GoogleCode</a> en <a href="http://code.google.com/p/zentracker/downloads/list">téléchargement</a>  Utiliser cet outil consiste à passer à la <code>Session</code> Hibernate un <code>Interceptor</code> qui va se charger de collecter des informations sur l’activité. Information qui sera journalisée au moment de la complétion de la transaction. L’intercepteur étant un objet avec état, il en faut une nouvelle instance pour chaque nouvelle <code>Session</code> Hibernate.<br />
Cet outil ne fonctionne qu’à partir de la version 3.2.0 d’Hibernate.</p> <pre class="java code java" style="font-family:inherit"><ol><li style="font-weight: normal;"><div style="font-family: monospace; font-weight: normal; font-style: normal; margin:0; padding:0; background:inherit;"><span style="color: #808080; font-style: italic;">// Opening Session with a fresh instance of the Interceptor</span></div></li><li style="font-weight: normal;"><div style="font-family: monospace; font-weight: normal; font-style: normal; margin:0; padding:0; background:inherit;">SessionStatisticsInterceptor interceptor = <span style="color: #7F0055; font-weight: bold;">new</span> SessionStatisticsInterceptor<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;</div></li><li style="font-weight: normal;"><div style="font-family: monospace; font-weight: normal; font-style: normal; margin:0; padding:0; background:inherit;">Session session = sessionFactory.<span style="color: #000000;">openSession</span><span style="color: #000000;">&#40;</span>interceptor<span style="color: #000000;">&#41;</span>;</div></li></ol></pre> <p>Dans le cas ou la <code>Session</code> est utilisée sans démarrer de transaction, il faut récupérer l’intercepteur au moment de la fermeture de la <code>Session</code> et déclencher la journalistation manuellement par la méthode <code>logSummary()</code>.</p> <h3>Configuration</h3> <p>1. Ajouter le jar zentracker.jar au classpath</p> <p>2. Déclarer deux propriétés&nbsp;:</p> <pre> hibernate.jdbc.factory_class=com.zenika.zentracker.hibernate.jdbc.ZenTrackerBatchingFactory &lt;listener type=”flush-entity” class=”com.zenika.zentracker.hibernate.listener.EntityCheckDirtyListener”/&gt; </pre> <p>La propriété <code>factory_class</code> peut être déclarée soit dans le fichier <code>hibernate.properties</code>, soit dans le fichier <code>hibernate.cfg.xml</code>. Le listener doit être déclarée dans le fichier <code>hibernate.cfg.xml</code>.</p> <p>3. Modifier le fichier <code>log4j.properties</code>&nbsp;:</p> <pre> # Loggers used by the ZenTracker tool log4j.logger.com.zenika.ZenTracker=debug </pre> <p>4. Déclarer l’intercepteur au moment de la création d’une nouvelle <code>Session</code>. L’intercepteur possède un état, il en faut un pour chaque nouvelle instance de <code>Session</code>.</p> <h3>Utilisation</h3> <h4>Comment tracer la modification d’une entité&nbsp;?</h4> <p>Le <em>listener</em> <code>EntityCheckDirtyListener</code> va se déclencher après celui d’Hibernate après que celui-ci ai déterminé la liste des propriétés "<em>dirty</em>". Toutes les propriétés modifiées sont ainsi tracées. La trace sera de la forme suivante&nbsp;:</p> <pre>     ZenTracker - Entity [City [NewCityName]] with ID [9] has the following dirty property [name] Previous value was [London], current value is [NewCityName] </pre> <h4>Que veut dire surveiller l’activité des entités par type&nbsp;?</h4> <p>Quand une entité est chargée, mise à jour, supprimée, créée elle sera tracée par l’intercepteur. A la complétion de la transaction il sera possible de savoir combien une entité d’un type donnée a été chargée.</p> <pre> ZenTracker - Entity &lt;class com.zenika.sample.model.Continent&gt; loaded 2 times ZenTracker - Entity &lt;class com.zenika.sample.model.City&gt; loaded 70 times ZenTracker - Entity &lt;class com.zenika.sample.model.Country&gt; loaded 10 times </pre> <h4>Et les collections&nbsp;?</h4> <p>Il sera possible de connaître l’activité au niveau d’une collection. Dans la trace ci dessous, on peut voir par exemple que la collection countries du Continent Asie a été modifiée au premier flush avec un retrait de deux pays, et qu’au troisième flush un nouveau pays a été ajouté.</p> <pre> ZenTracker - COLLECTION [3 - com.zenika.sample.model.Continent.countries] for Entity Continent [Asie] has been modified ! ZenTracker - During flush &lt;1&gt; REMOVED : &lt;Country [Russie]&gt; &lt;Country [Japon]&gt; ZenTracker - During flush &lt;3&gt; ADDED : &lt;Country [Zenika]&gt; </pre> <h4>Et en ce qui concerne le temps d’exécution des requêtes&nbsp;?</h4> <p>Sans ajout d’un outil tierce, il est possible d’accéder à toutes les requêtes SQL, savoir combien de fois elles ont été exécutées ainsi que les temps d’exécution (min, max, moyenne)</p> <pre> ZenTracker - Query &lt;select cities0_.COUNTRY_ID as COUNTRY3_1_, cities0_.id as id1_, cities0_.id as id2_0_, cities0_.name as name2_0_, cities0_.COUNTRY_ID as COUNTRY3_2_0_ from CITY cities0_ where cities0_.COUNTRY_ID=?&gt; executed: 10 times. average: 1 min: 0 max: 7 </pre>