---
ID: 101
post_title: Error handling with REST
author: Arnaud Cogolu√®gnes
post_date: 2011-05-23 10:55:00
post_excerpt: |
  <p>When I teach REST as part of the <a href="http://www.springsource.com/training/course?courseID=17833">Enterprise Integration with Spring training</a>, a question comes up quite often: how to deal with errors? People try to map what they're used to doing with SOAP web services, and they don't see the equivalent in REST. This post covers the basics of error handling in REST and shows how to implement them with Spring MVC.</p>
layout: post
permalink: http://blog.zenika-offres.com/?p=101
published: true
---
<p>When I teach REST as part of the <a href="http://www.springsource.com/training/course?courseID=17833">Enterprise Integration with Spring training</a>, a question comes up quite often: how to deal with errors? People try to map what they're used to doing with SOAP web services, and they don't see the equivalent in REST. This post covers the basics of error handling in REST and shows how to implement them with Spring MVC.</p>
<!--more-->
<h2>Everything is in the HTTP response...</h2> <p>When a client sends a request to a HTTP server, the server answers with... a HTTP response. A HTTP response is made of the following:</p> <ul> <li>a status line</li> <li>HTTP headers</li> <li>content (the body)</li> </ul> <p>Today, we're interested in the <em>status line</em>.</p> <h2>What is the status line in a HTTP response?</h2> <p>The status line should be enough for the client to know how its request was processed (or at least to have an idea). This is an example of a status line:</p> <pre> HTTP/1.1 200 OK </pre> <p>There are three elements in the status line:</p> <ul> <li>the version of HTTP used</li> <li>the status code</li> <li>a short description of the status code</li> </ul> <p>Believe it or not, but this is enough to deal with errors in REST... well, almost. The trick is to know which status code to use when responding to the client.</p> <h2>Status codes at the rescue</h2> <p>So the status code of a HTTP response should bring enough semantics about the processing of the request: was the processing successful? Did the client do something wrong? Did the server do something wrong? Luckily, status codes are standardized and the average web developer knows some of them: 404 (resource not found), 200 (everything went fine), etc.</p> <p>HTTP status codes are organized in series:</p> <ul> <li>informational (100-199)</li> <li>successful (200-299)</li> <li>redirection (300-399)</li> <li>client error (400-499)</li> <li>server error (500-599)</li> </ul> <p>You can find all the standard status codes <a href="http://en.wikipedia.org/wiki/List_of_HTTP_status_codes" hreflang="en">here</a>.</p> <h2>Which status code to use?</h2> <p>Well, it depends on what happened! We focus on error in this post, so we're more interested in the 400 and 500 series. But as the 500 series is about server errors (bugs or service unavailability), a developer of REST web services cares mainly about the 400 series (when writing your service, you can't really know about gateways or bandwidth limitations, this is the server infrastructure's job, not yours). Ok, let's see a couple of examples.</p> <h3>The dreaded 404</h3> <p>A service should send back a 404 when the client asked for a resource that doesn't exist. Perhaps the client asks for a resources with a given ID, so there's no row in the database with this ID, so 404! That's the example we'll implement with Spring MVC later.</p> <h3>The rigid 405</h3> <p>The usual short description of 405 is <em>Method Not Allowed</em>. Imagine an immutable resource, like an order that has been confirmed, paid, shipped, and received. This resource can't change anymore: it reached the end of its workflow. If a client sends a PUT request - PUT equals to update in REST - the service should then answer with a 405.</p> <h3>The rich 409</h3> <p>The short description for 409 is <em>Conflict</em>. There are many use cases where 409 is an appropriate status code:</p> <ul> <li>optimistic locking: a client GET a resource, change its state locally, and sends a PUT to update the resource. Unfortunately, another client updated the resource between the GET and the PUT. If the server can detect the conflict - thanks to a timestamp on the resource or a version number - the appropriate response would be a 409.</li> <li>pessimistic locking: a resource is accessible only by one client at a time, other clients trying to GET the resource could get a 409 until the lock is released (with a PUT for example or after a timeout). Note the 423 status code also holds the semantics of pessimistic locking.</li> <li>imagine clients submitting long-running tasks to be processed in the background by the server. Each task would have a client-provided ID. If a client submits a task with the same ID twice, the server could answer with a 409.</li> </ul> <p>All the standard status codes (up to 426) provide quite rich semantics to inform clients about an error. You can also imagine your own status codes, but you'll need to inform your clients about their meaning.</p> <h2>And what about the short description?</h2> <p>A status code comes with a short description. Standard status codes have a pre-defined short description, but you can change it if you want to provide more specific information.</p> <h2>Don't forget headers</h2> <p>Headers are another element of the response, and they can't complement the status code. When responding with 405 <em>Method Not Allowed</em>, the response can contain an <em>Allow</em> header to list the methods the resource supports.</p> <h2>And the content!</h2> <p>A response can also contain some content to describe even more the error. You're not limited to a status code and a short description. Take care the client actually understands the content you're sending back (plain text, HTML, etc.)</p> <h2>Status codes and error handling in action with Spring MVC</h2> <p>Spring MVC provides REST support as of Spring 3.0. You can implement all the REST of the planet with the plain servlet API, but a framework like Spring MVC is here to help you develop REST by using common patterns, like exception handling. Let's see how to do that on the server side, before moving on to the client side.</p> <h3>A RESTful web controller</h3> <p>Our web controller is quite simple: it returns a contact resource. The client must provide the ID of the contact by GETting a URL like /contacts/123 (123 being the ID).</p> <h4>200 when everything goes fine</h4> <p>Here is the code for the Spring MVC controller:</p> <pre class="java code java" style="font-family:inherit"><span style="color: #7F0055; font-weight: bold;">package</span> com.<span style="color: #000000;">zenika</span>.<span style="color: #000000;">web</span>; &nbsp; <span style="color: #a1a100;">import org.springframework.beans.factory.annotation.Autowired;</span> <span style="color: #a1a100;">import org.springframework.http.HttpStatus;</span> <span style="color: #a1a100;">import org.springframework.stereotype.Controller;</span> <span style="color: #a1a100;">import org.springframework.web.bind.annotation.PathVariable;</span> <span style="color: #a1a100;">import org.springframework.web.bind.annotation.RequestMapping;</span> <span style="color: #a1a100;">import org.springframework.web.bind.annotation.RequestMethod;</span> <span style="color: #a1a100;">import org.springframework.web.bind.annotation.ResponseBody;</span> <span style="color: #a1a100;">import org.springframework.web.bind.annotation.ResponseStatus;</span> <span style="color: #a1a100;">import com.zenika.domain.Contact;</span> <span style="color: #a1a100;">import com.zenika.repo.ContactRepository;</span> &nbsp; @Controller <span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">class</span> ContactController <span style="color: #000000;">&#123;</span> &nbsp;   @Autowired   <span style="color: #7F0055; font-weight: bold;">private</span> ContactRepository contactRepository; &nbsp;   @RequestMapping<span style="color: #000000;">&#40;</span>value=<span style="color: #888888;">&quot;/contacts/{id}&quot;</span>,method=RequestMethod.<span style="color: #000000;">GET</span><span style="color: #000000;">&#41;</span>   @ResponseStatus<span style="color: #000000;">&#40;</span>HttpStatus.<span style="color: #000000;">OK</span><span style="color: #000000;">&#41;</span>   <span style="color: #7F0055; font-weight: bold;">public</span> @ResponseBody Contact get<span style="color: #000000;">&#40;</span>@PathVariable <span style="color: #000000;">Long</span> id<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>     <span style="color: #7F0055; font-weight: bold;">return</span> contactRepository.<span style="color: #000000;">get</span><span style="color: #000000;">&#40;</span>id<span style="color: #000000;">&#41;</span>;   <span style="color: #000000;">&#125;</span> &nbsp; <span style="color: #000000;">&#125;</span></pre> <p>Spring MVC heavily relies on annotations for the configuration of controllers. The key point here is the <code>ResponseStatus</code> annotation, that tells Spring MVC which status code to send back. But what happe
ns if there's no contact for the given ID?</p> <h4>Bad ID, bad response?</h4> <p>The controller relies on a <code>ContactRepository</code> to load the <code>Contact</code>s. The contract of the <code>ContactRepository</code> is to throw a <code>EmptyResultDataAccessException</code> when there's no contact for the given ID. In this case, Spring MVC's default is to send back a 500 status code, which is bad for this specific error. Let's see how to send a 404 when the requested resource doesn't exist.</p> <h4>404 when the resource doesn't exist</h4> <p>Whenever a controller method throws an exception, Spring MVC can fall back to an exception handler method. Such a method is declared by annotating the method with the <code>ExceptionHandler</code> annotation. Here is the modified version of the controller with exception handler method when <code>EmptyResultDataAccessException</code> is thrown.</p> <pre class="java code java" style="font-family:inherit"><span style="color: #7F0055; font-weight: bold;">package</span> com.<span style="color: #000000;">zenika</span>.<span style="color: #000000;">web</span>; &nbsp; <span style="color: #a1a100;">import org.springframework.beans.factory.annotation.Autowired;</span> <span style="color: #a1a100;">import org.springframework.dao.EmptyResultDataAccessException;</span> <span style="color: #a1a100;">import org.springframework.http.HttpStatus;</span> <span style="color: #a1a100;">import org.springframework.stereotype.Controller;</span> <span style="color: #a1a100;">import org.springframework.web.bind.annotation.ExceptionHandler;</span> <span style="color: #a1a100;">import org.springframework.web.bind.annotation.PathVariable;</span> <span style="color: #a1a100;">import org.springframework.web.bind.annotation.RequestMapping;</span> <span style="color: #a1a100;">import org.springframework.web.bind.annotation.RequestMethod;</span> <span style="color: #a1a100;">import org.springframework.web.bind.annotation.ResponseBody;</span> <span style="color: #a1a100;">import org.springframework.web.bind.annotation.ResponseStatus;</span> <span style="color: #a1a100;">import com.zenika.domain.Contact;</span> <span style="color: #a1a100;">import com.zenika.repo.ContactRepository;</span> &nbsp; @Controller <span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">class</span> ContactController <span style="color: #000000;">&#123;</span> &nbsp;   @Autowired   <span style="color: #7F0055; font-weight: bold;">private</span> ContactRepository contactRepository; &nbsp;   @RequestMapping<span style="color: #000000;">&#40;</span>value=<span style="color: #888888;">&quot;/contacts/{id}&quot;</span>,method=RequestMethod.<span style="color: #000000;">GET</span><span style="color: #000000;">&#41;</span>   @ResponseStatus<span style="color: #000000;">&#40;</span>HttpStatus.<span style="color: #000000;">OK</span><span style="color: #000000;">&#41;</span>   <span style="color: #7F0055; font-weight: bold;">public</span> @ResponseBody Contact get<span style="color: #000000;">&#40;</span>@PathVariable <span style="color: #000000;">Long</span> id<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>     <span style="color: #7F0055; font-weight: bold;">return</span> contactRepository.<span style="color: #000000;">get</span><span style="color: #000000;">&#40;</span>id<span style="color: #000000;">&#41;</span>;   <span style="color: #000000;">&#125;</span> &nbsp;   @ExceptionHandler<span style="color: #000000;">&#40;</span>EmptyResultDataAccessException.<span style="color: #7F0055; font-weight: bold;">class</span><span style="color: #000000;">&#41;</span>   @ResponseStatus<span style="color: #000000;">&#40;</span>value=HttpStatus.<span style="color: #000000;">NOT_FOUND</span>,reason=<span style="color: #888888;">&quot;Contact not found&quot;</span><span style="color: #000000;">&#41;</span>   <span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">void</span> notFound<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> <span style="color: #000000;">&#125;</span> &nbsp; <span style="color: #000000;">&#125;</span></pre> <p>How does it work?</p> <ul> <li>Spring MVC calls the controller's <code>get</code> method</li> <li>the controller calls the <code>ContactRepository</code> that throws a <code>EmptyResultDataAccessException</code> because there's no contact for the given ID</li> <li>Spring MVC catches the exception and see there's an exception handler method for this kind of exceptions (see the value in the <code>ExceptionHandler</code> annotation on the <code>notFound</code> method)</li> <li>Spring MVC calls the exception handler method</li> <li>the exception handler method does nothing apart from providing the status code and the short description to send back.</li> </ul> <p>Note the <code>notFound</code> method customizes the short description: <em>Contact not found</em>.</p> <p>The point here is to show how a framework like Spring MVC helps to implement some REST practices. Spring MVC uses annotations in this case. But what about the client? Must it analyze the status code to know if its request has been processed correctly?</p> <h4>Error handling on the client side</h4> <p>A REST client must always analyze the status code, but again, a framework can help here. A good example is Spring MVC's <code>RestTemplate</code>. By default, the <code>RestTemplate</code> throws an exception for any response in the 400 or 500 series. The developer can customize this by providing its own implementation of <code>ResponseErrorHandler</code>. The following listing shows a JUnit test that shows a successful GET and a GET that ends up with a 404. The developer must handle the later in a <code>catch</code> block.</p> <pre class="java code java" style="font-family:inherit"><span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">class</span> RestErrorHandlingTest <span style="color: #000000;">&#123;</span> &nbsp;   <span style="color: #7F0055; font-weight: bold;">private</span> <span style="color: #000000;">String</span> url = <span style="color: #888888;">&quot;http://localhost:8081/rest/contacts/{id}&quot;</span>; &nbsp;   <span style="color: #7F0055; font-weight: bold;">private</span> RestTemplate restTemplate = <span style="color: #7F0055; font-weight: bold;">new</span> RestTemplate<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>; &nbsp;   @Test <span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">void</span> getContactOk<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>     Contact contact = restTemplate.<span style="color: #000000;">getForObject</span><span style="color: #000000;">&#40;</span>url, Contact.<span style="color: #7F0055; font-weight: bold;">class</span>, <span style="color: #888888;">&quot;1&quot;</span><span style="color: #000000;">&#41;</span>;     assertNotNull<span style="color: #000000;">&#40;</span>contact<span style="color: #000000;">&#41;</span>;     assertEquals<span style="color: #000000;">&#40;</span>1L, contact.<span style="color: #000000;">getId</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>.<span style="color: #000000;">longValue</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;   <span style="color: #000000;">&#125;</span> &nbsp;   @Test <span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">void</span> getContactNotFound<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>     <span style="color: #7F0055; font-weight: bold;">try</span> <span style="color: #000000;">&#123;</span>       restTemplate.<span style="color: #000000;">getForObjec
t</span><span style="color: #000000;">&#40;</span>url, Contact.<span style="color: #7F0055; font-weight: bold;">class</span>, <span style="color: #888888;">&quot;2&quot;</span><span style="color: #000000;">&#41;</span>;       fail<span style="color: #000000;">&#40;</span><span style="color: #888888;">&quot;no contact with this id&quot;</span><span style="color: #000000;">&#41;</span>;     <span style="color: #000000;">&#125;</span> <span style="color: #7F0055; font-weight: bold;">catch</span> <span style="color: #000000;">&#40;</span>HttpClientErrorException e<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>       assertEquals<span style="color: #000000;">&#40;</span>HttpStatus.<span style="color: #000000;">NOT_FOUND</span>, e.<span style="color: #000000;">getStatusCode</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;     <span style="color: #000000;">&#125;</span> <span style="color: #7F0055; font-weight: bold;">catch</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">Exception</span> e<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>       fail<span style="color: #000000;">&#40;</span><span style="color: #888888;">&quot;this isn't the expected exception: &quot;</span>+e.<span style="color: #000000;">getMessage</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;     <span style="color: #000000;">&#125;</span>   <span style="color: #000000;">&#125;</span> <span style="color: #000000;">&#125;</span></pre> <p>The default error handling behavior makes sense, as it prevents the developer from checking the status code after each request. The developer can let an exception interrupt the execution flow, as usual.</p> <h2>Summary</h2> <p>Hopefully, the way to deal with errors in typical REST services is clearer to you now. There's no magic: this is plain HTTP and you need to carefully choose the status codes to send back to the clients. Frameworks like Spring MVC can help to stick to the common patterns you have in the your favorite language, like exceptions.</p> <p>The <a href="https://github.com/Zenika/Blogs/tree/master/20110518_REST-error-handling/rest-error-handling">source code for this post</a> is available on <a href="https://github.com/Zenika/Blogs/">Zenika's GitHub repo</a>.</p>