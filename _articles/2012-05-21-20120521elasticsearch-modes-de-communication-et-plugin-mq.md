---
ID: 410
post_title: 'Elasticsearch : modes de communication et plugin ØMQ'
author: tleroux
post_date: 2012-05-21 09:08:00
post_excerpt: |
  <p><a href="http://www.elasticsearch.org/">Elasticsearch</a> est un projet open source, développé en Java et basé sur l'excellente librairie Apache Lucene, qui fournit des fonctionnalités de recherche avancées pour les sites web et les applications métier. Ses caractéristiques les plus connues sont sa capacité à indexer et rechercher des informations sur un très grand volume de données, sa nature distribuée qui facilite la clusterisation de serveurs de moteurs de recherche, et son API REST/JSON très complète.</p> <p>Il existe plusieurs façons de communiquer avec un serveur (ou un ensemble de serveurs) Elasticsearch. La plus simple est d’utiliser l’API REST sur le protocole HTTP, mais il en existe d’autres. Voici donc un petit tour d’horizon des modes de transport existants pour communiquer avec Elasticsearch, ainsi qu’une présentation plus détaillée du plugin ØMQ.</p>
layout: post
permalink: http://blog.zenika-offres.com/?p=410
published: true
slide_template:
  - ""
---
<p><a href="http://www.elasticsearch.org/">Elasticsearch</a> est un projet open source, développé en Java et basé sur l'excellente librairie Apache Lucene, qui fournit des fonctionnalités de recherche avancées pour les sites web et les applications métier. Ses caractéristiques les plus connues sont sa capacité à indexer et rechercher des informations sur un très grand volume de données, sa nature distribuée qui facilite la clusterisation de serveurs de moteurs de recherche, et son API REST/JSON très complète.</p> <p>Il existe plusieurs façons de communiquer avec un serveur (ou un ensemble de serveurs) Elasticsearch. La plus simple est d’utiliser l’API REST sur le protocole HTTP, mais il en existe d’autres. Voici donc un petit tour d’horizon des modes de transport existants pour communiquer avec Elasticsearch, ainsi qu’une présentation plus détaillée du plugin ØMQ.</p>
<!--more-->
<h3>HTTP</h3> <p>Elasticsearch dispose d’un module appelé “HTTP”, activé par défaut, qui expose l'API REST au travers d’un serveur Web. Ainsi, il suffit d’un simple client HTTP (nous utilisons dans nos exemples cURL) pour exécuter des opérations d’indexation de documents&nbsp;:</p> <pre> $ curl -XPUT http://localhost:9200/library/book/1 -d '{     &quot;title&quot; : &quot;Lucene in Action&quot;,     &quot;authors&quot; : [&quot;Michael McCandless&quot;, &quot;Erik Hatcher&quot;, &quot;Otis Gospodnetic&quot;] }' </pre> <p>Ou des recherches de documents&nbsp;:</p> <pre> $ curl -XGET http://localhost:9200/library/_search?q=title:lucene </pre> <p>Pour les traitements en masse, par exemple lorsqu'un grand nombre de documents doivent être indexés successivement, une bonne pratique consiste à utiliser l’API “Bulk”. Une requête “bulk” contient simplement un ensemble d’opérations à exécuter de façon groupée, qui seront envoyées au cluster Elasticsearch en une seule fois.</p> <pre> $ cat operations { &quot;index&quot; : { &quot;_index&quot; : &quot;library&quot;, &quot;_type&quot; : &quot;book&quot;, &quot;_id&quot; : &quot;1&quot; } } {  &quot;title&quot; : &quot;Lucene in Action&quot; } { &quot;index&quot; : { &quot;_index&quot; : &quot;library&quot;, &quot;_type&quot; : &quot;book&quot;, &quot;_id&quot; : &quot;2&quot; } } {  &quot;title&quot; : &quot;Spring Batch in Action&quot; } … </pre> <p>Ce dernier fournira en retour un rapport d’exécution de chacune des opérations&nbsp;:</p> <pre> $ curl -s -XPOST localhost:9200/_bulk --data-binary @operations {     &quot;took&quot;:16,     &quot;items&quot;:[         {&quot;index&quot;:{&quot;_index&quot;:&quot;library&quot;,&quot;_type&quot;:&quot;book&quot;,&quot;_id&quot;:&quot;1&quot;,&quot;_version&quot;:1,&quot;ok&quot;:true}},         {&quot;index&quot;:{&quot;_index&quot;:&quot;library&quot;,&quot;_type&quot;:&quot;book&quot;,&quot;_id&quot;:&quot;2&quot;,&quot;_version&quot;:1,&quot;ok&quot;:true}},         (...)     ] } </pre> <p>Si ce mode de transport est le plus simple et intuitif, ce n’est pas forcément le plus adapaté à toutes les situations. <br />
Par exemple, lorsqu’un très grand nombre de documents courts doivent être indexés de façon non prédictible&nbsp;: dans ce cas, les documents ne peuvent pas être groupés de façon efficace dans une requête “bulk” (car nous ne savons pas quand ils sont générés) et le temps de requête/réponse HTTP peut constituer un goulet d’étranglement. Une autre situation est lorsque le protocole HTTP est tout simplement interdit pour des raisons techniques ou de sécurité.</p> <p>Heureusement, Elasticsearch propose d’autres alternatives&nbsp;: Thrift, Memcached et ØMQ.</p> <h3>Thrift</h3> <p><a href="http://thrift.apache.org/">Apache Thrift</a> permet de définir des contrats d’échanges entre services dans un fichier de configuration et de générer à partir de ce fichier plusieurs clients RPC  dans différents langages de programmation.</p> <p>Le projet Elasticsearch dispose d’un plugin de transport “Thrift” installable sous forme de plugin, et met à disposition le fichier de définition correspondant pour la génération de clients RPC. Thrift offre théoriquement de meilleures performances que le mode de transport HTTP, et permet de réaliser les mêmes opérations (indexation, recherche, administration) que ce dernier.</p> <h3>Memcached</h3> <p><a href="http://memcached.org/">Memcached</a> est un système de gestion de cache distribué où les données sont stockées en mémoire, au sein d’un cluster. Il suffit ensuite d’utiliser l'un des nombreux clients disponibles pour se connecter au serveur et y stocker ou récupérer des données.</p> <p>Un mode de transport “memcached” a été implémenté pour Elasticsearch. Toutefois, ce dernier n’expose pas l’intégralité de l’API REST.</p> <h3>ØMQ</h3> <p><a href="http://www.zeromq.org/">ØMQ</a> (aussi appellé ZeroMQ ou zmq) est une librairie de sockets connue pour ses excellentes performances. Développée en C/C++, son API est disponible dans de nombreux langages dont Java.</p> <p>Cette librairie fournit des sockets capables d’échanger des messages sur un réseau (en TCP ou multicast), entre threads d’une application via un espace mémoire (on parle alors de in-process) ou encore entre processus d’une même machine (inter-process). <br />
ØMQ permet aussi d’implémenter différents patterns de communication tels que request/reply, publish/suscribe, fanout ou encore la distribution de messages à destination de plusieurs workers (chargés du traitement des messages).</p> <p>Le plugin “transport-zeromq” expose l’API REST d’Elasticsearch via des sockets ØMQ. N’importe quelle application cliente qui dispose de cette librairie peut alors soumettre des opérations à un cluster Elasticsearch sous forme de message ØMQ et exploiter la réponse obtenue en retour.</p> <p>Le format des messages n’est pas imposé par la librairie ØMQ. Toutefois, le plugin pour Elasticsearch s’attend à des messages au format suivant&nbsp;:</p> <pre> &lt;Method PUT,DELETE, POST...&gt;|&lt;URI, including parameters&gt;|&lt;JSON content&gt; </pre> <p>Voici un exemple de message:</p> <pre> PUT|/library/book/1|{&quot;title&quot; : &quot;Lucene in Action&quot;, &quot;authors&quot; : [&quot;Michael McCandless&quot;, &quot;Erik Hatcher&quot;, &quot;Otis Gospodnetic&quot;]} </pre> <p>Les réponses générées auront le format suivant:</p> <pre> &lt;Status code&gt;|&lt;Status name&gt;|&lt;JSON reply content&gt; </pre> <p>Par exemple:</p> <pre> 201|CREATED|{&quot;ok&quot; : true, &quot;_index&quot; : &quot;library&quot;, &quot;_type&quot; : &quot;book&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;_version&quot; : 1} </pre> <p>Pour des questions de performances, le plugin ØMQ utilise une implémentation du <a href="http://www.zeromq.org/sandbox:dealer" hreflang="en">pattern  router-dealer</a>:</p> <p><br />
<img src="/wp-content/uploads/2015/07/Elasticsearch_ZeroMQ_Transport_Plugin.png" alt="Elasticsearch ZeroMQ Transport Plugin Architecture" style="display:block; margin:0 auto;" title="Elasticsearch ZeroMQ Transport Plugin Architecture" /> <br /></p> <p>Dans ce pattern, une socket “Router” écoute et réceptionne les messages entrants envoyés par les différents clients, la communication Client-Router s’effectuant via TCP.</p> <p>Chaque message reçu est ensuite directement routé vers une seconde socket appelée “Dealer” au moyen d’une “Queue” (qui s’apparente à un canal de communication entre 2 sockets où chaque message reçu par l’une est directement transféré à l’autre).</p> <p>Le rôle de la socket Dealer est de distribuer les messages réceptionnés entre plusieurs Workers chargés de les traiter de façon asynchrone (la communication Dealer-Workers s’effectue in-process sur un pattern request/reply). Ce sont ces Workers qui exécutent les opérations (indexation, recherche, administration) dans le cluster Elasticsearch. Le résultat de l’exécution de l’opération est ensuite encapsulé dans un message, puis envoyé comme réponse par le Worker au Dealer, puis du Dealer au Router, et enfin du Router au client à l’initiative du message d’origine.</p> <p>Le plugin de transport ØMQ offre lui aussi de meilleures performances que le mode de transport HTTP tout en exposant l’intégralité de l’API REST.</p> <p>Le plugin peut être installé avec la procédure habituelle. Son code source est disponible sur <a href="https://github.com/tlrx/transport-zeromq" hreflang="en">github</a>.</p>