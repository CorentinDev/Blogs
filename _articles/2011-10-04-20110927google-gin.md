---
ID: 437
post_title: Google Gin
author: jvey
post_date: 2011-10-04 13:50:00
post_excerpt: '<p>Barman&nbsp;! Un gin s’il vous plaît&nbsp;! Gin Fizz&nbsp;? Gin Tonic&nbsp;? Non... Google Gin.</p> <p>Pour ceux qui se demandent ce que signifie ce nom, Gin vient de <strong>G</strong>WT <strong>IN</strong>jection. C’est le pendant de Guice, framework d’injection de dépendance également développé par Google, mais cette fois pour la partie cliente GWT. L’injection de dépendance en Javascript, vous en rêviez, Google l’a fait.</p>'
layout: post
permalink: http://blog.zenika-offres.com/?p=437
published: true
slide_template:
  - ""
---
<p>Barman&nbsp;! Un gin s’il vous plaît&nbsp;! Gin Fizz&nbsp;? Gin Tonic&nbsp;? Non... Google Gin.</p> <p>Pour ceux qui se demandent ce que signifie ce nom, Gin vient de <strong>G</strong>WT <strong>IN</strong>jection. C’est le pendant de Guice, framework d’injection de dépendance également développé par Google, mais cette fois pour la partie cliente GWT. L’injection de dépendance en Javascript, vous en rêviez, Google l’a fait.</p>
<!--more-->
<h2>L’intérêt</h2> <p>Avant de détailler comment mettre en place GIN, nous allons voir à quelles fins nous pouvons l’utiliser. Tout d’abord, ne cherchez pas l’intérêt de Gin du côté de la performance. Le code généré en utilisant Gin sera équivalent à un code développé de façon classique (Il ne faut pas oublier que tout le code écrit en Java (côté client GWT) est transformé et optimisé par le compilateur GWT pour donner au final du code Javascript).</p> <p>L’intérêt principal réside dans la simplification du code et sa lisibilité. En utilisant l’injection de dépendance, vous n’avez plus besoin de garder des références static de partout pour accéder à vos services ou vos objets. Imaginez pouvoir accéder à votre EventBus ou votre Bundle d’images en ajoutant simplement l’annotation @Inject, et là la magie opère.</p> <p>Utiliser Gin va également vous permettre de mettre en place une politique précise d’instanciation de vos objets. Cette politique correspond au binding que vous déclarez dans la configuration du module Gin, nous verrons cela après.</p> <p>Pour en revenir au côté simplification du code, l’injection automatique mais aussi l’instanciation automatique de tous les dictionnaires, les bundles d’images et les services RPC (Remote Procedure Call) est une facilité à laquelle on devient vite accros.</p> <h2>Mise en place</h2> <p>Maitenant, mettons un peu les mains dans le cambouis. La mise en place de Google Gin est extrêmement simple et bien documentée.</p> <p>Avant tout, il faut importer le module GIN. Pour cela, nous allons le déclarer dans le fichier de configuration de notre application GWT à l’aide de la balise inherits&nbsp;:</p> <pre class="xml code xml" style="font-family:inherit"><span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;module<span style="color: #000000; font-weight: bold;">&gt;</span></span></span>   ...   <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;inherits</span> <span style="color: #000066;">name</span>=<span style="color: #ff0000;">&quot;com.google.gwt.inject.Inject&quot;</span><span style="color: #000000; font-weight: bold;">/&gt;</span></span>   ... <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;/module<span style="color: #000000; font-weight: bold;">&gt;</span></span></span></pre> <p>Ensuite, déclarer une interface qui hérite de Ginjector (Prononcez “Gin-jector” et non “G-Injector”) qui doit définir des méthodes avec des types de retour correspondant aux types désirés. Seuls les objets que vous souhaitez récupérer depuis l’instance de l’injecteur doivent être ajoutées dans cette interface. Les objects injectés automatiquement via l’annotation @Inject par exemple, n’ont pas besoin d’être déclarés. En d’autres mots, comme le dit la documentation, “Les méthodes de l’injecteur fournissent un pont entre le monde Gin et le monde non-Gin”.</p> <pre class="java code java" style="font-family:inherit"><span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">interface</span> ZenGinjector <span style="color: #7F0055; font-weight: bold;">extends</span> Ginjector <span style="color: #000000;">&#123;</span>   MainPanel getMainPanel<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>; <span style="color: #000000;">&#125;</span></pre> <p>La prochaine étape est de déclarer le binding. Dans l’exemple suivant, nous allons binder la classe MainPanel en tant que Singleton tandis que la classe ZenRemoteService est bindé sur un Provider, ZenRemoteServiceProvider. Le binding définit comment seront instanciés les objets en question. Par exemple, lorsque vous utiliserez l’injecteur pour MainPanel, la même instance vous sera toujours renvoyé, puisque le scope est “Singleton”</p> <pre class="java code java" style="font-family:inherit"><span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">class</span> ZenClientModule <span style="color: #7F0055; font-weight: bold;">extends</span> AbstractGinModule <span style="color: #000000;">&#123;</span>   <span style="color: #7F0055; font-weight: bold;">protected</span> <span style="color: #7F0055; font-weight: bold;">void</span> configure<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>     bind<span style="color: #000000;">&#40;</span>MainPanel.<span style="color: #7F0055; font-weight: bold;">class</span><span style="color: #000000;">&#41;</span>.<span style="color: #000000;">in</span><span style="color: #000000;">&#40;</span>Singleton.<span style="color: #7F0055; font-weight: bold;">class</span><span style="color: #000000;">&#41;</span>;     bind<span style="color: #000000;">&#40;</span>ZenRemoteService.<span style="color: #7F0055; font-weight: bold;">class</span><span style="color: #000000;">&#41;</span>.<span style="color: #000000;">toProvider</span><span style="color: #000000;">&#40;</span>ZenRemoteServiceProvider.<span style="color: #7F0055; font-weight: bold;">class</span><span style="color: #000000;">&#41;</span>;   <span style="color: #000000;">&#125;</span> <span style="color: #000000;">&#125;</span></pre> <p>Il faut par la suite lier le module avec l’injecteur en utilisant l’annotation @GinModules.</p> <pre class="java code java" style="font-family:inherit">@GinModules<span style="color: #000000;">&#40;</span>ZenClientModule.<span style="color: #7F0055; font-weight: bold;">class</span><span style="color: #000000;">&#41;</span> <span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">interface</span> ZenGinjector <span style="color: #7F0055; font-weight: bold;">extends</span> Ginjector <span style="color: #000000;">&#123;</span>   MainPanel getMainPanel<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>; <span style="color: #000000;">&#125;</span></pre> <p>Finalement, une fois que toutes les classes et interfaces pour définir l’injecteur sont prêtes, il ne vous reste plus qu’à instancier celui-ci, et pour cela rien de mieux que la bonne vieille méthode GWT.create(...) et ensuite récupérer les objets que l’on souhaite en appelant les méthodes définies sur l’injecteur.</p> <pre class="java code java" style="font-family:inherit"><span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">class</span> ZenGinExample <span style="color: #7F0055; font-weight: bold;">implements</span> EntryPoint <span style="color: #000000;">&#123;</span>   <span style="color: #7F0055; font-weight: bold;">private</span> <span style="color: #7F0055; font-weight: bold;">final</span> ZenGinjector injector = GWT.<span style="color: #000000;">create</span><span style="color: #000000;">&#40;</span>ZenGinjector.<span style="color: #7F0055; font-weight: bold;">class</span><span style="color: #000000;">&#41;</span>; &nbsp;   <span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">void</span> onModuleLoad<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>     MainPanel mainPanel = injector.<span style="color: #000000;">getMainPanel</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;     RootPanel.<span style="color: #000000;">get</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>.<span style="color: #000000;">add</span><span style="color: #000000;">&#40;</span>mainPanel<span style="color: #000000;">&#41;</span>;   <span style="color: #000000;">&#125;</span> <span style="color: #000000;">&#125;</span></pre> <p>Pour rappeler ce qui a été dit précédemment, vous n’avez besoin de l’injecteur que pour faire le pont Gin/Non-GIN, récupérer les objets dont vous aurez besoin via les méthodes de l'injecteur
. Pour les autres objets, vous pouvez utiliser l’injection classique de Guice, comme dans l’exemple suivant, via annotations.</p> <pre class="java code java" style="font-family:inherit"><span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">class</span> ZenWidget <span style="color: #000000;">&#123;</span> &nbsp;   @Inject   <span style="color: #7F0055; font-weight: bold;">public</span> ZenWidget<span style="color: #000000;">&#40;</span>MyRemoteServiceAsync service<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>   ...   <span style="color: #000000;">&#125;</span> <span style="color: #000000;">&#125;</span></pre> <p>Il est intéressant de noter qu’il n’est pas nécessaire de déclarer de binding pour les objets qui sont créés via la méthode GWT.create(...), tels que les dictionnaires d’i18n, les bundles d’images ou de css ou encore les services RPC de GWT, car lorsque Gin ne trouve pas de binding, il utilise en fallback GWT.create(...)</p> <h2>Les différences avec Guice</h2> <p>La première différence entre Gin et Guice est le nom des interfaces. En Gin, celles-ci s’appellent Ginjector, GinModule et AbstractGinModule tandis qu’avec Guice, elles se nomment Injector, Module et AbstractModule.</p> <p>La seconde est que Gin ne possède qu’un sous-ensemble de fonctionnalités de Guice. Pour vous rendre compte, Gin fournit un tableau comparatif entre les différentes versions de Gin et de Guice&nbsp;: <a href="http://code.google.com/p/google-gin/wiki/GuiceCompatibility">Guice Compatibility </a></p> <p>Enfin, si vous souhaitez réutiliser le code écrit avec Gin, dans Guice, un adapteur est fourni, GinModuleAdapter qui vous permet par exemple de partager du code entre le client et le serveur (J’avoue personnellement ne voir qu’un intérêt limité à cette fonctionnalité mais qui sait... mieux vaut en avoir trop que pas assez)</p> <h2>Conclusion</h2> <p>Pour conclure et vous donner mon avis, utilisez Gin. Pour l’instant il n’existe pas d’équivalent pour la partie cliente de GWT, et le coût de mise en place est négligeable comparé au gain que vous pourrez en retirer, à la fois en terme de productivité mais aussi de maintenabilité de code.</p> <p>Le lien du projet&nbsp;: <a href="http://code.google.com/p/google-gin/">http://code.google.com/p/google-gin/</a></p>