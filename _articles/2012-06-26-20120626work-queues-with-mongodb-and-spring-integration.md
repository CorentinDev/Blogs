---
ID: 120
post_title: >
  Work queues with MongoDB and Spring
  Integration
author: Arnaud Cogolu√®gnes
post_date: 2012-06-26 09:36:00
post_excerpt: "<p>Work queue is a common pattern to decouple a producer of a request from the actual worker that processes the request. This pattern is especially useful when the producer doesn't expect any response: as the processing is asynchronous, the producer isn't held up and can do something else, instead of waiting for the worker to complete its job.</p> <p>In this post, we'll see how to quickly implement work queues with MongoDB and Spring Integration.</p>"
layout: post
permalink: http://blog.zenika-offres.com/?p=120
published: true
---
<p>Work queue is a common pattern to decouple a producer of a request from the actual worker that processes the request. This pattern is especially useful when the producer doesn't expect any response: as the processing is asynchronous, the producer isn't held up and can do something else, instead of waiting for the worker to complete its job.</p> <p>In this post, we'll see how to quickly implement work queues with MongoDB and Spring Integration.</p>
<!--more-->
<h2>Work queue implementations</h2> <p>There are <a href="http://en.wikipedia.org/wiki/Java_Message_Service">many ways</a> to implement <a href="http://www.rabbitmq.com/tutorials/tutorial-two-java.html">work queues</a>, and <a href="http://www.mattinsler.com/why-and-how-i-replaced-amazon-sqs-with-mongodb/">some people around here</a> have already <a href="http://www.ibm.com/developerworks/opensource/library/os-mongodb-work-queues/index.html">found out</a> that <a href="http://captaincodeman.com/2011/05/28/simple-service-bus-message-queue-mongodb/">MongoDB can do the job</a>. But these custom MongoDB-based work queue solutions are way too... custom. (Constructive) Laziness is a virtue (at least for <a href="http://www.catb.org/~esr/writings/cathedral-bazaar/cathedral-bazaar/ar01s02.html">programmers</a>), so why not re-using? The good news is <a href="http://www.springsource.org/spring-integration">Spring Integration</a> provides us with everything we need to implement work queues on top of <a href="http://www.mongodb.org/">MongoDB</a>.</p> <h2>The use case</h2> <p>Imagine an HTTP request on a web application triggers the sending of an email. The email sending API would be like the following:</p> <pre class="java code java" style="font-family:inherit"><span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">interface</span> EmailGateway <span style="color: #000000;">&#123;</span> &nbsp;   <span style="color: #7F0055; font-weight: bold;">void</span> send<span style="color: #000000;">&#40;</span>EmailNotification email<span style="color: #000000;">&#41;</span>; &nbsp; <span style="color: #000000;">&#125;</span></pre> <p>The web controller would do the following to send the email:</p> <pre class="java code java" style="font-family:inherit">emailGateway.<span style="color: #000000;">send</span><span style="color: #000000;">&#40;</span><span style="color: #7F0055; font-weight: bold;">new</span> EmailNotification<span style="color: #000000;">&#40;</span><span style="color: #888888;">&quot;mickey@mouse.com&quot;</span>,<span style="color: #888888;">&quot;Message from Minnie &quot;</span>+i,<span style="color: #888888;">&quot;Minnie is waiting for you!&quot;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;</pre> <p>A dedicated service would handle the actual sending:</p> <pre class="java code java" style="font-family:inherit"><span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">class</span> EmailService <span style="color: #000000;">&#123;</span> &nbsp;   <span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">void</span> send<span style="color: #000000;">&#40;</span>EmailNotification email<span style="color: #000000;">&#41;</span> <span style="color: #7F0055; font-weight: bold;">throws</span> <span style="color: #000000;">Exception</span> <span style="color: #000000;">&#123;</span>     <span style="color: #808080; font-style: italic;">// actual sending...</span>     <span style="color: #808080; font-style: italic;">// ... takes time and holds up caller</span>   <span style="color: #000000;">&#125;</span> &nbsp; <span style="color: #000000;">&#125;</span></pre> <p>The usual default solution would be all synchronous. What's bad about such a solution is the caller (the web controller) would be held up during the email sending (which can take a couple of seconds). This means the sending monopolizes a container thread. Let several users call the web controller at the same time and they would starve the container threads.</p> <p>A better solution would consist in making the sending asynchronous. This can be easily done by setting up a Spring Integration pipeline. The good news is this solution would affect the web controller: it will still be using the exact same <code>EmailGateway</code> interface but won't have to wait for the processing.</p> <h2>Submission to a Spring Integration pipeline</h2> <p>The web controller just needs a reference to <code>EmailGateway</code> Spring bean. Spring Integration routes every call to this gateway to a channel. Here is the configuration to declare the gateway and the channel:</p> <pre class="xml code xml" style="font-family:inherit"><span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;int:gateway</span> <span style="color: #000066;">service-interface</span>=<span style="color: #ff0000;">&quot;com.zenika.EmailGateway&quot;</span> <span style="color: #000066;">default-request-channel</span>=<span style="color: #ff0000;">&quot;tasks&quot;</span> <span style="color: #000000; font-weight: bold;">/&gt;</span></span> &nbsp; <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;int:channel</span> <span style="color: #000066;">id</span>=<span style="color: #ff0000;">&quot;tasks&quot;</span><span style="color: #000000; font-weight: bold;">&gt;</span></span>   <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;int:queue</span> <span style="color: #000066;">message-store</span>=<span style="color: #ff0000;">&quot;messageStore&quot;</span><span style="color: #000000; font-weight: bold;">/&gt;</span></span> <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;/int:channel<span style="color: #000000; font-weight: bold;">&gt;</span></span></span></pre> <p>The channel is a queue, which means it buffers messages. Spring Integration's queue channels buffer messages in memory by default, but as we plugged in a message store, our messages will be stored permanently. We won't lose any messages if the application crashes.</p> <p>But what is this message store? This is where MongoDB comes in.</p> <h2>MongoDB comes in as the message store</h2> <p>A MongoDB message store is available since <a href="http://blog.springsource.org/2012/01/09/spring-integration-2-1-is-now-ga/">Spring Integration 2.1</a>. It builds on top <a href="http://www.springsource.org/spring-data/mongodb">Spring Data MongoDB</a> (go <a href="/index.php?post/2012/04/27/Overview-of-Spring-Data-MongoDB">here</a> if you want to discover Spring Data MongoDB).</p> <p>The MongoDB message store is straightforward to configure:</p> <pre class="xml code xml" style="font-family:inherit"><span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;mongo:db-factory</span> <span style="color: #000066;">id</span>=<span style="color: #ff0000;">&quot;mongoDbFactory&quot;</span> <span style="color: #000066;">dbname</span>=<span style="color: #ff0000;">&quot;spring-integration&quot;</span> <span style="color: #000000; font-weight: bold;">/&gt;</span></span> &nbsp; <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;bean</span> <span style="color: #000066;">id</span>=<span style="color: #ff0000;">&quot;messageStore&quot;</span> <span style="color: #000066;">class</span>=<span style="color: #ff0000;">&quot;org.springframework.integration.mongodb.store.MongoDbMessageStore&quot;</span><span style="color: #000000; font-weight: bold;">&gt;</span></span>   <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;constructor-arg</span> <span style="color: #000066;">ref</span>=<span style="color: #ff0000;">&quot;mongoDbFactory&quot;</span> <span style="color: #000000; font-weight: bold;">/&gt;</span></span>   <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;constructor-arg</span> <span style="color: #000066;">value</span>=<span style="color: #ff0000;">&quot;emailtasks&quot;</span> <span style="color: #000000; font-weight: bold;">/&gt;</span></span> <span style="color: #808080; font-style: italic;">&lt;!-- the name of the collection --&gt;</span> <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;/bean<span style="color: #000000; font-weight: bold;">&gt;</span></span></span></pre> <p>That's it, our email sending requests are durable. Note a <a href="http://static.springsource.org/spring-integration/reference/htmlsingle/#message-s
tore">Spring Integration message store</a> is also useful to implement the <a href="http://www.eaipatterns.com/Aggregator.html">aggregator</a> or the <a href="http://www.eaipatterns.com/StoreInLibrary.html">claim check</a> patterns.</p> <p>Let's see now how to plug the actual sender.</p> <h2>A service activator to do the job</h2> <p>How to dequeue the email sending requests from the MongoDB queue? Quite simple, as Spring Integration handles the plumbing. We just have to configure a <a href="http://www.eaipatterns.com/MessagingAdapter.html">service activator</a> and a poller (as the channel is pollable channel):</p> <pre class="xml code xml" style="font-family:inherit"><span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;bean</span> <span style="color: #000066;">id</span>=<span style="color: #ff0000;">&quot;emailService&quot;</span> <span style="color: #000066;">class</span>=<span style="color: #ff0000;">&quot;com.zenika.EmailService&quot;</span> <span style="color: #000000; font-weight: bold;">/&gt;</span></span> &nbsp; <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;int:service-activator</span> <span style="color: #000066;">input-channel</span>=<span style="color: #ff0000;">&quot;tasks&quot;</span> <span style="color: #000066;">ref</span>=<span style="color: #ff0000;">&quot;emailService&quot;</span> <span style="color: #000066;">method</span>=<span style="color: #ff0000;">&quot;send&quot;</span><span style="color: #000000; font-weight: bold;">&gt;</span></span>   <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;int:poller</span> <span style="color: #000066;">fixed-rate</span>=<span style="color: #ff0000;">&quot;5000&quot;</span> <span style="color: #000066;">time-unit</span>=<span style="color: #ff0000;">&quot;MILLISECONDS&quot;</span> <span style="color: #000000; font-weight: bold;">/&gt;</span></span> <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;/int:service-activator<span style="color: #000000; font-weight: bold;">&gt;</span></span></span></pre> <p>Spring Integration will pull messages every 5 seconds and send them, one after the other, to the email service.</p> <p>The processing is mono-threaded by default. If you want to scale the processing out, you just need to plug a task executor on the poller:</p> <pre class="xml code xml" style="font-family:inherit"><span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;bean</span> <span style="color: #000066;">id</span>=<span style="color: #ff0000;">&quot;emailService&quot;</span> <span style="color: #000066;">class</span>=<span style="color: #ff0000;">&quot;com.zenika.EmailService&quot;</span> <span style="color: #000000; font-weight: bold;">/&gt;</span></span> &nbsp; <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;int:service-activator</span> <span style="color: #000066;">input-channel</span>=<span style="color: #ff0000;">&quot;tasks&quot;</span> <span style="color: #000066;">ref</span>=<span style="color: #ff0000;">&quot;emailService&quot;</span> <span style="color: #000066;">method</span>=<span style="color: #ff0000;">&quot;send&quot;</span><span style="color: #000000; font-weight: bold;">&gt;</span></span>   <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;int:poller</span> <span style="color: #000066;">fixed-rate</span>=<span style="color: #ff0000;">&quot;5000&quot;</span> <span style="color: #000066;">time-unit</span>=<span style="color: #ff0000;">&quot;MILLISECONDS&quot;</span>  </span> <span style="color: #009900;">                    <span style="color: #000066;">task-executor</span>=<span style="color: #ff0000;">&quot;emailTaskExecutor&quot;</span> <span style="color: #000000; font-weight: bold;">/&gt;</span></span> <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;/int:service-activator<span style="color: #000000; font-weight: bold;">&gt;</span></span></span> &nbsp; <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;task:executor</span> <span style="color: #000066;">id</span>=<span style="color: #ff0000;">&quot;emailTaskExecutor&quot;</span> <span style="color: #000066;">pool-size</span>=<span style="color: #ff0000;">&quot;10&quot;</span> <span style="color: #000000; font-weight: bold;">/&gt;</span></span></pre> <h2>Conclusion</h2> <p>This post covered how to implement a MongoDB-backed-up work queue with Spring Integration. This works great if you already have MongoDB in your architecture and don't want to install any additional component. Note Spring Integration also provides message store implementations for <a href="http://static.springsource.org/spring-integration/reference/htmlsingle/#jdbc-message-store">relational databases</a>, <a href="http://static.springsource.org/spring-integration/reference/htmlsingle/#redis-message-store">Redis</a>, and <a href="http://static.springsource.org/spring-integration/reference/htmlsingle/#gemfire-message-store">Gemfire</a>.</p> <p>Our solution works but remains simple If you're in need of more robust and feature-complete messaging solutions (like routing or <a href="/index.php?post/2012/03/15/PDF-workers-with-RabbitMQ">distributed request-reply</a>), solutions like <a href="http://www.rabbitmq.com/">RabbitMQ</a> are usually more appropriate.</p> <p><a href="https://github.com/acogoluegnes/Spring-Integration-MongoDB">Source code</a></p>