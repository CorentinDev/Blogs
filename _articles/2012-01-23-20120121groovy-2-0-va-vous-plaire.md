---
ID: 106
post_title: Groovy 2.0 va vous plaire !
author: mboillod
post_date: 2012-01-23 09:30:00
post_excerpt: |
  <p>Si vous aimez Java et que vous ne connaissez pas Groovy, je vous invite à découvrir ce langage très addictif&nbsp;!</p> <h3>Présentation de Groovy</h3> <p>En deux mots, Groovy est un langage dynamique, fortement typé qui s'exécute sur la JVM et qui a l'avantage d'avoir une syntaxe très proche de Java et qui propose&nbsp;:</p> <ul> <li>une syntaxe plus concise (avec le support natif des listes, des maps, du JSON, du XML, ...),</li> </ul> <pre>Exemple : def codesPostaux = [ 44000 : "Nantes", 75000 : "Paris" ]</pre> <ul> <li>un JDK Java enrichi de nouvelles fonctionnalités, qui permet d'écrire le code suivant&nbsp;: voir le <a href="http://groovy.codehaus.org/groovy-jdk/">Groovy JDK</a>,</li> </ul> <pre> Exemple : new File("fichier.txt").eachLine{ line -&gt; println line }</pre> <ul> <li>une API supplémentaire&nbsp;: voir l'<a href="http://groovy.codehaus.org/api/">API Groovy</a>,</li> </ul> <pre>Exemple : use(TimeCategory) { println 1.minute.from.now }</pre> <ul> <li>permet de modifier le comportement d'une classe ou d'une instance au runtime (via sa métaclasse). Voir définition du <a href="http://fr.wikipedia.org/wiki/Monkey-Patch">monkey-patch</a>,</li> <li>un support du scripting,</li> <li>et plein d'autres choses...</li> </ul>
layout: post
permalink: http://blog.zenika-offres.com/?p=106
published: true
---
<p>Si vous aimez Java et que vous ne connaissez pas Groovy, je vous invite à découvrir ce langage très addictif&nbsp;!</p> <h3>Présentation de Groovy</h3> <p>En deux mots, Groovy est un langage dynamique, fortement typé qui s'exécute sur la JVM et qui a l'avantage d'avoir une syntaxe très proche de Java et qui propose&nbsp;:</p> <ul> <li>une syntaxe plus concise (avec le support natif des listes, des maps, du JSON, du XML, ...),</li> </ul> <pre>Exemple : def codesPostaux = [ 44000 : "Nantes", 75000 : "Paris" ]</pre> <ul> <li>un JDK Java enrichi de nouvelles fonctionnalités, qui permet d'écrire le code suivant&nbsp;: voir le <a href="http://groovy.codehaus.org/groovy-jdk/">Groovy JDK</a>,</li> </ul> <pre> Exemple : new File("fichier.txt").eachLine{ line -&gt; println line }</pre> <ul> <li>une API supplémentaire&nbsp;: voir l'<a href="http://groovy.codehaus.org/api/">API Groovy</a>,</li> </ul> <pre>Exemple : use(TimeCategory) { println 1.minute.from.now }</pre> <ul> <li>permet de modifier le comportement d'une classe ou d'une instance au runtime (via sa métaclasse). Voir définition du <a href="http://fr.wikipedia.org/wiki/Monkey-Patch">monkey-patch</a>,</li> <li>un support du scripting,</li> <li>et plein d'autres choses...</li> </ul>
<!--more-->
<h3>Inconvénients de Groovy 1.8</h3> <p>Malgré tous ses avantages, Groovy, de part son comportement dynamique, concède quelques faiblesses (pour les développeurs Java)&nbsp;:</p> <ul> <li>ses performances pures sont moins bonnes que Java (plus significatif sur du calcul que pour des traitements métiers),</li> <li>seule la sémantique est vérifiée à la compilation, pas le code</li> <li>le comportement de votre classe peut être modifié dynamiquement</li> </ul> <h3>Groovy 2.0 pour satisfaire tout le monde</h3> <p>Groovy est à l'écoute de la communauté Java et la version 2.0 va certainement plaire à beaucoup de monde.</p> <p><strong>Pourquoi ?</strong></p> <p>Tout simplement parce que Groovy 2.0 permettra au développeur de choisir de combler les faiblesses évoquées en activant au niveau d'une classe ou d'une méthode&nbsp;:</p> <ul> <li>La vérification statique de code via l'annotation <code>@TypeChecked</code></li> <li>La compilation statique via l'annotation <code>@CompileStatic</code></li> </ul> <p><strong>Vérification statique</strong></p> <p>La vérification statique de code ne change pas le comportement de Groovy mais permet de vérifier à la compilation que tous les attributs ou méthodes utilisés sont connues par le compilateur. Cela évite de faire des erreurs du style&nbsp;:</p> <pre>println "hello world".len() //méthode inexistante</pre> <p>Bien évidemment, si vous avez besoin du comportement dynamique, il ne faudra pas ajouter l'annotation.</p> <p><strong>Compilation statique</strong></p> <p>La compilation statique quant à elle désactive toutes les fonctionnalités dynamique de Groovy et produit du bytecode Java plus "standard" (appel de méthode directe, ...). Les impacts directs sont des <strong>gains de performances</strong> (du niveau de Java) et des <strong>erreurs détectées à la compilation</strong> (plus stricte encore que lors de la vérification statique).</p> <p>Cette fonctionnalité est en cours de développement et certains choix d'implémentation reste encore à faire, principalement au niveau des appels de méthodes.</p> <p>Pour présenter le dilemme, prenons le code suivant&nbsp;:</p> <pre class="java code java" style="font-family:inherit">def foo<span style="color: #000000;">&#40;</span><span style="color: #000000;">Object</span> o<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#123;</span> println <span style="color: #888888;">'object'</span> <span style="color: #000000;">&#125;</span> def foo<span style="color: #000000;">&#40;</span><span style="color: #000000;">Date</span> d<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#123;</span> println <span style="color: #888888;">'date'</span> <span style="color: #000000;">&#125;</span> &nbsp; <span style="color: #000000;">Object</span> date = <span style="color: #7F0055; font-weight: bold;">new</span> <span style="color: #000000;">Date</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> foo<span style="color: #000000;">&#40;</span>date<span style="color: #000000;">&#41;</span></pre> <p>En Java, l'exécution de ce code affiche <code>object</code> car le lien vers la méthode est fait à la compilation à partir du type déclaré de l'attribut date. C'est d'ailleurs une erreur que l'on fait souvent en tant que développeur Java. On pense que la bonne méthode sera appelée, ... et non&nbsp;! En groovy, le compilateur est un peu plus intelligent et sait que le type de l'attribut date est <code>java.util.Date</code>. Selon le code, il est possible que le compilateur Groovy ne puisse pas déterminer le type d'une variable. C'est pourquoi, le comportement standard de Groovy est de résoudre le type au runtime pour appeler la méthode la plus adéquate.</p> <p><strong>La question qui se pose est donc :</strong> "Le lien vers la méthode doit-il se faire"&nbsp;:</p> <ul> <li>A partir du type déclaré, comme en Java,</li> <li>A partir du type inféré par le compilateur Groovy.</li> <li>A partir du type exact au runtime.</li> </ul> <p>L'idéal est sûrement la dernière solution, mais ce serait forcément moins "statique", car il faudrait analyser le type de la variable pendant l'exécution puis faire un appel par réflexivité ... et adieu aux perfs.</p> <p>En tant que développeur, avec Java, soit on est conscient du comportement, et il faut ajouter les <code>(Cast)</code> explicitement pour avoir ce comportement, soit on ne sait pas et l'exécution du code n'est pas toujours celui attendu.</p> <p>Je me dis donc que si groovy peut en faire une partie, autant le prendre. Donc je pencherai pour la solution 2, mais quoi qu'il en soit, <strong>l'important est de connaître la règle</strong>.</p> <p>D'ailleurs, même en Java, il y a plein de "corner case" que peu de développeur connaissent. Par exemple, d'après vous, que ce passe t'il si on exécute ce code&nbsp;:</p> <pre class="java code java" style="font-family:inherit"><span style="color: #7F0055; font-weight: bold;">class</span> Base <span style="color: #000000;">&#123;</span>     <span style="color: #7F0055; font-weight: bold;">public</span>  <span style="color: #000000;">String</span> name = <span style="color: #888888;">&quot;Base&quot;</span>;     <span style="color: #7F0055; font-weight: bold;">public</span>  <span style="color: #000000;">String</span> getName<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> <span style="color: #7F0055; font-weight: bold;">return</span> name; <span style="color: #000000;">&#125;</span> <span style="color: #000000;">&#125;</span> &nbsp; <span style="color: #7F0055; font-weight: bold;">class</span> Sub <span style="color: #7F0055; font-weight: bold;">extends</span> Base <span style="color: #000000;">&#123;</span>     <span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #000000;">String</span> name = <span style="color: #888888;">&quot;Sub&quot;</span>;     <span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #000000;">String</span> getName<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> <span style="color: #7F0055; font-weight: bold;">return</span> name; <span style="color: #000000;">&#125;</span> <span style="color: #000000;">&#125;</span> &nbsp; <span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">class</span> Program <span style="color: #000000;">&#123;</span>     <span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">static</span> <span style="color: #7F0055; font-weight: bold;">void</span> main<span style="color: #000000;">&#40;</span><span style="color: #000000;">String</span><span style="color: #000000;">&#91;</span><span style="color: #000000;">&#93;</span> args<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>         Sub s  = <span style="color: #7F0055; font-weight: bold;">new</span> Sub<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;         Base b = s;         <span style="color: #000000;">System</span>.<span style="color: #000000;">out</span>.<span style="color: #000000;">println</span><span style="color: #000000;">&#40;</span>b.<span style="color: #000000;">name</span><span style="color: #000000;">&#41;</span>;     <span style="color: #000000;">&#125;</span> <span style="color: #000000;">&#125;</span></pre> <p>Pour finir sur le choix à propos de l'appel de méthode, pour ceux qui préfèrent le comportement Groovy, il est toujours possible de ne pas activer la compilation statique, ou bien d'ajouter le <code>(Cast)</code> pour avoir ce comportement&nbsp;:</p> <pre class="java code java" style="font-family:inherit">def foo<span style="color: #000000;">&#40;</span><span style="color: #000000;">Object</span> o<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#123;</span>     <span style="color: #7F0055;font-weight: bold;">if</span> <
span style="color: #000000;">&#40;</span>foo <span style="color: #7F0055; font-weight: bold;">instanceof</span> <span style="color: #000000;">Date</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#123;</span>         foo<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">Date</span><span style="color: #000000;">&#41;</span>o<span style="color: #000000;">&#41;</span>     <span style="color: #000000;">&#125;</span> <span style="color: #7F0055;font-weight: bold;">else</span> <span style="color: #000000;">&#123;</span>         println <span style="color: #888888;">'object'</span>     <span style="color: #000000;">&#125;</span> <span style="color: #000000;">&#125;</span></pre> <p>Et vous, quel est votre avis&nbsp;? N'hésitez pas à le donner en ajoutant un commentaire à cet article.</p> <h3>Utilisez Groovy comme il vous semble</h3> <p>En résumé, Groovy 2.0 essaye de combler certaines frustrations exprimées par la communauté Java, sans pour autant changer sa philosophie. Groovy reste un langage dynamique, mais permet de désactiver certaines de ces fonctionnalités si vous n'en n'avez pas besoin, pour gagner au niveau de la vérification du code et en performance.</p> <p>Si vous voulez en savoir plus sur ces fonctionnalités, je vous invite à lire la très bonne présentation de Cédric Champeau de vmware que vous trouverez à <a href="http://portal.sliderocket.com/vmware/Groovy-2-0-Static-Type-Checking-and-Compilation">cette adresse</a>.</p> <p>Vous trouverez également plus de documentation sur le site des <a href="http://docs.codehaus.org/display/GroovyJSR/Groovy+Enhancement+Proposal">GEP</a> (Groovy Enhancement Proposal) et sur le <a href="http://www.jroller.com/melix/">blog</a> de Cédric.</p> <p>Je n'ai pas parlé de l'utilisation de <code>invokeDynamic</code> au niveau du bytecode Groovy qui est aussi une des features proposées pour les utilisateurs de Java7, mais vous pouvez trouver plus d'info sur <a href="http://docs.codehaus.org/display/GROOVY/2011/11/09/">cette page</a> du site de Groovy</p> <p>D'ailleurs, si vous souhaitez tester ces fonctionnalités et faire avancer Groovy, vous pouvez télécharger la version <a href="http://groovy.codehaus.org/Download">2.0 beta</a> sur le site de Groovy, et pour la compilation statique, qui est présent à partir de la béta 3, vous devez télécharger la version <a href="http://snapshots.repository.codehaus.org/org/codehaus/groovy/groovy-all/">snapshot ici</a> en attendant la version béta.</p> <p>J'espère vous avoir donné <strong>envie d'essayer Groovy</strong>&nbsp;!</p> <p>Manuel</p> <p>Télécharger la béta de Groovy (pour la compilation statique ;..)</p>