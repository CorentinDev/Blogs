---
ID: 407
post_title: 'Coherence Part VI : traitement de données distribuées, concurrence et in-place processing'
author: team-bourgain-tinon
post_date: 2012-02-09 09:30:00
post_excerpt: "<p>La gestion de la concurrence et la distribution des calculs sont primordiaux pour atteindre la scalabilité que promettent les in memory datagrids. Coherence propose plusieurs mécanismes pour cela, dans cet article nous allons gérer les accès concurrents aux données dans un premier temps avec des locks explicites puis nous verrons comment Coherence permet de faire des traitements lock-free et in place, pour que le noeud qui porte la donnée soit celui qui effectue les opérations afin d'atteindre une scalabilité supérieure.</p>"
layout: post
permalink: http://blog.zenika-offres.com/?p=407
published: true
slide_template:
  - ""
---
<p>La gestion de la concurrence et la distribution des calculs sont primordiaux pour atteindre la scalabilité que promettent les in memory datagrids. Coherence propose plusieurs mécanismes pour cela, dans cet article nous allons gérer les accès concurrents aux données dans un premier temps avec des locks explicites puis nous verrons comment Coherence permet de faire des traitements lock-free et in place, pour que le noeud qui porte la donnée soit celui qui effectue les opérations afin d'atteindre une scalabilité supérieure.</p>
<!--more-->
<h3>Locks</h3> <p>Le locking consiste à verrouiller une entrée du cache pour éviter qu’un autre accès à cette entrée puisse la modifier en même temps. Dans PetClinic, nous sommes exposés à cette problématique pour tout ce qui concerne la modification des données, puisqu’il faut à chaque fois faire un get(), modifier l’entrée puis faire un put() avec l’entrée modifiée. Si un autre utilisateur de l’application modifie la même entrée, avec des get et puts entrelacés, on peut perdre la donnée, le dernier appel à <strong>put()</strong> écrasant le précédant avec les données récupérées lors de son propre <strong>get()</strong>. <br />
<img src="/wp-content/uploads/2015/07/get_put_entrelaces.png" alt="get_put_entrelaces.png" /> <br /></p> <p>Dans ce cas, les modifications apportées par Client 1 sont écrasées. Coherence supporte le locking avec une granularité au niveau d'une entrée du cache. Leur utilisation est simple, il suffit d'appeler le couple de méthodes <strong>lock()</strong> et <strong>unlock()</strong> du <strong>NamedCache</strong>, qui vont blocker et débloquer la clé passé en argument. La méthode <strong>lock()</strong> demande un timeout en millisecondes comme second paramètre, une valeur de -1 garderas le lock indéfiniment, tandis que 0 le libérera immédiatement. Seul le nœud qui a posé un lock peut le libérer, donc n'oubliez pas de le faire même en cas d'exception.</p> <p>Pour PetClinic, nous allons améliorer la méthode <strong>storePet()</strong> qui pour rappel n'était pas thread safe, puisqu'entre le get() et le put() dans le cache, un autre client de la grille pouvait avoir modifié l'entrée.</p> <pre class="java code java" style="font-family:inherit"><span style="color: #7F0055; font-weight: bold;">try</span> <span style="color: #000000;">&#123;</span>     <span style="color: #7F0055; font-weight: bold;">boolean</span> lock = getOwnersCache<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>.<span style="color: #000000;">lock</span><span style="color: #000000;">&#40;</span>pet.<span style="color: #000000;">getOwner</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>.<span style="color: #000000;">getId</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;     <span style="color: #7F0055;font-weight: bold;">if</span> <span style="color: #000000;">&#40;</span><span style="color: #000000;">!</span>lock<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>         <span style="color: #7F0055; font-weight: bold;">throw</span> <span style="color: #7F0055; font-weight: bold;">new</span> <span style="color: #000000;">ConcurrentModificationException</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;     <span style="color: #000000;">&#125;</span>     <span style="color: #000000;">Owner</span> owner = <span style="color: #000000;">&#40;</span><span style="color: #000000;">Owner</span><span style="color: #000000;">&#41;</span> getOwnersCache<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>.<span style="color: #000000;">get</span><span style="color: #000000;">&#40;</span>pet.<span style="color: #000000;">getOwner</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>.<span style="color: #000000;">getId</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;     <span style="color: #808080; font-style: italic;">// store the pet in owner omitted for clarity</span>     ...     <span style="color: #000000;">getOwnersCache</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>.<span style="color: #000000;">put</span><span style="color: #000000;">&#40;</span>owner.<span style="color: #000000;">getId</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>, owner<span style="color: #000000;">&#41;</span>; <span style="color: #000000;">&#125;</span> <span style="color: #7F0055; font-weight: bold;">finally</span> <span style="color: #000000;">&#123;</span>     getOwnersCache<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>.<span style="color: #000000;">unlock</span><span style="color: #000000;">&#40;</span>pet.<span style="color: #000000;">getOwner</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>.<span style="color: #000000;">getId</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>; <span style="color: #000000;">&#125;</span></pre> <p>Les locks ne bloquent pas réellement l'entrée, il est toujours possible d'y accéder en lecture, et dans le cas des caches partitionnés en écriture, si vous n’utilisez pas les locks dans toute l’application. En revanche un seul noeud peut posséder le lock, il faut donc penser à le faire avant d'accéder en écriture au cache si vous utilisez cette API.</p> <h3>EntryProcessor</h3> <p>L'utilisation des locks n'est pas très performante sur des caches répliqués ou partitionnés puisque le lock, le get(), le put() et l'unlock font chacun un appel réseau. Pour optimiser ce type d'opération, Coherence propose un mécanisme pour effectuer ce traitement du coté du noeud qui porte l’entrée en une seule opération et donc un seul appel réseau, même si le traitement est effectué sur plusieurs entrées. Ce traitement qui ne nécessite pas de lock explicite est un processor. Ces processors ont aussi pour avantage de tirer naturellement partie de la structure du cluster pour distribuer les traitements. A la place de l’exécution du pattern lock, get, put, unlock en série pour toutes les entrées à traiter, le processor ne nécessitera qu’un appel pour traiter l’ensemble des entrées ciblées en parallèle sur les différents noeuds.<br />
Bilan: réduction des échanges réseau et distribution de la charge de calcul.</p> <p>Utiliser un <strong>EntryProcessor</strong> revient globalement à envoyer le code vers les données plutôt que faire venir les données vers le code de traitement. Cela offre plusieurs avantages:</p> <ul> <li>diminution du volume de données qui transite sur le réseau, le processor et sa valeur de retour sont envoyés sur le réseau plutôt que la donnée dans les deux sens.</li> <li>répartition la charge sur les différents nœuds du cluster.</li> <li>réalisation d'opérations concurrentes sans lock explicite, les processor sont traités en série sur une entrée. Par contre il est toujours possible qu'avec deux processeurs successifs le second écrase les modifications du premier.</li> <li>modifications des entrées dans le cache atomiques.</li> <li>garantie d'exécution grâce aux fonctionnalités de réplication des caches.</li> </ul> <p>A propos de la garantie d’exécution, celà signifie que si le nœud qui porte la donnée sort du cluster pendant le traitement, c'est la partition de sauvegarde qui est promue partition principale, qui va exécuter ce traitement. <br />
Attention, un processeur ne réalise pas une transaction, si le processeur à des effets de bords et qu'une exception est levée, il n'y a pas de rollback.</p> <p>L'interface <strong>EntryProcessor</strong> expose deux méthodes&nbsp;: process(Entry) et processAll(Set). Pour vous simplifier la vie vous pouvez étendre <strong>AbstractProcessor</strong> qui propose une implémentation par défaut de <strong>processAll()</strong> qui va simplement itérer sur le Set passé en paramètre et appliquer <strong>process()</strong> sur chaque entrée.</p> <h3>Utilisation d'un processeur</h3> <p>Nous allons à nouveau modifier la méthode <strong>storePet()</strong> pour utiliser un processeur qui va enregistrer le <strong>Pet</strong> . Voici le code du processeur</p> <pre class="java code java" style="font-family:inherit"><span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">class</span> StorePetProcessor <span style="color: #7F0055; font-weight: bold;">extends</span> AbstractProcessor <span style="color: #000000;">&#123;</span>     <span style="color: #7F0055; font-weight: bold;">private</span> Pet pet;     <span style="color: #7F0055; font-weight: bold;">public</span> StorePetProcessor<span style="color: #000000;">&#40;</span>Pet pet<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>         <span style="color: #7F0055; font-weight: bold;">this</span>.<span style="color: #000000;">pet</span> = pet;     <span style="color: #000000;">&#125;</span> &nbsp;     <span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #000000;">Object</span> process<span style="color: #000000;">&#40;</span>Entry entry<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>         <span style="color: #000000;">Owner</span> owner = <span style="color: #000000;">&#40;</span><span style="color: #000000;">Owner</span><span style="color: #000000;">&#41;</span> entry.<span style="color: #000000;">getValue</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>; &nbsp;         <span style="color: #7F0055;font-weight: bold;">if</span> <span style="color: #000000;">&#40;</span>pet.<span style="color: #000000;">getId</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> == <span style="color: #7F0055; font-weight: bold;">null</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>             pet.<span style="color: #000000;">setId</span><span style="color: #000000;">&#40;</span>RandomUtils.<span style="color: #000000;">nextInt</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;             owner.<span style="color: #000000;">addPet</span><span style="color: #000000;">&#40;</span>pet<span style="color: #000000;">&#41;</span>;         <span style="color: #000000;">&#125;</span> <span style="color: #7F0055;font-weight: bold;">else</span> <span style="color: #000000;">&#123;</span>             Pet existingPet = owner.<span style="color: #000000;">getPet</span><span style="color: #000000;">&#40;</span>pet.<span style="color: #000000;">getName</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;             existingPet.<span style="color: #000000;">setBirthDate</span><span style="color: #000000;">&#40;</span>pet.<span style="color: #000000;">getBirthDate</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;             existingPet.<span style="color: #000000;">setName</span><span style="color: #000000;">&#40;</span>pet.<span style="color: #000000;">getName</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;             existingPet.<span style="color: #000000;">setType</span><span style="color: #000000;">&#40;</span>pet.<span style="color: #000000;">getType</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>;         <span style="color: #000000;">&#125;</span>         entry.<span style="color: #000000;">setValue</span><span style="color: #000000;">&#40;</span>owner<span style="color: #000000;">&#41;</span>;         <span style="color: #7F0055; font-weight: bold;">return</span> <span style="color: #7F0055; font-weight: bold;">null</span>;     <span style="color: #000000;">&#125;</span> <span style="color: #000000;">&#125;</span></pre> <p>Pensez à appeler <strong>setValue()</strong> après avoir modifier l'entrée, pour la sérialiser et l'insérer dans le cache, sinon vous n'aurez fait que modifier la copie de-sérialisée de l'entrée.</p> <p>Pour exécuter le processeur, on utilise la méthode <strong>invoke()</strong> de l'interface <strong>InvocableMap</strong>, implémentée par <strong>NamedCache</strong>. Les paramètres sont la clé de l'entrée sur laquelle on veut envoyer le processeur et le processeur lui même:</p> <pre class="java code java" style="font-family:inherit"><span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">void</span> storePet<span style="color: #000000;">&#40;</span>Pet pet<span style="color: #000000;">&#41;</span> <span style="color: #7F0055; font-weight: bold;">throws</span> DataAccessException <span style="color: #000000;">&#123;</span>     EntryProcessor processor = <span style="color: #7F0055; font-weight: bold;">new</span> StorePetProcessor<span style="color: #000000;">&#40;</span>pet<span style="color: #000000;">&#41;</span>;     getOwnersCache<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>.<span style="color: #000000;">invoke</span><span style="color: #000000;">&#40;</span>pet.<span style="color: #000000;">getOwner</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>.<span style="color: #000000;">getId</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>, processor<span style="color: #000000;">&#41;</span>; <span style="color: #000000;">&#125;</span></pre> <p>L'exécution du processeur est synchrone et le thread appelant recevra la valeur retournée par le processeur. Attention, Coherence possède un mécanisme de détection des threads bloqués&nbsp;: si votre traitement est long, il risque d'être tué par le GuardSupport. Pour éviter cela, il faut appeler la méthode GuardSupport.heartbeat(), qui va signaler que le thread n'est pas bloqué.</p> <p>Notez qu'il est possible de lancer un processeur sur une clé qui n'existe pas, il est dans ce cas possible de crée l'entrée avec <strong>setValue()</strong>. Il est donc possible de coupler une action supplémentaire, comme la vérification des droits.</p> <p>J'ai utilisé plus haut l'image de l'envoie de code vers les données, pour être plus précis, le processeur va être sérialisé puis envoyé vers les autres nœuds du cluster qui vont le de sérialiser. Le processeur doit donc exister dans le classpath des autres nœuds.</p> <h3>Exécution parallèle de processeurs</h3> <p>Pour exécuter le processeur sur plusieurs entrées en parallèle, vous pouvez utiliser la méthode <strong>invokeAll()</strong>. Il y a deux variantes, la première prend un Set des clés à traiter et la seconde prend un filtre et qui s'appliquera sur toutes les entrées qui correspondent au filtre. Cette approche est semblable à du Map/Reduce mais au lieu de réduire les résultats, on les traite indépendamment coté serveur. Dans les deux cas, la valeur de retour est une Map avec en clé celle de l'entrée du cache et en valeur le retour de la méthode <strong>process()</strong> pour cette entrée. L'exécution est distribuée et parallélisée sur le cluster, chaque noeud traitant les données qu'il porte localement. Pour ajouter une nouvelle spécialité à tous les vétérinaires, nous a
urions besoin d'un processeur comme celui ci&nbsp;:</p> <pre class="java code java" style="font-family:inherit"><span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">class</span> AddSpecialtyToVetsProcessor <span style="color: #7F0055; font-weight: bold;">extends</span> AbstractProcessor <span style="color: #000000;">&#123;</span>     <span style="color: #7F0055; font-weight: bold;">private</span> Specialty specialty;     <span style="color: #7F0055; font-weight: bold;">public</span> AddSpecialtyToVetsProcessor<span style="color: #000000;">&#40;</span>Specialty specialty<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>         <span style="color: #7F0055; font-weight: bold;">this</span>.<span style="color: #000000;">specialty</span> = specialty;     <span style="color: #000000;">&#125;</span>     <span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #000000;">Object</span> process<span style="color: #000000;">&#40;</span>InvocableMap.<span style="color: #000000;">Entry</span> entry<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>         Vet vet = <span style="color: #000000;">&#40;</span>Vet<span style="color: #000000;">&#41;</span> entry.<span style="color: #000000;">getValue</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;         <span style="color: #7F0055;font-weight: bold;">if</span> <span style="color: #000000;">&#40;</span>vet.<span style="color: #000000;">getSpecialties</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>.<span style="color: #000000;">contains</span><span style="color: #000000;">&#40;</span>specialty<span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>             <span style="color: #7F0055; font-weight: bold;">return</span> <span style="color: #7F0055; font-weight: bold;">false</span>;         <span style="color: #000000;">&#125;</span>         vet.<span style="color: #000000;">addSpecialty</span><span style="color: #000000;">&#40;</span>specialty<span style="color: #000000;">&#41;</span>;         <span style="color: #7F0055; font-weight: bold;">return</span> <span style="color: #7F0055; font-weight: bold;">true</span>;     <span style="color: #000000;">&#125;</span> <span style="color: #000000;">&#125;</span></pre> <p>pour utiliser ce processeur sur toutes les entrée du cache, on utilise le <strong>AlwaysFilter</strong>, qui retourne toujours true.</p> <pre class="java code java" style="font-family:inherit">Specialty specialty = <span style="color: #7F0055; font-weight: bold;">new</span> Specialty<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>; specialty.<span style="color: #000000;">setName</span><span style="color: #000000;">&#40;</span><span style="color: #888888;">&quot;radiology&quot;</span><span style="color: #000000;">&#41;</span>; EntryProcessor processor = <span style="color: #7F0055; font-weight: bold;">new</span> AddSpecialtyToVetsProcessor<span style="color: #000000;">&#40;</span>specialty<span style="color: #000000;">&#41;</span>; getVetsCache<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>.<span style="color: #000000;">invokeAll</span><span style="color: #000000;">&#40;</span>AlwaysFilter.<span style="color: #000000;">INSTANCE</span>, processor<span style="color: #000000;">&#41;</span>;</pre> <h3>Ré-entrance des services</h3> <p>Il est impossible d'effectuer un appel réentrant depuis un processeur , c'est à dire accéder à une entrée du cache autre que celle qui est traitée actuellement. En effet, les accès au cache sont traités par un pool de thread et interdire les appels réentrant permet de ne pas bloquer le pool. Les caches Coherence sont groupées dans des services, qui ont chacun un pool de thread et une queue de messages. Tous les appels à un cache sont transmis au service qui le gère par la queue de message. Les services utilisent un modèle threadé, donc chaque message est traité par un thread du pool, un excès de message pourrait saturer le pool et provoquer un deadlock, avec les threads bloqués par en attente des appels réentrants qui ne peuvent êtres traités, faute de thread libre disponible. Pour prévenir ce type de problème, Coherence vérifie que le thread accédant au cache n'est pas un thread de son propre pool et le cas échéant déclenchera une exception avec comme message&nbsp;:</p> <pre> Assertion failed: poll() is a blocking call and cannot be called on the Service thread </pre> <h3>Conclusion</h3> <p>Les processeurs sont des outils très simple et puissants à utiliser pour gérer la concurrence et paralléliser de façon performante le traitement des données sur le cluster. En effet, le processeur est exécuté par le noeud qui porte la donnée, le traitement est atomique et sans lock, elle est pas belle la vie&nbsp;? On peut aussi faire un parallèle avec le select for update du SQL, qui verrouille les données le temps de la mise à jour, les autres accès à cette données attendant simplement que le précédent termine.</p> <p>Les sources sont téléchargeables&nbsp;: Sur GitHub</p> <pre class="bash code bash" style="font-family:inherit">git clone git:<span style="color: #000000; font-weight: bold;">//</span>github.com<span style="color: #000000; font-weight: bold;">/</span>obourgain<span style="color: #000000; font-weight: bold;">/</span>petclinic-coherence.git git checkout article6-end</pre> <p>En <a href="http://blog.zenika.com/public/Billet_311/petclinic-coherence-article6-end.zip">zip</a></p> <p>Index des articles de la série Coherence&nbsp;:</p> <ul> <li><a href="index.php?post/2011/08/12/Coherence-PetCinic">Introduction à Coherence: Part I</a></li> <li><a href="index.php?post/2011/08/25/Introduction-à-Coherence%3A-Part-II">Introduction à Coherence: Part II</a></li> <li><a href="index.php?post/2011/10/07/Introduction-à-Coherence%3A-Part-III">Coherence Part III&nbsp;: Filtres</a></li> <li><a href="index.php?post/2012/01/09/Coherence-Part-IV-%3A-extracteurs-et-recherches-distribuées-sur-le-cluster">Coherence Part IV&nbsp;: extracteurs et recherches distribuées sur le cluster</a></li> <li><a href="index.php?post/2012/01/03/Coherence-Part-IV-%3A-optimisations-des-requêtes-avec-des-index6">Coherence Part V&nbsp;: optimisations des requêtes avec des index</a></li> <li><a href="index.php?post/2012/01/06/Coherence-Part-VI-%3A-traitement-de-données-distribuées%2C-in-place-processing4">Coherence Part VI&nbsp;: traitement de données distribuées, concurrence et in-place processing</a></li> </ul>