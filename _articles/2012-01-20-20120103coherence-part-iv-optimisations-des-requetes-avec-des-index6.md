---
ID: 406
post_title: 'Coherence Part V : optimisations des requêtes avec des index'
author: team-bourgain-tinon
post_date: 2012-01-20 11:30:00
post_excerpt: |
  <p>Dans l'<a href="http://blog.zenika.com/index.php?post/2012/01/09/Coherence-Part-IV-%3A-extracteurs-et-recherches-distribu%C3%A9es-sur-le-cluster">article précédent</a>, nous évoquions la possibilité de créer un index sur le cache afin d'accélérer les recherches en évitant de de-sérialiser l'ensemble des entrées du cache pour appliquer le filtre. Nous allons voir comment faire&nbsp;!</p>
layout: post
permalink: http://blog.zenika-offres.com/?p=406
published: true
slide_template:
  - ""
---
<p>Dans l'<a href="http://blog.zenika.com/index.php?post/2012/01/09/Coherence-Part-IV-%3A-extracteurs-et-recherches-distribu%C3%A9es-sur-le-cluster">article précédent</a>, nous évoquions la possibilité de créer un index sur le cache afin d'accélérer les recherches en évitant de de-sérialiser l'ensemble des entrées du cache pour appliquer le filtre. Nous allons voir comment faire&nbsp;!</p>
<!--more-->
<h3>Anatomie d'un index</h3> <p>Un index Coherence est en réalité une map qui fait correspondre les éléments indexés aux entrées du cache qui les contiennent. Un parcours de l'index est beaucoup plus rapide que de parcourir le cache en de-sérialisant toutes les entrées. Dans le cas d'un cache distribué, l'index est répartit sur le cluster. Chaque nœud du cluster est responsable de l'indexation des données qu'il porte, le parcours de l'index est donc distribué.</p> <p>Un index peut être ordonné ou non. Un index ordonné sera plus efficace pour faire des requêtes sur un intervalle ou ensemble de valeurs telles que "toutes les consultations vétérinaires entre deux dates" ou "tous les animaux dont le nom commence par 'A'", alors qu'un index non ordonné sera préférable pour des requêtes d'égalité. L'index non ordonné sera aussi plus rapide à mettre à jour puisque les modifications ne nécessitent pas de maintenir l'ordre.</p> <p>Il existe deux types d'index, les index "reverse" et les index "forward". Un index reverse va faire correspondre les valeurs de l'index aux clés des entrées qui portent la valeur. L'index forward fait correspondre des clés aux valeurs. Notez que dans ces phrases, valeur fait référence au champs qui est indexé, et pas à la value au sens de Map. L'index reverse permet de retrouver les entrées du cache pour lesquelles l'attribut indexé correspond au critère donné, c'est cet index qui va nous intéresser pour le moment. L'index forward permet de garder de-sérialisé l'ensemble des valeurs d'un attribut, nous l'utiliserons dans un prochain article.</p> <p><img src="/wp-content/uploads/2015/07/index.jpg" alt="index.jpg" /> <br /></p> <h3>Création et utilisation d'un index</h3> <p>Un index est très simple à créer, il suffit d'appeler la méthode <strong>addIndex()</strong> de <strong>QueryMap</strong>, qui est implémentée par les <strong>NamedCache</strong>s de Coherence. Cette méthode prend en paramètre un extracteur, un booléen indiquant si l'index doit être trié et un <strong>Comparator</strong> pour effectuer le tri. Un index peut être ajouté plusieurs fois sans problèmes, l'ajout un index avec le même extracteur, ordonné ou non et le même Comparator, qui existe déjà sera détecté et l'index ne sera créé qu'une seule fois, il n'y a pas d'inquiétudes à avoir là dessus. Tous les noeuds peuvent donc déclarer les index. <br />
Dans le <strong>DataInitializer</strong>, nous allons créer une méthode pour ajouter les index et l'appeler dans la méthode <strong>contextInitialized()</strong> qui pour rappel est appelée une fois que le ServletContext a démarré.</p> <pre class="java code java" style="font-family:inherit"><span style="color: #7F0055; font-weight: bold;">private</span> <span style="color: #7F0055; font-weight: bold;">void</span> initializeIndices<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> 	ownerCache.<span style="color: #000000;">addIndex</span><span style="color: #000000;">&#40;</span><span style="color: #7F0055; font-weight: bold;">new</span> PetIdsExtractor<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>, <span style="color: #7F0055; font-weight: bold;">false</span>, <span style="color: #7F0055; font-weight: bold;">null</span><span style="color: #000000;">&#41;</span>; <span style="color: #000000;">&#125;</span> &nbsp; <span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">void</span> contextInitialized<span style="color: #000000;">&#40;</span>ServletContextEvent sce<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> 	... 	<span style="color: #000000;">initializeIndices</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>; <span style="color: #000000;">&#125;</span></pre> <p>Pour utiliser un index, il faut faire une requête sur le cluster avec un filtre et ce filtre doit utiliser l'extracteur ayant servi à créer l'index. Pensez à implémenter <strong>equals()</strong> et <strong>hashCode()</strong> dans vos extracteurs.</p> <pre class="java code java" style="font-family:inherit">@Override <span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">int</span> hashCode<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> 	<span style="color: #7F0055; font-weight: bold;">return</span> <span style="color: #cc66cc;">31</span>; <span style="color: #000000;">&#125;</span> &nbsp; @Override <span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">boolean</span> equals<span style="color: #000000;">&#40;</span><span style="color: #000000;">Object</span> obj<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>     <span style="color: #7F0055;font-weight: bold;">if</span> <span style="color: #000000;">&#40;</span><span style="color: #7F0055; font-weight: bold;">this</span> == obj<span style="color: #000000;">&#41;</span>         <span style="color: #7F0055; font-weight: bold;">return</span> <span style="color: #7F0055; font-weight: bold;">true</span>;     <span style="color: #7F0055;font-weight: bold;">if</span> <span style="color: #000000;">&#40;</span>obj == <span style="color: #7F0055; font-weight: bold;">null</span><span style="color: #000000;">&#41;</span>         <span style="color: #7F0055; font-weight: bold;">return</span> <span style="color: #7F0055; font-weight: bold;">false</span>;     <span style="color: #7F0055;font-weight: bold;">if</span> <span style="color: #000000;">&#40;</span>getClass<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> == obj.<span style="color: #000000;">getClass</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>         <span style="color: #7F0055; font-weight: bold;">return</span> <span style="color: #7F0055; font-weight: bold;">true</span>;     <span style="color: #7F0055; font-weight: bold;">return</span> <span style="color: #7F0055; font-weight: bold;">false</span>; <span style="color: #000000;">&#125;</span></pre> <p>La requête de <strong>loadPet()</strong>, qui utilise un <strong>PetIdsExtractor</strong> va automatiquement faire appel à l'index.</p> <p>L'index est mis à jour de façon synchrone, chaque ajout, modification ou suppression des entrées du cache va donc déclencher une mise à jour des données concernées dans l'index avec le retour de la fonction. Cela permet de garantir la consistance de l'index mais si il y a de nombreux index à maintenir ou si les extracteurs sont coûteux, il peut y avoir une dégradation des performances. L'ajout d'un index sur un cache contenant déjà des données va déclencher leur indexation de façon synchrone là aussi, la méthode <strong>addIndex()</strong> termine après l'indexation complète du cache.</p> <h3>Un index partiel</h3> <p>Dans certains cas il est préférable de ne pas indexer l'ensemble des entrées d'un cache, par exemple dans le cas où un petit nombre d'entrées ont un attribut que nous souhaitons utiliser dans les requêtes tandis que pour les autres entrées cet attribut ne nous intéresse pas. On peut par exemple vouloir indexer uniquement les <strong>Owner</strong> qui ont une adresse, en évitant de maintenir un ensemble d'entrées associées à une adresse null. Pour cela, il est possible d'utiliser un <strong>ConditionalIndex</strong>, qui prend un filtre et un extracteur en paramètre. Les seules entrées indexées seront celles pour lesquelles le filtre a retourné true.</p> <pre class="java code java" style="font-family:inherit">ValueExtractor extractor = <span style="color: #7F0055; font-weight: bold;">new</span> ReflectionExtractor<span style="color: #000000;">&#40;</span><span style="color: #888888;">&quot;getAddress&quot;</span><span style="color: #000000;">&#41;</span>; Filter filter = <span style="color: #7F0055; font-weight: bold;">new</span> NotEqualsFilter<span style="color: #000000;">&#40;</span><span style="color: #888888;">&quot;getAddress&quot;</span>, <span style="color: #7F0055; font-weight: bold;">null</span><span style="color: #000000;">&#41;</span>; ConditionalExtractor conditionalExtractor = <span style="color: #7F0055; font-weight: bold;">new</span> ConditionalExtractor<span style="color: #000000;">&#40;</span>filter, extractor, <span style="color: #7F0055; font-weight: bold;">false</span><span style="color: #000000;">&#41;</span>; ownerCache.<span style="color: #000000;">addIndex</span><span style="color: #000000;">&#40;</span>conditionalExtractor, <span style="color: #7F0055; font-weight: bold;">false</span>, <span style="color: #7F0055; font-weight: bold;">null</span><span style="color: #000000;">&#41;</span>;</pre> <p>Dans notre cas, l'extracteur utilisé pour le filtre et pour générer l'index sont les mêmes, mais on pourrait aussi utiliser des extracteurs différents.</p> <h3>Traps and pitfalls</h3> <p>L'index utilisé par Coherence étant de type <strong>HashSet</strong>, dans le cas de l'utilisation de plusieurs index dans une même requête, le résultat peut être peu efficace, voir contre productif. En effet, si la recherche se fait sur deux ensembles qui peuvent contenir beaucoup d'éléments, par exemple dans le cas de PetClinic, la recherche de tous les <strong>Owner</strong>s qui ont une adresse et un numéro de téléphone sur deux index différents, la recherche va créer un set contenant tous les <strong>Owner</strong>s ayant une adresse, un autre set contenant tous les  <strong>Owner</strong>s ayant un numéro de téléphone puis réaliser l'intersection en parcourant toutes les entrées de l'un des sets et en comparant chacune de ces entrées avec l'ensemble de l'autre set. Si la requête est lancé sans index, Coherence va simplement de-sérialiser chaque entrée du cache, appliquer le filtre sur les adresses, le cas échéant appliquer le filtre sur les numéros. Comme pour une base de données, il est donc important de mesurer l'efficacité de l'index.</p> <p>De plus, Coherence ne fait pas d'optimisation globale de la requête. Pour les requêtes sur de multiples critères, l'ordre dans lequel les filtres sont appliqués est donc important. Le résultat du premier filtre est passé au suivant, mesurer l'impact du chan
gement d'ordre des filtres est donc une piste d'optimisation si vous avez des requêtes lentes.</p> <p>Les sources sont téléchargeables&nbsp;: Sur GitHub</p> <pre class="bash code bash" style="font-family:inherit">git clone git:<span style="color: #000000; font-weight: bold;">//</span>github.com<span style="color: #000000; font-weight: bold;">/</span>obourgain<span style="color: #000000; font-weight: bold;">/</span>petclinic-coherence.git git checkout article5-end</pre> <p>En<a href="http://blog.zenika.com/public/Billet_307/petclinic-coherence-article5-end.zip">zip</a></p> <p>Index des articles de la série Coherence&nbsp;:</p> <ul> <li><a href="index.php?post/2011/08/12/Coherence-PetCinic">Introduction à Coherence: Part I</a></li> <li><a href="index.php?post/2011/08/25/Introduction-à-Coherence%3A-Part-II">Introduction à Coherence: Part II</a></li> <li><a href="index.php?post/2011/10/07/Introduction-à-Coherence%3A-Part-III">Coherence Part III&nbsp;: Filtres</a></li> <li><a href="index.php?post/2012/01/09/Coherence-Part-IV-%3A-extracteurs-et-recherches-distribuées-sur-le-cluster">Coherence Part IV&nbsp;: extracteurs et recherches distribuées sur le cluster</a></li> <li><a href="index.php?post/2012/01/03/Coherence-Part-IV-%3A-optimisations-des-requêtes-avec-des-index6">Coherence Part V&nbsp;: optimisations des requêtes avec des index</a></li> <li><a href="index.php?post/2012/01/06/Coherence-Part-VI-%3A-traitement-de-données-distribuées%2C-in-place-processing4">Coherence Part VI&nbsp;: traitement de données distribuées, concurrence et in-place processing</a></li> </ul>