---
ID: 135
post_title: Creating a Varnish 4 module
author: dboukelmoune
post_date: 2013-07-31 10:00:00
post_excerpt: |
  |
    <p>Don't let the title fool you, Varnish 4 hasn't been released yet. However, the master branch (which holds Varnish 4 developments) in its current state should be close enough to what the first release will look like. I've been bitten by API changes several times, but that's the deal when writing code against work in progress<sup>[<a href="#pnote-415-1" id="rev-pnote-415-1">1</a>]</sup>.</p> <div class="footnotes"><h4 class="footnotes-title">Note</h4> <p>[<a href="#rev-pnote-415-1" id="pnote-415-1">1</a>] Last tested against the revision <code>d0c0ee9</code></p></div>
layout: post
permalink: http://blog.zenika-offres.com/?p=135
published: true
---
<p>Don't let the title fool you, Varnish 4 hasn't been released yet. However, the master branch (which holds Varnish 4 developments) in its current state should be close enough to what the first release will look like. I've been bitten by API changes several times, but that's the deal when writing code against work in progress<sup>[<a href="#pnote-415-1" id="rev-pnote-415-1">1</a>]</sup>.</p> <div class="footnotes"><h4 class="footnotes-title">Note</h4> <p>[<a href="#rev-pnote-415-1" id="pnote-415-1">1</a>] Last tested against the revision <code>d0c0ee9</code></p></div>
<!--more-->
<h3>What's new in Varnish 4&nbsp;?</h3> <p>I will simply copy/paste an answer from <a href="https://www.varnish-software.com/blog/qa-you-can-cache-everything-webinar">Varnish Software</a> (blame my laziness on this one):</p> <blockquote>  <p>   The 4.0 release is underway and should be released after the summer, with a   prerelease during the summer, hopefully. The main new features are:  </p>  <ul>   <li>    New logging framework (see this blog post    <a href="https://www.varnish-software.com/blog/varnishlog-query-language">    https://www.varnish-software.com/blog/varnishlog-query-language</a>)   </li>   <li>Increased performance (multiple acceptor threads, amongst others)</li>   <li>    HTTP 2.0 compatible architecture. HTTP 2.0 is still far away, but the    internals are being reworked in order to fit with what the specs are going to    look like   </li>   <li>    Directors in vmods. You can now write a director in a vmod. Should make it a    lot easier to write a new director.   </li>  </ul>  <p>   In addition there are numerous improvements that will allow us to add features   quicker.  </p> </blockquote> <p>The last point about directors is the one I'm interested in in this post. The fact that <em>directors</em> are now declared programmatically offers even more flexibility. You can now make Varnish serve static contents by simply writing a <em>director</em> that fetches resources from the filesystem instead of over HTTP, or can you&nbsp;? Anyway, this changeset doesn't really give any clue on what's new for VMOD developers.</p> <h3>What's new for VMOD developers&nbsp;?</h3> <p>The short answer is:</p> <blockquote><p>Most probably more than I could tell you.</p></blockquote> <p>So I'll do my best to list and describe significant changes for VMODs, but I do not claim completeness. As my experience with VMODs is a bit limited to those I've built, so is my knowledge of Varnish internals. I'll try to point changes in the code related to the changes listed above.</p> <h4>New logging framework</h4> <p>I don't know whether it is actually related, but the logging API changed. With Varnish 3 you would use <code>WSP</code> and <code>WSPR</code> macros:</p> <pre> struct sess *sp; [...] WSP(sp, SLT_Debug, &quot;%s&quot;, &quot;printf-like logging&quot;); </pre> <p>Varnish 4 introduces two equivalent functions, respectively <code>VSLb</code> and <code>VSLbt</code>. It works exactly the same, besides being functions instead of macros, except that the <code>sess</code> pointer is replaced by a <code>vsl_log</code> pointer:</p> <pre> struct vsl_log *vsl; [...] VSLb(vsl, SLT_Debug, &quot;%s&quot;, &quot;printf-like logging&quot;); </pre> <p>With this, <code>varnishtest</code> introduces a new <code>expectlog</code> instruction and a new <code>-errvcl</code> argument that seems to replace the <code>-badvcl</code> one for Varnish servers, with the expected message explaining why the VCL won't compile.</p> <h4>Architecture</h4> <p>The changes in the architecture to allow alternative protocols like SPDY (which is the starting point of the HTTP 2.0 draft) also mean a lot of changes in the code.</p> <h5>Function signatures</h5> <p>Varnish 3 passes a <code>sess</code> pointer to the VMOD functions, it is replaced by a <code>vrt_ctx</code> pointer in Varnish 4. This structure is described as a composite object, it holds other objects (req, bereq, ...) needed throughout the VCL.</p> <h5>Includes</h5> <p>Some files have moved, including headers. This is not a big deal, but at least I've noticed a new <code>bin/varnishd/cache/</code> directory containing the <code>cache.h</code> header I use a lot, and all corresponding <code>cache_*.c</code>.</p> <h5>Objects</h5> <p>This time I'm talking about objects as in <em>Object-Oriented Programming</em>. The kind of programming that talks to the <em>enterprisey</em> developer I am. With Varnish 4, you can now manipulate objects in your VCL. But don't run away, it's just a means to keep track of <em>state</em>.</p> <p>With Varnish 3, you can make stateful functions in your VMODs, and you would use <a href="https://www.varnish-cache.org/docs/3.0/reference/vmod.html#private-pointers">Private Pointers</a> to keep track of state. With Varnish 4, you can also declare objects that will encapsulate both state and behavior (nothing fancy like inheritance or whatever sounds too much enterprisey). The key difference is that it creates a named variable in the VCL, where private pointers OTOH must be handled entirely in the VMOD space (in any case Varnish does the housekeeping).</p> <h4>Directors in VMODs</h4> <p>This change means a lot for both Varnish users and VMOD creators. Instead of declaring backends and directors declaratively, you need to declare them in the <code>vcl_init</code> and <code>vcl_fini</code> functions. You'll lose a bit of readability, a small cost for the flexibility it gives&nbsp;: you can now have not only backends in a director, but also other directors.</p> <h5>VCL</h5> <p>From the man page:</p> <blockquote><p>A director is a logical group of backend servers clustered together for redundancy. The basic role of the director is to let Varnish choose a backend server amongst several so if one is down another can be used.</p></blockquote> <p>With Varnish 3 you create directors declaratively in similar fashion to backends:</p> <pre> backend node1 {   .host = &quot;192.168.1.1&quot;;   .port = &quot;http&quot;; } backend node2 {   .host = &quot;192.168.1.2&quot;;   .port = &quot;http&quot;; } director my_cluster round-robin {   { .backend = node1; }   { .backend = node2; } } sub vcl_recv {   set req.backend = my_cluster; } </pre> <p>With Varnish 4 it's different, you would do it this way:</p> <pre> import directors; backend node1 {   .host = &quot;192.168.1.1&quot;;   .port = &quot;http&quot;; } backend node2 {   .host = &quot;192.168.1.2&quot;;   .port = &quot;http&quot;; } sub vcl_init {   new rr = directors.round_robin();   rr.add_backend(node1);   rr.add_backend(node2); } sub vcl_recv {   set req.backend = rr.backend(); } </pre> <p>You may remember I said earlier that you can now put directors behind other directors. This allows new network topologies behind your Varnish like active/passive clusters with a combination of fallback and round robin directors.</p> <pre> import directors; backend active_node1 {   .host = &quot;192.168.1.1&quot;;   .port = &quot;http&quot;; } backend active_node2 {   .host = &quot;192.168.1.2&quot;;   .port = &quot;http&quot;; } backend passive_node1 {   .host = &quot;192.168.2.1&quot;;   .port = &quot;http&quot;; } backend passive_node2 {   .host = &quot;192.168.2.2&quot;;   .port = &quot;http&quot;; } sub vcl_init {   new active_rr = directors.round_robin();   active_rr.add_backend(active_node1);   active_rr.add_backend(active_node2);   new passive_rr = directors.round_robin();   passive_rr.add_backend(passive_node1);   passive_rr.add_backend(passive_node2);   new fb = directors.fallback();   fb.add_backend(active_rr);   fb.add_backend(passive_rr); } sub vcl_recv {   set req.backend = fb.backend(); } </pre> <h5>Build scripts</h5> <p>Since directors have been moved to a <em>director</em> VMOD, the <em>std</em> is not the sole VMOD in the Varnish source tree anymore (there's also a new <em>debug</em> module).</p> <p>The VMOD build scripts have been moved to <code>lib/libvcl/</code>, a small change to do in your <em>makefile</em>.</p> <h5>Objects</h5> <p>To declare objects, in the <em>VCC</em>, the syntax looks like:</p> <pre> Module blog Object my_object( [...] ) { 	Method VOID .do_something( [...] ); 	Method STRING .return_something( [...] ); } # [...] means you can add parameter types </pre> <p>The generated header looks like:</p> <pre> /*  * NB:  This file is machine generated, DO NOT EDIT!  *  * Edit vmod.vcc and run vmod.py instead  */ struct vrt_ctx; struct VCL_conf; struct vmod_priv; struct vmod_blog_my_object; VCL_VOID vmod_my_object__init(const struct vrt_ctx *, struct vmod_blog_my_object **, const char *[, ...]); VCL_VOID vmod_my_object__fini(struct vmod_blog_my_object **); VCL_VOID vmod_my_object_do_something(const struct vrt_ctx *, struct vmod_blog_my_object *[,
 ...]); VCL_STRING vmod_my_object_return_something(const struct vrt_ctx *, struct vmod_blog_my_object *[, ...]); </pre> <p>Well, this is C, so you don't really have objects. Instead, there is a <code>vmod_&lt;module_name&gt;_&lt;object_name&gt;</code> structure you need to define, this is where you keep track of state. The structure is then transmitted to the object <em>methods</em>, that is to say functions following the <code>vmod_&lt;module_name&gt;_&lt;object_name&gt;_&lt;method_name&gt;</code> naming scheme.</p> <p>Varnish expects two special functions (<code>init</code> and <code>fini</code>) which act as constructor and destructor. Free nitpick, the destructor call doesn't seem to be implemented yet (more on that later).</p> <p>In your VCL, you would use the new keyword <code>new</code> to instantiate a <em>named</em> object:</p> <pre> sub vcl_init { 	new my_instance = blog.my_object( [...] ); } sub vcl_recv { 	my_instance.do_something( [...] ); } </pre> <p>This is stateful made easy&nbsp;!</p> <h5>A word on objects</h5> <p>The funny thing with Varnish is that the code base looks Object Oriented-ish. A lot of <em>objects</em> consists in a structure with a <code>magic</code> field that serves as a sort-of weak runtime type system. Let's take the same example as in my <a href="http://blog.zenika.com/index.php?post/2012/08/21/Creating-a-Varnish-module">previous post</a>: the workspace structure.</p> <p>First, there is the structure, holding the state:</p> <pre> struct ws {         unsigned                magic; #define WS_MAGIC                0x35fac554         unsigned                overflow;       /* workspace overflowed */         const char              *id;            /* identity */         char                    *s;             /* (S)tart of buffer */         char                    *f;             /* (F)ree/front pointer */         char                    *r;             /* (R)eserved length */         char                    *e;             /* (E)nd of buffer */ }; </pre> <p>And then you get all the <code>WS_*</code> functions that serve as methods, they all take a <code>struct ws*</code> as the first argument (call that <code>this</code> or <code>self</code> or whatever your favorite OOP language chose to reference the current instance). The <code>WS_Init</code> function acts as some sort of constructor.</p> <p>Of course it doesn't provide the same level of visibility than say, Java. And I could easily mess with a <code>ws</code> structure and perform direct writes to its fields ignoring the <em>methods</em>. That is not the case for the workspace API, but private methods are emulated with static functions. If there were private methods for <code>ws</code> objects, the function names would probably be in lower case (eg. <code>static ws_garbage_collect</code>).</p> <p>It's also probably worth mentioning the <code>CHECK_OBJ_NOTNULL</code> macro that takes a pointer and a magic number, and check whether the pointer is not null and seems to reference the right structure (there's no guarantee, but still a valuable check). And also the <code>CAST_OBJ_NOTNULL</code> is similar but allows to copy and cast the reference to another pointer. Two other macros come handy for such structures, <code>ALLOC_OBJ</code> and <code>FREE_OBJ</code>. Better know them when working with backends.</p> <h5>Working with backends</h5> <p>Varnish 4 introduces a new type on the VMOD side: <code>VCL_BACKEND</code>. The name is a bit misleading though, because it isn't defined as a pointer to a <code>backend</code> structure, but to a <code>director</code> structure instead. This is because backends are abstracted to directors, which gives the flexibility to put a <em>director</em> behind another <em>director</em> as shown above.</p> <p>As for backends themselves, they are wrapped into a <code>vdi_simple</code> structure, which is a single-backend director.</p> <h3>Creating a Varnish 4 module then&nbsp;?</h3> <p>After this <em>short</em> introduction, it is finally time to build the VMOD, but what VMOD&nbsp;?</p> <h4>The goal</h4> <p>The one thing I'd always wanted to do since I know Varnish is to use it to serve static contents. But this is Varnish Cache, and by design it is meant to only speak HTTP. I've even written a VCL to do that, using <code>std.fileread</code>, but it doesn't work with binary files, and it didn't work properly even with text files, and it was fun but pointless. So this time, I've tried to leverage the new <em>programmatic directors</em> feature to achieve this, but it failed. The VMOD is called <code>libvmod-fsdirector</code>.</p> <h4>What The Fail&nbsp;?</h4> <p>A quick side note to explain how and why I've failed. In order to create a director, you need a <code>director</code> structure:</p> <pre> struct director {         unsigned                magic; #define DIRECTOR_MAGIC          0x3336351d         const char              *name;         char                    *vcl_name;         vdi_getfd_f             *getfd;         vdi_fini_f              *fini;         vdi_healthy             *healthy;         void                    *priv; }; </pre> <p>It looks quite self-describing in my opinion. You need a function to provide a file descriptor that your director knows how to pick. Another function is used to know whether the director is healthy or not (it depends on you definition of healthy). You are also given a private pointer to keep track of your state and you have to provide a function to clean it up. If you want to write a director like the built-in ones, you can't reuse the function that take care of all the boilerplate.</p> <p>So this looks fairly simple, right&nbsp;? Yes but... There always is a "but". The problem here is that I'm trying to build a backend through the director facility. I'm trying to create a server thread <em>AND</em> a varnish backend, all with the director API. If you haven't spotted the problem, please re-read the previous statement.</p> <h5>First attempt - naive</h5> <p>Create an object with a method that returns a <code>VCL_BACKEND</code>, just like built-in directors. Everything is created once in the constructor. Since we're not actually creating a director per-se (we are not putting existing backends or directors behind it) we need a dummy backend.</p> <pre> import fsdirector; backend dummy {         .host = &quot;127.0.0.1&quot;;         .port = &quot;8080&quot;; } sub vcl_init {         new fs = fsdirector.file_system(); } sub vcl_recv {         set req.backend = fs.backend(); } </pre> <p>This one failed because I've tried to programmatically create the backend, register it, and return it as a genuine native backend. It probably failed because registration needed a <code>CLI</code> object. Anyway, it was fun to try, and at least it made obvious to me that I wasn't trying to build a director at all.</p> <h5>Second attempt - pragmatic</h5> <p>Declare a backend in the VCL, pass it to the VMOD so that a server thread can be created accordingly. No director involved. I've also tried to enhance the backend, but it failed. If the backend had a nul port, I would bind a dynamic port in the server thread and change the port in the <code>vrt_backend</code> structure but it didn't work. So instead I can only declare a backend with the desired port and the server thread will listen to this very port.</p> <pre> import fsdirector; backend static {         .host = &quot;127.0.0.1&quot;;         .port = &quot;8080&quot;; } sub vcl_init {         new fs = fsdirector.file_system(static, &quot;/var/www&quot;); } </pre> <p>This second attempt which succeded (minus dynamic binding) is the actual goal this module is trying to reach. We just have to build it then.</p> <h4>The build</h4> <p>Since we're going to make VMOD for Varnish 4, we need a few changes in the build system. I'm talking of course about <a href="http://github.com/varnish/libvmod-example">libvmod-example</a>'s build system.</p> <h5>autoconf</h5> <p>In the <code>configure.ac</code> file, we need to ensure we have a Varnish *4* source tree. At least I have decided I wanted to make sure of that, this part is actually optional.</p> <p>You can use this to
 check the new VMOD facility:</p> <pre> AC_CHECK_FILE(        [$VARNISHSRC/lib/libvcl/vmodtool.py],        [],        [AC_MSG_FAILURE([&quot;$VARNISHSRC&quot; is not a Varnish 4 source directory])] ) </pre> <h5>automake</h5> <p>In the <code>src/Makefile.am</code>, we can then use this very script to generate the <code>vcc_if.*</code> files:</p> <pre> vcc_if.c vcc_if.h: vmod_fsdirector.vcc 	@PYTHON@ $(VARNISHSRC)/lib/libvcl/vmodtool.py vmod_fsdirector.vcc </pre> <p>I've also decided to tweak the includes to add <code>varnishd</code> in my include path in order to (lazily) include <code>"cache/cache*.h"</code> instead of <code>"bin/varnishd/cache/cache*.h"</code>.</p> <pre> INCLUDES = -I$(VARNISHSRC)/include             -I$(VARNISHSRC)/bin/varnishd             -I$(VARNISHSRC) </pre> <p>And since it's using <code>libmagic</code> which definitely *is* magic, let's add the flag:</p> <pre> libvmod_fsdirector_la_LIBADD = -lmagic </pre> <h5>vcc</h5> <p>As stated before, I didn't manage to create a proper <em>director</em>, so instead of having something similar to what we find in <code>vmod-directors</code>, we simply declare an object without methods (only a constructor and the implicit destructor).</p> <pre> Module fsdirector Object file_system(BACKEND, STRING) { } </pre> <h4>The implementation</h4> <p>Unlike the name suggests, <em>fsdirector</em> does not provide a new director, this approach failed. Probably my wrongdoing... So instead, this VMOD spawns a thread that will listen to requests and serve responses from the filesystem. You only need to declare a backend on <em>localhost</em>, and pass it to the constructor and the module creates a server thread according to the backend's properties.</p> <pre> backend static {         .host = &quot;127.0.0.1&quot;;         .port = &quot;8080&quot;; } sub vcl_init {         new fs = fsdirector.file_system(static, &quot;/var/www&quot;); } </pre> <p>With this sample, we create a server thread that listens on the port <code>8080</code> and serves files from <code>/var/www</code>.</p> <h5>The object</h5> <p>This is probably not the best example, since the object has no method, but the point is still valid since there implicitly is a destructor. Since we declare an object, we need to provide the structure that will hold the state between method calls. In this module it looks like this:</p> <pre> struct vmod_fsdirector_file_system {         unsigned                 magic; #define VMOD_FSDIRECTOR_MAGIC    0x94874A52         const char               *root;         struct vdi_simple        *vs;         int                      sock;         struct vss_addr          **vss_addr;         char                     port[6];         char                     sockaddr_size;         struct sockaddr_in       sockaddr;         pthread_t                tp;         struct worker            *wrk;         struct http_conn         htc;         magic_t                  magic_cookie;         char                     *thread_name;         char                     *ws_name; }; </pre> <p>The first field is not required, but doesn't cost much and can be used for defensive programming to make sure you are given the right structure. There are various fields, some of them using Varnish data structures, such as the vile <code>vdi_simple</code>.</p> <h5>The <code>vdi_simple</code> gate</h5> <p>As I explained before, we are not supposed to manipulate backends directly, they are wrapped inside a <code>vdi_simple</code> structure so that everything can be handled as directors. This is a nice approach, except that it prevents from reading the backend's data in the VMOD space. So I came up with a brittle workaround that consists in copying the structure in the VMOD's source:</p> <pre> /*--------------------------------------------------------------------  * Stolen from bin/varnishd/cache/cache_backend.c  */ struct vdi_simple {         unsigned                magic; #define VDI_SIMPLE_MAGIC        0x476d25b7         struct director         dir;         struct backend          *backend;         const struct vrt_backend *vrt; }; </pre> <p>Notice the <code>backend</code> and <code>vrt_backend</code> structure&nbsp;? That's a lot of code to read that piles up to understand which is responsible for what. As for the <code>vdi_simple</code> object,  I can retrieve such a structure from the <code>priv</code> field of the <code>director</code> structure, the one I get from the VCL.</p> <pre> // include/vrt.h typedef struct director *               VCL_BACKEND; // bin/varnishd/cache/cache_backend.h struct director {         unsigned                magic; #define DIRECTOR_MAGIC          0x3336351d         const char              *name;         char                    *vcl_name;         vdi_getfd_f             *getfd;         vdi_fini_f              *fini;         vdi_healthy             *healthy;         void                    *priv; }; </pre> <p>So how do we use all that in the constructor&nbsp;? Let's write the implementation of the generated signature of <code>vmod_file_system__init</code>:</p> <pre> VCL_VOID vmod_file_system__init(const struct vrt_ctx *ctx,     struct vmod_fsdirector_file_system **fsp,     const char *vcl_name, VCL_BACKEND be, const char *root) {         struct vmod_fsdirector_file_system *fs;         struct vdi_simple *vs;         AN(ctx);         AN(fsp);         AN(vcl_name);         AZ(*fsp);         CHECK_OBJ_NOTNULL(be, DIRECTOR_MAGIC);         CAST_OBJ_NOTNULL(vs, be-&gt;priv, VDI_SIMPLE_MAGIC);         ALLOC_OBJ(fs, VMOD_FSDIRECTOR_MAGIC);         AN(fs);         *fsp = fs;         fs-&gt;vs = vs;         fs-&gt;thread_name = malloc(sizeof(&quot;fsthread-&quot;)    + strlen(vcl_name));         fs-&gt;ws_name     = malloc(sizeof(&quot;fsworkspace-&quot;) + strlen(vcl_name));         AN(fs-&gt;thread_name);         AN(fs-&gt;ws_name);         sprintf(fs-&gt;thread_name, &quot;fsthread-%s&quot;, vcl_name);         sprintf(fs-&gt;ws_name,  &quot;fsworkspace-%s&quot;, vcl_name);         AN(root);         assert(root[0] == ' ' || root[0] == '/');         fs-&gt;root = root;         [...]         server_start(fs); } </pre> <p>First, we have a few checks on the parameters, nothing unusual. The <code>fsp</code> pointer is expected to be <code>NULL</code> since it's the duty of the constructor to instantiate it.</p> <p>Then, we check the given director holds a <code>vdi_simple</code> object, and thus a backend, not a true <em>director</em>. Again this is might suffer breaking changes in the future.</p> <p>The next step allocates an <code>fsdirector</code> object, which implies a structure starting with a <code>magic</code> field. This not only saves me complexity by reusing Varnish's object utilities but I can also reuse the <code>CHECK_OBJ_NOTNULL</code> macro with my own structure.</p> <p>For the <code>root</code> argument, I went super lazy and only checked for either an empty string or something that looks like an absolute path, nothing more. And finally, I can start the server thread.</p> <p>So of course, anything allocated by the constructor must be freed by the destructor:</p> <pre> VCL_VOID vmod_file_system__fini(struct vmod_fsdirector_file_system **fsp) {         struct vmod_fsdirector_file_system *fs;         void *res;         // XXX It seems that the destructor is not called yet.         //     A little reminder then...         abort();         fs = *fsp;         *fsp = NULL;         CHECK_OBJ_NOTNULL(fs, VMOD_FSDIRECTOR_MAGIC);         AZ(pthread_cancel(fs-&gt;tp));         AZ(pthread_join(fs-&gt;tp, &amp;res));         assert(res == PTHREAD_CANCELED);         [...]         free(fs-&gt;thread_name);         free(fs-&gt;ws_name);         free(fs-&gt;wrk-&gt;aws);         FREE_OBJ(fs-&gt;wrk);         FREE_OBJ(fs); } </pre> <p>I haven't tested this yet for obvious reasons. Anyway, this is just a matter of time until this is implemented. Now for the <code>vdi_simple</code> usage, here is the <code>server_start</code> function called in the constructor:</p> <pre> static void server_start(struct vmod_fsdirector_file_system *fs) {         struct vdi_simple *vs;         const struct vrt_backend *be;         vs = fs-&gt;v
s;         be = vs-&gt;vrt;         AN(VSS_resolve(be-&gt;ipv4_addr, be-&gt;port, &amp;fs-&gt;vss_addr));         fs-&gt;sock = VSS_listen(fs-&gt;vss_addr[0], be-&gt;max_connections);         assert(fs-&gt;sock &gt;= 0);         WRK_BgThread(&amp;fs-&gt;tp, fs-&gt;thread_name, server_bgthread, fs); } </pre> <p>That's just a lazy reuse of Varnish's code to open a socket and start a worker thread (for me it means a thread with a workspace). I've written this module for fun, and to dig into Linux system calls and Varnish's code. This time Varnish won, even though I initially wrote it with the <em>socket</em> and <em>pthread</em> APIs.</p> <h5>The server thread</h5> <p>The worker thread is just a wrapper to a <em>pthread</em> which receives a <code>worker</code> structure and does whatever a worker does... The previous statement should make it obvious that choosing a Varnish worker thread over a standard <em>pthread</em> was just driven by fun and curiosity...</p> <p>The other big deal with this server thread is to actually listen to HTTP requests. So after a long thinking (of about half a second) I decided to look at what Varnish has to offer. And surprisingly, I managed to use an <code>http_conn</code> structure and some <code>HTTP1_*</code> functions. And without trying too hard, I had a simple HTTP listener:</p> <pre> static void * server_bgthread(struct worker *wrk, void *priv) {         struct vmod_fsdirector_file_system *fs;         struct sockaddr_storage addr_s;         socklen_t len;         struct http_conn *htc;         int fd;         enum htc_status_e htc_status;         CAST_OBJ_NOTNULL(fs, priv, VMOD_FSDIRECTOR_MAGIC);         assert(fs-&gt;sock &gt;= 0);         htc = &amp;fs-&gt;htc;         fs-&gt;wrk = wrk;         WS_Init(wrk-&gt;aws, fs-&gt;ws_name, malloc(WS_LEN), WS_LEN);         while (1) {                 do {                         fd = accept(fs-&gt;sock, (void*)&amp;addr_s, &amp;len);                 } while (fd &lt; 0 &amp;&amp; errno == EAGAIN);                 if (fd &lt; 0) {                         continue;                 }                 HTTP1_Init(htc, wrk-&gt;aws, fd, NULL, HTTP1_BUF, HTTP1_MAX_HDR);                 htc_status = HTTP1_Rx(htc);                 switch (htc_status) {                         case HTTP1_OVERFLOW:                         case HTTP1_ERROR_EOF:                         case HTTP1_ALL_WHITESPACE:                         case HTTP1_NEED_MORE:                                 prepare_answer(htc, 400);                                 prepare_body(htc);                                 break;                         case HTTP1_COMPLETE:                                 answer_appropriate(fs);                                 break;                 }                 WS_Reset(wrk-&gt;aws, NULL);                 close(fd);         }         pthread_exit(0);         NEEDLESS_RETURN(NULL); } </pre> <h3>Conclusion</h3> <p>For an article I initially intended to keep short, it's grown a bit more than I expected. If you're reading this, I hope you've enjoyed the post. I'm not covering the rest of the code, since it's just me playing with APIs I'm not familiar with, and not directly related to Varnish. I am aware of some security issues in the current code, and this is only a proof of concept, and a toy project. It also contains some <em>linuxisms</em>, so don't expect to build it on any other platform. The code is not <em>TODO-free</em>. You can find the full project on <a href="https://github.com/dridi/libvmod-fsdirector">GitHub</a>.</p>