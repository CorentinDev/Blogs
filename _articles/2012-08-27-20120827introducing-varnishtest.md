---
ID: 126
post_title: Introducing varnishtest
author: dboukelmoune
post_date: 2012-08-27 09:15:00
post_excerpt: |
  <p>When I first started working with Varnish, my only concerns were mostly configuration and a bit of administration. Depending on your needs (which can impressively become complex sometimes) you can reach the limits of Varnish in terms of features (especially if your needs are not directly linked to HTTP caching). In this case, you will probably need a module or create your own, and I've already shown you how to <a href="/index.php?post/2012/08/21/Creating-a-Varnish-module">make</a> one. I already knew that Varnish comes with a test framework, but I didn't expect it could also enable TDD for VMODs. I was lost when I first tried to read a test case, but I quickly found that the <code>varnishtest</code> framework is quite powerful and easy to use!</p>
layout: post
permalink: http://blog.zenika-offres.com/?p=126
published: true
---
<p>When I first started working with Varnish, my only concerns were mostly configuration and a bit of administration. Depending on your needs (which can impressively become complex sometimes) you can reach the limits of Varnish in terms of features (especially if your needs are not directly linked to HTTP caching). In this case, you will probably need a module or create your own, and I've already shown you how to <a href="/index.php?post/2012/08/21/Creating-a-Varnish-module">make</a> one. I already knew that Varnish comes with a test framework, but I didn't expect it could also enable TDD for VMODs. I was lost when I first tried to read a test case, but I quickly found that the <code>varnishtest</code> framework is quite powerful and easy to use!</p>
<!--more-->
<h3>A test framework&nbsp;?</h3> <p>When I stated earlier that Varnish comes with a test framework, I meant that you do have the <code>varnishtest</code> program when you install Varnish. It's not just a tool for the Varnish development team, nor a tool for VMOD creators. It's also a tool you can use to reproduce a bug when you file a bug report. If you look at the tests in Varnish's source tree, you can see a README:</p> <pre> Test-scripts for varnishtest ============================ Naming scheme ------------- 	The intent is to be able to run all scripts in lexicographic 	order and get a sensible failure mode. 	This requires more basic tests to be earlier and more complex 	tests to be later in the test sequence, we do this with the 	prefix/id letter: 		[id]%05d.vtc 	id ~ [a] --&gt; varnishtest(1) tests 	id ~ [b] --&gt; Basic functionality tests 	id ~ [c] --&gt; Complex functionality tests 	id ~ [e] --&gt; ESI tests 	id ~ [g] --&gt; GZIP tests 	id ~ [m] --&gt; VMOD tests 	id ~ [p] --&gt; Persistent tests 	id ~ [r] --&gt; Regression tests, same number as ticket 	id ~ [s] --&gt; Slow tests, expiry, grace etc. 	id ~ [t] --&gt; sTreaming tests 	id ~ [v] --&gt; VCL tests: execute VRT functions </pre> <p>As of Varnish 3.0.3, released a few days ago, there are 294 tests you can study before writing your own. And today I'll save you some time by showing the important parts of the VTC language.</p> <h3>The Varnish Test Case language</h3> <p>Many things in Varnish's architecture are impressive for me. The design of a <acronym title="Domain Specific Language">DSL</acronym> for the configuration is one example, but I didn't expect I would find another DSL for testing when I first used with Varnish. The VTC is really easy to both write and read, but you need a small mental shift (at least I needed) because it doesn't follow the <em>set up/test/assert/tear down</em> or <em>given/when/then</em> patterns. Depending on your scenario, there might be test preparations, executions and assertions all over the place. Unlike the VCL, the VTC is not compiled but simply interpreted on the fly.</p> <p>First of all, a test has a name:</p> <pre> varnishtest &quot;Test example vmod&quot; </pre> <h4>Starting a varnishd instance</h4> <p>The thing about <code>varnishtest</code> is that it launches a real Varnish instance and interacts with it. It launches the <code>varnishd</code> instance, controls it through the management process and makes assertions based on the <em>shared memory logs</em>. It makes tests really slow (like a hundred milliseconds slow every time an expected value has yet to be found) but it actually tests the real product.</p> <p>The Varnish instance needs a name. You can optionally configure it or just rely on the default VCL. If you are testing a VMOD, you can import it with an absolute file name.</p> <pre> varnish v1 -vcl+backend { 	import example from &quot;${vmod_topbuild}/src/.libs/libvmod_example.so&quot;; 	sub vcl_deliver { 		set resp.http.hello = example.hello(&quot;World&quot;); 	} } -start </pre> <p>The instance can be started later...</p> <pre> varnish v1 -vcl+backend { 	import example from &quot;${vmod_topbuild}/src/.libs/libvmod_example.so&quot;; 	sub vcl_deliver { 		set resp.http.hello = example.hello(&quot;World&quot;); 	} } [...] varnish v1 -start </pre> <p>If you fork the <a href="https://github.com/varnish/libvmod-example">libvmod-example</a> module, your <em>autotools</em> configuration will run <code>varnishtest</code> with the <code>vmod_topbuild</code> macro. It works like Java system properties in the command line: <code>-Dkey=value</code>.</p> <p>The <code>-vcl+backend</code> directive automatically injects the backend into the VCL, which most of the time is what you want to do. Sometimes you might have several backends (load balanced for instance) so you might want to do it manually:</p> <pre> varnish v1 -vcl { 	import example from &quot;${vmod_topbuild}/src/.libs/libvmod_example.so&quot;; 	# you'll learn how to run a &quot;s1&quot; server 	backend default { 		.host = &quot;${s1_addr}&quot;; 		.port = &quot;${s1_port}&quot;; 	} 	sub vcl_deliver { 		set resp.http.hello = example.hello(&quot;World&quot;); 	} } -start </pre> <p>Now let's learn how <code>varnishtest</code> can mock backends and run clients.</p> <h4>Mocking the backend</h4> <p>The syntax for backends and clients is similar to the syntax for Varnish instances except that instead of VCL, you'll find actions and assertions.</p> <pre> server s1 {        rxreq        txresp } -start </pre> <p>In this case, we are starting a server which answers a response to exactly one request. It could also answer to more requests, it doesn't matter. It would be a problem if the server received more requests than expected, it would timeout and the Varnish instance would send a <code>503 Unavailable</code> response (yet, this is a behaviour you might need to test). Those can be seen as actions: receiving a request (<code>rx</code>) and transmitting (<code>tx</code>) a response.</p> <p>Answering up to two requests:</p> <pre> server s1 {        rxreq        txresp        rxreq        txresp } -start </pre> <p>In addition to actions, you can add assertions. You can expect the server to receive a request with a given url, a specific header... Remember that your client's request goes through a Varnish instance first and the backend request might change in some way you want to check.</p> <pre> server s1 {        rxreq        expect req.url == &quot;/&quot;        txresp } -start </pre> <p>It is of course possible to change the empty default response depending on your use cases.</p> <pre> server s1 {        rxreq        expect req.url == &quot;/index.php?post/2012/07/25/RPM-Maven-Jenkins-1&quot;        txresp -body &quot;A great article :p&quot;        rxreq        expect req.url == &quot;/index.php?post/2012/08/02/RPM-Maven-Jenkins-2&quot;        txresp -body &quot;The second part ;)&quot; } -start </pre> <p>Once you start a server named <code>s1</code>, macros are automatically made available:</p> <ul> <li><code>${s1_addr}</code>&nbsp;: the IP address (127.0.0.1)</li> <li><code>${s1_port}</code>&nbsp;: the port (randomly chosen)</li> <li><code>${s1_sock}</code>&nbsp;: the socket</li> </ul> <p>It is also possible to use a real backend instead of just a mock. Remember that <code>varnishtest</code> launches a real <code>varnishd</code> instance. You could integrate Varnish in your <acronym title="Continuous Integration">CI</acronym> environment and run your own integration or regression tests against your actual application.</p> <h4>Running client requests</h4> <p>Once you have a server and a Varnish, you can start running clients and sending requests. The syntax is the same as for the servers, but instead of expecting requests and answering responses, clients send requests and expect responses.</p> <pre> client c1 { 	txreq -url &quot;/&quot; 	rxresp 	expect resp.http.hello == &quot;Hello, World&quot; } -run </pre> <p>And it's easy to run the same client's scenario multiple times:</p> <pre> client c1 { 	txreq 	rxresp } [...] client c1 -run client c1 -run client c1 -run </pre> <p>And of course a single client can send several requests:</p> <pre> clent c1 { 	txreq -url &quot;/index.php?post/2012/07/25/RPM-Maven-Jenkins-1&quot; 	rxresp 	expect resp.bodylen == 18 	txreq -url &quot;/index.php?post/2012/08/02/RPM-Maven-Jenkins-2&quot; 	rxresp 	expect resp.bodylen == 18 } -run </pre> <p>We've seen that servers and clients are made to embed a scenario with both actions and expectations, embeded in the server or client body. Since a Varnish instance's body contains VCL, is it possible to add assertions&nbsp;? The answer is yes.</p> <h4>Varnish assertions</h4> <p>Unlike clients or servers, Varnish assertions are put outside the instance's declaration body. What can you actually test with Varnish&nbsp;? Since it's a proxy to your backend, checking requests and responses is irrelevant. Instead, you have access to the counters exposed by <code>varnishstat</code> at any time (it doesn't mean that all counters are relevant for testing purpose).</p> <pre> varnish v1 -expect the_counter == the_value </pr
e> <p>Now, how does it look like when you write a test case that does all this&nbsp;?</p> <h3>A more advanced example</h3> <pre> varnishtest &quot;Test example vmod even more&quot; server s1 {        rxreq        expect req.url == &quot;/index.php?post/2012/07/25/RPM-Maven-Jenkins-1&quot;        txresp -body &quot;A great article :p&quot;        rxreq        expect req.url == &quot;/index.php?post/2012/08/02/RPM-Maven-Jenkins-2&quot;        txresp -body &quot;The second part ;)&quot; } -start varnish v1 -vcl+backend { 	import example from &quot;${vmod_topbuild}/src/.libs/libvmod_example.so&quot;; 	sub vcl_deliver { 		set resp.http.hello = example.hello(&quot;World&quot;); 	} } -start client c1 { 	txreq -url &quot;/index.php?post/2012/07/25/RPM-Maven-Jenkins-1&quot; 	rxresp 	expect resp.http.hello == &quot;Hello, World&quot; 	expect resp.bodylen == 18 	txreq -url &quot;/index.php?post/2012/08/02/RPM-Maven-Jenkins-2&quot; 	rxresp 	expect resp.http.hello == &quot;Hello, World&quot; 	expect resp.bodylen == 18 } varnish v1 -expect cache_miss == 0 varnish v1 -expect cache_hit == 0 client c1 -run varnish v1 -expect cache_miss == 2 varnish v1 -expect cache_hit == 0 client c1 -run client c1 -run client c1 -run varnish v1 -expect cache_miss == 2 varnish v1 -expect cache_hit == 6 </pre> <h3>Conclusion</h3> <p>Test preparations, executions and assertions all over the place, didn't I warn you&nbsp;? Yes I did, however, it doesn't mean that you can't write readable tests. On the contrary, the <code>varnishtest</code> DSL is really expressive, especially once you know how to read it. It's also easy to write, even though your test case is exploded (servers + varnish + clients), the isolation of those components makes it simpler IMHO. I should probably mention that <code>varnishtest</code> is not suited for performance tests by design.</p> <p>This is only an introduction to <code>varnishtest</code> but I hope this will answer questions you might ask yourself when writing your first test cases.</p>