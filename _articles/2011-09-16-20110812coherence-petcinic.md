---
ID: 403
post_title: 'Introduction à Coherence: Part I'
author: team-bourgain-tinon
post_date: 2011-09-16 12:30:00
post_excerpt: "<p>Oracle Coherence entre dans la catégorie relativement fermée des In Memory Data Grids. Initialement édité par la société Tangosol, Coherence a ensuite été rachetée par Oracle et se positionne sur le même marché que GigaSpaces (GigaSpaces), GemFire (VMWare/SpringSource) ou Websphere eXtreme Scale (IBM).</p> <p>Le parti pris par les solutions d'In Memory Data Grid (IMDG) consiste à déporter le stockage primaire des données du disque vers la mémoire dans le but principal de gagner en performances.</p> <p>Cependant, la mémoire étant volatile et en quantité plus limitée que le disque, les gains de performances s'accompagnent de contraintes nouvelles dès lors que l'on souhaite prévenir toute perte en cas de défaillance du système. La solution consiste généralement à mettre en place un système distribué où un cluster de machines se répartissent l'ensemble des données. Mais cela introduit d'autres contraintes: que se passe-t-il si une partie des machines tombe ou se retrouve isolée suite à un problème réseau&nbsp;? Comment synchroniser les données au sein du cluster&nbsp;?</p>"
layout: post
permalink: http://blog.zenika-offres.com/?p=403
published: true
slide_template:
  - ""
---
<p>Oracle Coherence entre dans la catégorie relativement fermée des In Memory Data Grids. Initialement édité par la société Tangosol, Coherence a ensuite été rachetée par Oracle et se positionne sur le même marché que GigaSpaces (GigaSpaces), GemFire (VMWare/SpringSource) ou Websphere eXtreme Scale (IBM).</p> <p>Le parti pris par les solutions d'In Memory Data Grid (IMDG) consiste à déporter le stockage primaire des données du disque vers la mémoire dans le but principal de gagner en performances.</p> <p>Cependant, la mémoire étant volatile et en quantité plus limitée que le disque, les gains de performances s'accompagnent de contraintes nouvelles dès lors que l'on souhaite prévenir toute perte en cas de défaillance du système. La solution consiste généralement à mettre en place un système distribué où un cluster de machines se répartissent l'ensemble des données. Mais cela introduit d'autres contraintes: que se passe-t-il si une partie des machines tombe ou se retrouve isolée suite à un problème réseau&nbsp;? Comment synchroniser les données au sein du cluster&nbsp;?</p>
<!--more-->
<p>Les IMDG présentent aussi une rupture importante par rapport aux bases de données relationnelles: les données sont manipulées directement sous forme de graphes d'objets; le modèle et la plupart des opérations doivent être pensées différemment. Cependant, la nature distribuée des IMDG offre de nouvelles possibilités comme l'envoi et l'exécution d'un traitement directement sur les machines qui portent les données à manipuler: le traitement est hautement parallélisé et toute la puissance de calcul du cluster peut être utilisée. Ce type d'architecture permet aussi d'améliorer la scalabilité de l'application puisque l'ajout de nouvelles machines augmente les capacités de stockage et de calcul.</p> <p>Dans une série d'article, nous présenterons Oracle Coherence à travers sa mise en place dans la célèbre application de démonstration de SpringSource PetClinic en remplacement de la base de données relationnelle. Dans ce premier billet, nous allons introduire Coherence comme un cache distribué simpliste devant la base de données.</p> <p><a name="get-the-stuff"></a></p> <h3>Time to get your hands dirty</h3> <h4>Get the stuff</h4> <p>Nous vous proposons donc de récupérer le <a href="http://www.oracle.com/technetwork/middleware/coherence/downloads/coherence-101246.html">jar Coherence</a> ainsi que le projet PetClinic. il y en a pour tous les goûts&nbsp;:</p> <ul> <li>github</li> </ul> <pre class="bash code bash" style="font-family:inherit">git clone <span style="color: #660033;">-n</span> git:<span style="color: #000000; font-weight: bold;">//</span>github.com<span style="color: #000000; font-weight: bold;">/</span>obourgain<span style="color: #000000; font-weight: bold;">/</span>petclinic-coherence.git git checkout article1-start</pre> <ul> <li>Subversion</li> </ul> <pre class="bash code bash" style="font-family:inherit"><span style="color: #c20cb9; font-weight: bold;">svn</span> <span style="color: #c20cb9; font-weight: bold;">co</span> https:<span style="color: #000000; font-weight: bold;">//</span>src.springframework.org<span style="color: #000000; font-weight: bold;">/</span><span style="color: #c20cb9; font-weight: bold;">svn</span><span style="color: #000000; font-weight: bold;">/</span>spring-samples<span style="color: #000000; font-weight: bold;">/</span>petclinic<span style="color: #000000; font-weight: bold;">/</span>trunk .<span style="color: #000000; font-weight: bold;">/</span>petclinic</pre> <ul> <li><a href="/wp-content/uploads/2015/07/petclinic-coherence.zip">petclinic-coherence.zip</a></li> </ul> <p>Vous aurez aussi besoin de Maven et d'un serveur d'application, type <a href="http://tomcat.apache.org/download-70.cgi">Tomcat</a>, pour faire fonctionner l'application.</p> <h4>Get ready</h4> <p>Faites un checkout ou dézippez le projet PetClinic et importez-le dans votre IDE préféré. Dans Eclipse, ouvrir la vue "Servers" et ajoutez un serveur Tomcat (clic droit &gt; new server &gt; ...). Puis ajouter le projet Petclinic à ce serveur. Enfin, ouvrir la vue du serveur et vérifier que le "Path" de Petclinic est bien "/petclinic" (clic droit sur le serveur &gt; open &gt; onglet modules).</p> <p>Dézippez l'archive Coherence et installez le coherence.jar (situé dans lib) dans votre repo Maven&nbsp;:</p> <pre class="bash code bash" style="font-family:inherit">mvn <span style="color: #c20cb9; font-weight: bold;">install</span>:install-file -<span style="color: #007800;">DgroupId</span>=com.oracle -<span style="color: #007800;">DartifactId</span>=coherence -<span style="color: #007800;">Dversion</span>=3.7.0.0b23397 -<span style="color: #007800;">Dfile</span>=<span style="color: #000000; font-weight: bold;">&lt;</span>path_to_your_jar_file<span style="color: #000000; font-weight: bold;">&gt;</span> -<span style="color: #007800;">Dpackaging</span>=jar</pre> <p>Dans le pom.xml du projet, ajouter&nbsp;:</p> <pre class="xml code xml" style="font-family:inherit"><span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;dependencies<span style="color: #000000; font-weight: bold;">&gt;</span></span></span> 	... 	<span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;dependency<span style="color: #000000; font-weight: bold;">&gt;</span></span></span> 		<span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;groupId<span style="color: #000000; font-weight: bold;">&gt;</span></span></span>com.oracle<span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;/groupId<span style="color: #000000; font-weight: bold;">&gt;</span></span></span> 		<span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;artifactId<span style="color: #000000; font-weight: bold;">&gt;</span></span></span>coherence<span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;/artifactId<span style="color: #000000; font-weight: bold;">&gt;</span></span></span> 		<span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;version<span style="color: #000000; font-weight: bold;">&gt;</span></span></span>3.7.0.0b23397<span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;/version<span style="color: #000000; font-weight: bold;">&gt;</span></span></span> 	<span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;/dependency<span style="color: #000000; font-weight: bold;">&gt;</span></span></span> 	... <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;/dependencies<span style="color: #000000; font-weight: bold;">&gt;</span></span></span></pre> <p>Nous sommes presque prêts à lancer l'application mais il reste une précaution à prendre. Au démarrage, Coherence va automatiquement chercher sur le réseau un cluster existant et tenter de le rejoindre. Afin d'éviter tout problème en développant, il est recommandé de s'isoler en limitant le <em>Time To Live</em> des paquets réseaux émis par Coherence. Pour celà, il suffit d'ajouter la propriété suivante à la ligne de commande de démarrage de Tomcat.</p> <pre class="bash code bash" style="font-family:inherit">-Dtangosol.coherence.ttl=0</pre> <p>Cette ligne de commande est accessible dans Eclipse par le menu run &gt; run configurations ... &gt; tomcat dans l'onglet "Arguments". Ajouter la propriété à la fin des "VM Arguments"</p> <p>Lancez l'application et connectez vous avec votre navigateur à l'url <a href="http://localhost:8080/petclinic" title="http://localhost:8080/petclinic">http://localhost:8080/petclinic</a> pour vérifier que tout fonctionne jusque là.</p> <h5>Disclaimer</h5> <p>L'organisation des caches n'est volontairement pas optimale, mais a été choisie dans le but de présenter les features de Coherence de façon incrémentale et en respectant le modèle déjà existant dans PetClinic. Le code sera aussi dans un premier temps non optimal pour les mêmes raisons.</p> <h3>Let's code&nbsp;!</h3> <p>Nous allons maintenant introduire Coherence dans l'application pour commencer à remplacer la base de donnée. Cette première implémentation triviale va gèrer les <strong>Owner</strong>s dans un cache Coherence et déléguer le reste des opérations à la <strong>SimpleJdbcClinic</strong>.</p> <p>Créez la classe <strong>com.zenika.petclinic.coherence.CoherenceClinic</strong> qui implémente <strong>Clinic</strong>. Ajoutez un champ <strong>jdbcClinic</strong> de type <strong>Clinic</strong> et le setter correspondant.</p> <pre class="java code java" style="font-family:inherit"><span style="color: #7F0055; font-weight: bold;">private</span> Clinic jdbcClinic; &nbsp; <span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">void</span> setJdbcClinic<span style="color: #000000;">&#40;</span>Clinic jdbcClinic<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> 	<span style="color: #7F0055; font-weight: bold;">this</span>.<span style="color: #000000;">jdbcClinic</span> = jdbcClinic; <span style="color: #000000;">&#125;</span></pre> <p>Tou
tes les méthodes sauf <strong>loadOwner()</strong>, <strong>findOwners()</strong> et <strong>storeOwner()</strong> vont déléguer leur traitement à la méthode correspondante de la SimpleJdbcClinic sous-jacente avec un code similaire à celui ci&nbsp;:</p> <pre class="java code java" style="font-family:inherit"><span style="color: #7F0055; font-weight: bold;">public</span> Collection<span style="color: #000000;">&lt;</span>PetType<span style="color: #000000;">&gt;</span> getPetTypes<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #7F0055; font-weight: bold;">throws</span> DataAccessException <span style="color: #000000;">&#123;</span> 	<span style="color: #7F0055; font-weight: bold;">return</span> jdbcClinic.<span style="color: #000000;">getPetTypes</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>; <span style="color: #000000;">&#125;</span></pre> <h4>Mise en place du cache au niveau des Owners</h4> <p>Nous allons dans un premier temps conserver le stockage en base de données et utiliser Coherence comme un cache standard pour les <strong>Owner</strong>s, <strong>Pet</strong>s et <strong>Visit</strong>s. Le modèle actuel lie directement ces trois entités en un graphe d'objets simple que nous allons conserver. Notre cache stockera donc un ensemble d'entrées dont la racine sera le <strong>Owner</strong>.</p> <p>Avant toute chose, nous avons besoin d'obtenir une référence sur un cache. Nous allons utiliser le cache nommé <strong>exemple-distributed</strong> défini dans le fichier <strong>coherence-cache-config.xml</strong> du jar Coherence. Ce cache par défaut suffira pour le moment, nous verrons dans le prochain article comment configurer nos propres caches. La <strong>CacheFactory</strong> est le point d'entrée pour accéder aux caches Coherence&nbsp;:</p> <pre class="java code java" style="font-family:inherit"><span style="color: #7F0055; font-weight: bold;">private</span> NamedCache getOwnersCache<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> 	<span style="color: #7F0055; font-weight: bold;">return</span> CacheFactory.<span style="color: #000000;">getCache</span><span style="color: #000000;">&#40;</span><span style="color: #888888;">&quot;example-distributed&quot;</span><span style="color: #000000;">&#41;</span>; <span style="color: #000000;">&#125;</span></pre> <p>Le <strong>NamedCache</strong> que retourne la <strong>CacheFactory</strong> implémente l'interface <strong>java.util.Map</strong>. Nous allons donc pour le moment le manipuler comme tel en prenant comme clé l'id (<strong>Integer</strong>) du <strong>Owner</strong>.</p> <ul> <li><strong>storeOwner()</strong></li> </ul> <pre class="java code java" style="font-family:inherit"><span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">void</span> storeOwner<span style="color: #000000;">&#40;</span><span style="color: #000000;">Owner</span> owner<span style="color: #000000;">&#41;</span> <span style="color: #7F0055; font-weight: bold;">throws</span> DataAccessException <span style="color: #000000;">&#123;</span> 	<span style="color: #808080; font-style: italic;">// store the owner in database to maintain consistency as we don't yet cache everything</span> 	<span style="color: #808080; font-style: italic;">// we also still rely on this call to generate the owner's id</span> 	jdbcClinic.<span style="color: #000000;">storeOwner</span><span style="color: #000000;">&#40;</span>owner<span style="color: #000000;">&#41;</span>; &nbsp; 	<span style="color: #808080; font-style: italic;">// put the owner in the cache</span> 	getOwnersCache<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>.<span style="color: #000000;">put</span><span style="color: #000000;">&#40;</span>owner.<span style="color: #000000;">getId</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>, owner<span style="color: #000000;">&#41;</span>; <span style="color: #000000;">&#125;</span></pre> <ul> <li><strong>loadOwner()</strong></li> </ul> <pre class="java code java" style="font-family:inherit"><span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #000000;">Owner</span> loadOwner<span style="color: #000000;">&#40;</span><span style="color: #7F0055; font-weight: bold;">int</span> id<span style="color: #000000;">&#41;</span> <span style="color: #7F0055; font-weight: bold;">throws</span> DataAccessException <span style="color: #000000;">&#123;</span> 	<span style="color: #808080; font-style: italic;">// search in the cache by key</span> 	<span style="color: #000000;">Owner</span> owner = <span style="color: #000000;">&#40;</span><span style="color: #000000;">Owner</span><span style="color: #000000;">&#41;</span> getOwnersCache<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>.<span style="color: #000000;">get</span><span style="color: #000000;">&#40;</span>id<span style="color: #000000;">&#41;</span>; 	<span style="color: #7F0055;font-weight: bold;">if</span> <span style="color: #000000;">&#40;</span>owner == <span style="color: #7F0055; font-weight: bold;">null</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> 		<span style="color: #808080; font-style: italic;">// if not in cache, try to load from the database</span> 		owner = jdbcClinic.<span style="color: #000000;">loadOwner</span><span style="color: #000000;">&#40;</span>id<span style="color: #000000;">&#41;</span>; 		<span style="color: #7F0055;font-weight: bold;">if</span> <span style="color: #000000;">&#40;</span>owner <span style="color: #000000;">!</span>= <span style="color: #7F0055; font-weight: bold;">null</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> 			<span style="color: #808080; font-style: italic;">// cache it</span> 			getOwnersCache<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>.<span style="color: #000000;">put</span><span style="color: #000000;">&#40;</span>id, owner<span style="color: #000000;">&#41;</span>; 		<span style="color: #000000;">&#125;</span> 	<span style="color: #000000;">&#125;</span> 	<span style="color: #7F0055; font-weight: bold;">return</span> owner; <span style="color: #000000;">&#125;</span></pre> <ul> <li><strong>findOwners()</strong></li> </ul> <pre class="java code java" style="font-family:inherit"><span style="color: #7F0055; font-weight: bold;">public</span> Collection<span style="color: #000000;">&lt;</span>Owner<span style="color: #000000;">&gt;</span> findOwners<span style="color: #000000;">&#40;</span><span style="color: #000000;">String</span> lastName<span style="color: #000000;">&#41;</span> <span style="color: #7F0055; font-weight: bold;">throws</span> DataAccessException <span style="color: #000000;">&#123;</span> 	<span style="color: #808080; font-style: italic;">// load from the database and cache all matching results</span> 	Collection<span style="color: #000000;">&lt;</span>Owner<span style="color: #000000;">&gt;</span> owners = jdbcClinic.<span style="color: #000000;">findOwners</span><span style="color: #000000;">&#40;</span>lastName<span style="color: #000000;">&#41;</span>; &nbsp; 	<span style="color: #808080; font-style: italic;">// inserts are batched to improve performance</span> 	Map<span style="color: #000000;">&lt;</span>Integer, Owner<span style="color: #000000;">&gt;</span> ownersMap = <span style="color: #7F0055; font-weight: bold;">new</span> HashMap<span style="color: #000000;">&lt;</span>Integer, Owner<span style="color: #000000;">&gt;</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>; 	<span style="color: #7F0055;font-weight: bold;">for</span> <span style="color: #000000;">&#40;</span><span style="color: #000000;">Owner</span> owner : owners<span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span> 		ownersMap.<span style="color: #
000000;">put</span><span style="color: #000000;">&#40;</span>owner.<span style="color: #000000;">getId</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>, owner<span style="color: #000000;">&#41;</span>; 	<span style="color: #000000;">&#125;</span> 	getOwnersCache<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>.<span style="color: #000000;">putAll</span><span style="color: #000000;">&#40;</span>ownersMap<span style="color: #000000;">&#41;</span>; &nbsp; 	<span style="color: #7F0055; font-weight: bold;">return</span> owners; <span style="color: #000000;">&#125;</span></pre> <p>Pour <strong>loadOwner()</strong>, nous avions utilisé la méthode <strong>put(key, value)</strong> du cache, dans <strong>findOwners()</strong> nous utilisons <strong>putAll(Map)</strong> afin de batcher les insertions. <br />
Dans le cas d'un cache distribué, Coherence va de façon synchrone répartir les données sur le cluster et créer des copies de backup sur des noeuds différents de ceux portant la donnée principale. Les noeuds Coherence utilisent le multicast UDP ainsi qu'une surcouche propriétaire nommée TCMP pour communiquer entre eux. Chaque appel à put() nécessite donc un appel réseau et attend une valeur de retour. L'utilisation de <strong>putAll()</strong> permet d'améliorer les performances pour des insertions multiples en ne faisant qu'un unique appel réseau.</p> <p>Les données sont insérées dans le cache sous forme de graphes d'objets sérialisés. Coherence supporte plusieurs méthodes de sérialisation dont la sérialisation Java et POF, un format propriétaire hautement optimisé. Laissons POF de côté pour le moment et utilisons ici la sérialisation Java standard&nbsp;: tous nos objets doivent donc implémenter <strong>java.io.Serializable</strong>. Ajoutons cette interface à la classe <strong>BaseEntity</strong>&nbsp;:</p> <pre class="java code java" style="font-family:inherit"><span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">class</span> BaseEntity <span style="color: #7F0055; font-weight: bold;">implements</span> <span style="color: #000000;">Serializable</span></pre> <p>Dans notre cas chaque graphe contient un <strong>Owner</strong> en racine avec ses <strong>Pet</strong>s et leurs <strong>Visit</strong>s. Toute modification se fait selon le pattern suivant:</p> <ul> <li>récupération et de-sérialisation de la donnée du cache</li> <li>modification directe des objets du graphe</li> <li>réinsertion/sérialisation dans le cache</li> </ul> <p>Dans notre cas, modifier un <strong>Pet</strong> ou une <strong>Visit</strong> impliquerait de modifier le graphe et de le réinsérer complètement dans le cache à partir du <strong>Owner</strong>. Pour l'instant, nous sommes dans un état intermédiaire et nous allons simplement invalider cette entrée du cache après insertion en base pour les méthodes <strong>storePet()</strong> et <strong>storeVisit()</strong>. Un problème similaire se pose avec la méthode <strong>deletePet()</strong> mais retrouver le <strong>Owner</strong> à partir de l'id du <strong>Pet</strong> requiert l'utilisation de fonctionnalités plus avancées de Coherence que nous découvrirons une autre fois. Pour le moment, cette opération n'invalidera donc pas le cache :) (Nous verrons dans un prochain article comment exécuter des recherches complexes et mettre à jour les données dans le cache)</p> <ul> <li><strong>storePet()</strong> devient donc&nbsp;:</li> </ul> <pre class="java code java" style="font-family:inherit"><span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">void</span> storePet<span style="color: #000000;">&#40;</span>Pet pet<span style="color: #000000;">&#41;</span> <span style="color: #7F0055; font-weight: bold;">throws</span> DataAccessException <span style="color: #000000;">&#123;</span> 	jdbcClinic.<span style="color: #000000;">storePet</span><span style="color: #000000;">&#40;</span>pet<span style="color: #000000;">&#41;</span>; 	getOwnersCache<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>.<span style="color: #000000;">remove</span><span style="color: #000000;">&#40;</span>pet.<span style="color: #000000;">getOwner</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>.<span style="color: #000000;">getId</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>; <span style="color: #000000;">&#125;</span></pre> <ul> <li>De même pour <strong>storeVisit()</strong>&nbsp;:</li> </ul> <pre class="java code java" style="font-family:inherit"><span style="color: #7F0055; font-weight: bold;">public</span> <span style="color: #7F0055; font-weight: bold;">void</span> storeVisit<span style="color: #000000;">&#40;</span>Visit visit<span style="color: #000000;">&#41;</span> <span style="color: #7F0055; font-weight: bold;">throws</span> DataAccessException <span style="color: #000000;">&#123;</span> 	jdbcClinic.<span style="color: #000000;">storeVisit</span><span style="color: #000000;">&#40;</span>visit<span style="color: #000000;">&#41;</span>; 	getOwnersCache<span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>.<span style="color: #000000;">remove</span><span style="color: #000000;">&#40;</span>visit.<span style="color: #000000;">getPet</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>.<span style="color: #000000;">getOwner</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>.<span style="color: #000000;">getId</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span><span style="color: #000000;">&#41;</span>; <span style="color: #000000;">&#125;</span></pre> <h4>Configuration Spring</h4> <p>Copier le fichier <strong>src/main/webapp/WEB-INF/spring/applicationContext-jdbc.xml</strong> en <strong>applicationContext-coherence.xml</strong> et renommer le bean</p> <pre class="xml code xml" style="font-family:inherit"><span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;bean</span> <span style="color: #000066;">id</span>=<span style="color: #ff0000;">&quot;clinic&quot;</span> <span style="color: #000066;">class</span>=<span style="color: #ff0000;">&quot;org.springframework.samples.petclinic.jdbc.SimpleJdbcClinic&quot;</span><span style="color: #000000; font-weight: bold;">/&gt;</span></span></pre> <p>en</p> <pre class="xml code xml" style="font-family:inherit"><span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;bean</span> <span style="color: #000066;">id</span>=<span style="color: #ff0000;">&quot;jdbcClinic&quot;</span> <span style="color: #000066;">class</span>=<span style="color: #ff0000;">&quot;org.springframework.samples.petclinic.jdbc.SimpleJdbcClinic&quot;</span><span style="color: #000000; font-weight: bold;">/&gt;</span></span></pre> <p>puis ajouter le bean</p> <pre class="xml code xml" style="font-family:inherit"><span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;bean</span> <span style="color: #000066;">id</span>=<span style="color: #ff0000;">&quot;clinic&quot;</span> <span style="color: #000066;">class</span>=<span style="color: #ff0000;">&quot;com.zenika.petclinic.coherence.CoherenceClinic&quot;</span><span style="color: #000000; font-weight: bold;">&gt;</span></span>     <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;property</span> <span style="color: #000066;">name</span>=<span style="color: #ff0000;">&quot;jdbcClinic&quot;</span> <span style="color: #000066;">ref</span>=<span style="color: #ff0000;">&quot;jdbcClinic&quot;</span> <span style="color: #000000; font-weight: bold;">/&gt;</span></span> <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;/bean<span style="color: #000000; font-weight: bold;">&gt;</span></span></span></pre> <p>Pour que l'application utilise notre nouveau contexte, nous allons modifier le fichier <strong>src/main/webapp/WEB-INF/web.xml</strong>. Trouvez la balise &lt;context-param&gt; et remplacez</p> <pre class="xml code xml" style="font-family:inherit"><span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;param-value<span style="color: #000000; font-weight: bold;">&gt;</span></span></span>/WEB-INF/spring/applicationContext-jdbc.xml<span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;/param-value<span style="color: #000000; font-weight: bold;">&gt;</span></span></span></pre> <p>par</p> <pre class="xml code xml" style="font-family:inherit"><span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;param-value<span style="color: #000000; font-weight: bold;">&gt;</span></span></span>/WEB-INF/spring/applicationConte
xt-coherence.xml<span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;/param-value<span style="color: #000000; font-weight: bold;">&gt;</span></span></span></pre> <h3>The end</h3> <p>Et voilà, notre application est prête à tourner. Vous pouvez tester et vérifer que tout fonctionne. Lors du premier accès au cache, vous pourrez constater dans les logs que Coherence s'initialise et créé un nouveau cluster.</p> <p>Pour les moins courageux, vous pouvez récupérer le résultat final sur Github&nbsp;:</p> <pre class="bash code bash" style="font-family:inherit">git clone <span style="color: #660033;">-n</span> git:<span style="color: #000000; font-weight: bold;">//</span>github.com<span style="color: #000000; font-weight: bold;">/</span>obourgain<span style="color: #000000; font-weight: bold;">/</span>petclinic-coherence.git git checkout article1-end</pre> <p>ou en <a href="/wp-content/uploads/2015/07/petclinic-coherence-article1-end.zip">zip</a></p> <p>A très bientôt pour le prochain épisode: mise en place de nos propres caches et retrait de la base de données&nbsp;! <br />
<em>Article co-écrit par Guillaume Tinon et Olivier Bourgain.</em></p> <p>Index des articles de la série Coherence&nbsp;:</p> <ul> <li><a href="index.php?post/2011/08/12/Coherence-PetCinic">Introduction à Coherence: Part I</a></li> <li><a href="index.php?post/2011/08/25/Introduction-à-Coherence%3A-Part-II">Introduction à Coherence: Part II</a></li> <li><a href="index.php?post/2011/10/07/Introduction-à-Coherence%3A-Part-III">Coherence Part III&nbsp;: Filtres</a></li> <li><a href="index.php?post/2012/01/09/Coherence-Part-IV-%3A-extracteurs-et-recherches-distribuées-sur-le-cluster">Coherence Part IV&nbsp;: extracteurs et recherches distribuées sur le cluster</a></li> <li><a href="index.php?post/2012/01/03/Coherence-Part-IV-%3A-optimisations-des-requêtes-avec-des-index6">Coherence Part V&nbsp;: optimisations des requêtes avec des index</a></li> <li><a href="index.php?post/2012/01/06/Coherence-Part-VI-%3A-traitement-de-données-distribuées%2C-in-place-processing4">Coherence Part VI&nbsp;: traitement de données distribuées, concurrence et in-place processing</a></li> </ul>